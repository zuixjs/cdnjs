{"version":3,"sources":["vs/editor/common/services/editorSimpleWorker.js","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/base/common/diff/diffChange.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/base/common/diff/diff.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/base/common/filters.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/base/common/uri.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/core/arrays.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/core/modeTransition.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/core/position.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/core/range.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/diff/diffComputer.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/modes/linkComputer.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/modes/supports/inplaceReplaceSupport.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/services/editorSimpleWorkerCommon.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/viewModel/prefixSumComputer.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/model/mirrorModel2.ts","vs/editor/common/services/fake","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/config/defaultConfig.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/modes/nullMode.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/model/textModelWithTokensHelpers.ts","vs/editor/common/services/file:/C:/Alex/src/vscode/src/vs/editor/common/services/editorSimpleWorker.ts"],"names":["define","require","exports","DifferenceType","Add","Remove","Change","DiffChange","originalStart","originalLength","modifiedStart","modifiedLength","this","prototype","getChangeType","getOriginalEnd","getModifiedEnd","diffChange_1","Debug","Assert","condition","message","Error","MyArray","Copy","sourceArray","sourceIndex","destinationArray","destinationIndex","length","i","MaxDifferencesHistory","DiffChangeHelper","m_changes","m_originalStart","Number","MAX_VALUE","m_modifiedStart","m_originalCount","m_modifiedCount","MarkNextChange","push","AddOriginalElement","originalIndex","modifiedIndex","Math","min","AddModifiedElement","getChanges","getReverseChanges","reverse","LcsDiff","originalSequence","newSequence","continueProcessingPredicate","OriginalSequence","ModifiedSequence","ContinueProcessingPredicate","m_originalIds","m_modifiedIds","m_forwardHistory","m_reverseHistory","ComputeUniqueIdentifiers","originalSequenceLength","getLength","modifiedSequenceLength","Array","hashTable","currentUniqueId","originalElementHash","getElementHash","hasOwnProperty","modifiedElementHash","ElementsAreEqual","newIndex","ComputeDiff","_ComputeDiff","originalEnd","modifiedEnd","quitEarlyArr","ComputeDiffRecursive","changes","midOriginalArr","midModifiedArr","result","ComputeRecursionPoint","midOriginal","midModified","leftChanges","rightChanges","ConcatenateChanges","WALKTRACE","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","diagonal","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","MIN_VALUE","historyIndex","originalStartPoint","modifiedStartPoint","lastForwardChange","max","numDifferences","maxDifferences","numDiagonals","delta","tempOriginalIndex","furthestOriginalIndex","furthestModifiedIndex","ClipDiagonalBound","abs","matchLengthOfLongest","temp","left","right","mergedChangeArr","ChangesOverlap","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven","strings","map_1","or","filter","_i","arguments","word","wordToMatchAgainst","len","match","and","concat","_matchesPrefix","ignoreCase","toLowerCase","start","end","matchesContiguousSubString","index","indexOf","matchesSubString","_matchesSubString","j","join","isLower","code","isUpper","isNumber","isWhitespace","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","charCodeAt","_matchesCamelCase","nextUpperIndex","isCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isCamelCasePattern","whitespace","matchesCamelCase","matchesWords","target","_matchesWords","nextWord","nextWordIndex","matchesFuzzy","enableSeparateSubstringMatching","regexp","fuzzyRegExpCache","get","RegExp","convertSimple2RegExpPattern","set","exec","fuzzySeparateFilter","fuzzyContiguousFilter","matchesStrictPrefix","matchesPrefix","SubstringMatching","LinkedMap","platform","_encode","ch","toString","toUpperCase","encodeURIComponent2","str","encodeURIComponent","replace","encodeNoop","URI","_scheme","_empty","_authority","_path","_query","_fragment","_formatted","_fsPath","Object","defineProperty","enumerable","configurable","value","scheme","_driveLetterPath","test","substr","isWindows","change","ret","authority","path","query","fragment","_validate","parse","data","_parseComponents","decodeURIComponent","file","_slash","idx","substring","_regexp","create","skipEncoding","_asFormatted","uri","encoder","parts","m","_upperCaseDrive","lastIdx","toJSON","fsPath","external","$mid","revive","Arrays","findIndexInSegmentsArray","arr","desiredIndex","low","high","mid","ceil","startIndex","arrays_1","ModeTransition","mode","modeTransitions","modeTransition","Position","lineNumber","column","equals","other","a","b","isBefore","isBeforeOrEqual","clone","lift","pos","isIPosition","obj","asEmptyRange","position","startLineNumber","startColumn","endLineNumber","endColumn","startPosition","range","endPosition","position_1","Range","isEmpty","containsPosition","containsRange","plusRange","intersectRanges","equalsRange","getEndPosition","getStartPosition","cloneRange","setEndPosition","setStartPosition","collapseToStart","isIRange","otherRange","areIntersectingOrTouching","resultStartLineNumber","resultStartColumn","resultEndLineNumber","resultEndColumn","otherStartLineNumber","otherStartColumn","otherEndLineNumber","otherEndColumn","compareRangesUsingStarts","aStartLineNumber","bStartLineNumber","aStartColumn","bStartColumn","aEndLineNumber","bEndLineNumber","aEndColumn","bEndColumn","compareRangesUsingEnds","spansMultipleLines","__extends","d","__","constructor","p","diff_1","computeDiff","modifiedSequence","diffAlgo","postProcessCharChanges","rawChanges","originalMatchingLength","modifiedMatchingLength","matchingLength","currChange","prevChange","MINIMUM_MATCHING_CHARACTER_LENGTH","MAXIMUM_RUN_TIME","MarkerSequence","buffer","startMarkers","endMarkers","otherMarkerSequence","myElement","otherElement","offset","getStartLineNumber","getStartColumn","getEndLineNumber","getEndColumn","LineMarkerSequence","_super","lines","shouldIgnoreTrimWhitespace","_getFirstNonBlankColumn","_getLastNonBlankColumn","call","txt","defaultValue","r","firstNonWhitespaceIndex","lastNonWhitespaceIndex","getCharSequence","endIndex","startMarker","endMarker","CharChange","diffChange","originalCharSequence","modifiedCharSequence","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","LineChange","originalLineSequence","modifiedLineSequence","shouldPostProcessCharChanges","charChanges","DiffComputer","originalLines","modifiedLines","opts","maximumRunTimeMs","original","modified","shouldConsiderTrimWhitespaceInEmptyCase","computationStartTime","Date","getTime","_continueProcessingPredicate","bind","lineChanges","now","computeLinks","model","getLineCount","getLineContent","LinkComputer","STATE_MAP","START_STATE","END_STATE","ACCEPT_STATE","h","H","f","F","t","T","P","s","S",":","/","I","l","L","e","E","CharacterClass","_openParens","_closeParens","_openSquareBracket","_closeSquareBracket","_openCurlyBracket","_closeCurlyBracket","CharacterClassifier","FORCE_TERMINATION_CHARACTERS","CANNOT_END_WITH_CHARACTERS","_asciiMap","None","_map","_set","ForceTermination","CannotEndIn","charCode","charClass","classify","_createLink","line","linkBeginIndex","linkEndIndex","url","lineCount","lastIncludedCharIndex","state","chCode","chClass","resetStateMachine","hasOpenParens","hasOpenSquareBracket","hasOpenCurlyBracket","characterClassifier","_characterClassifier","charAt","BasicInplaceReplace","_defaultValueSet","navigateValueSet","range1","text1","range2","text2","up","doNavigateValueSet","text","numberResult","numberReplace","textReplace","precision","pow","lastIndexOf","n1","n2","parseFloat","isNaN","floor","String","valueSetsReplace","valueSets","valueSetReplace","valueSet","INSTANCE","EditorSimpleWorker","acceptNewModel","acceptModelChanged","modelUrl","events","acceptRemovedModel","originalUrl","modifiedUrl","ignoreTrimWhitespace","computeDirtyDiff","textualSuggest","wordDef","wordDefFlags","PrefixSumIndexOfResult","remainder","PrefixSumComputer","values","prefixSum","prefixSumValidIndex","getCount","insertValue","insertIndex","splice","insertValues","slice","_zeroArray","count","changeValue","removeValues","cnt","getTotalValue","getAccumulatedValue","getIndexOf","accumulatedValue","midStop","midStart","prefixSumComputer_1","MirrorModel2","eol","versionId","_uri","_lines","_eol","_versionId","dispose","getText","onEvents","newEOL","_lineStarts","lastVersionId","_acceptDeleteRange","_acceptInsertText","_ensureLineStarts","lineStartValues","eolLength","_setLineText","lineIndex","newValue","insertText","insertLines","split","newLengths","nls","USUAL_WORD_SEPARATORS","DEFAULT_INDENTATION","tabSize","insertSpaces","detectIndentation","DEFAULT_TRIM_AUTO_WHITESPACE","DEFAULT_WINDOWS_FONT_FAMILY","DEFAULT_MAC_FONT_FAMILY","DEFAULT_LINUX_FONT_FAMILY","GOLDEN_LINE_HEIGHT_RATIO","isMacintosh","ConfigClass","editor","experimentalScreenReader","rulers","wordSeparators","selectionClipboard","ariaLabel","localize","lineNumbers","selectOnLineNumbers","lineNumbersMinChars","glyphMargin","lineDecorationsWidth","revealHorizontalRightPadding","roundedSelection","theme","readOnly","scrollbar","verticalScrollbarSize","horizontal","useShadows","verticalHasArrows","horizontalHasArrows","overviewRulerLanes","cursorBlinking","cursorStyle","fontLigatures","disableTranslate3d","hideCursorInOverviewRuler","scrollBeyondLastLine","automaticLayout","wrappingColumn","wrappingIndent","wordWrapBreakBeforeCharacters","wordWrapBreakAfterCharacters","wordWrapBreakObtrusiveCharacters","tabFocusMode","hover","contextmenu","mouseWheelScrollSensitivity","quickSuggestions","quickSuggestionsDelay","iconsInSuggestions","autoClosingBrackets","formatOnType","suggestOnTriggerCharacters","acceptSuggestionOnEnter","selectionHighlight","outlineMarkers","referenceInfos","folding","renderWhitespace","indentGuides","useTabStops","fontFamily","isLinux","fontSize","lineHeight","DefaultConfig","defaultConfig_1","nullTokenize","deltaOffset","stopAtOffset","tokens","type","actualStopOffset","endState","NullState","stateData","stateDataClone","getMode","otherStateData","getStateData","tokenize","stream","advanceToEOS","setStateData","NullMode","richEditSupport","wordDefinition","DEFAULT_WORD_REGEXP","createWordRegExp","allowInWords","usualSeparators","source","getId","ID","toSimplifiedMode","nullMode_1","modeTransition_1","WordHelper","_safeGetWordDefinition","ensureValidWordDefinition","global","flags","multiline","lastIndex","massageWordDefinitionOf","_getWordAtColumn","modeIndex","modeStartIndex","modeEndIndex","_getWordAtText","getWordAtPosition","textSource","_lineIsTokenized","_getLineModeTransitions","columnIndex","textOffset","k","startWord","endWord","words","trim","uri_1","winjs_base_1","range_1","filters_1","diffComputer_1","mirrorModel2_1","textModelWithTokensHelpers_1","linkComputer_1","inplaceReplaceSupport_1","editorSimpleWorkerCommon_1","EditorSimpleWorkerImpl","MirrorModel","apply","getLinesContent","wordAtText","getWordUntilPosition","wordAtPosition","_getAllWords","_this","forEach","_wordenize","info","getAllUniqueWords","skipWordOnce","foundSkipWord","uniqueWords","content","getValueInRange","lineEnding","startLineIndex","endLineIndex","resultLines","_models","EOL","strURL","diffComputer","TPromise","as","_suggestFiltered","wordDefRegExp","_suggestUnfiltered","currentWord","suggestions","element","label","incomplete","allWords","map","codeSnippet","noAutoAccept","selectionText","wordRange"],"mappings":"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","file":"vs/editor/common/services/editorSimpleWorker.js","sourcesContent":["/*!-----------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.2.3(84e204b238a1eff25d4c6f611fdcd76a494005a7)\n * Released under the MIT license\n * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt\n *-----------------------------------------------------------*/\n\ndefine(\"vs/base/common/diff/diffChange\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    exports.DifferenceType = {\r\n        Add: 0,\r\n        Remove: 1,\r\n        Change: 2\r\n    };\r\n    /**\r\n     * Represents information about a specific difference between two sequences.\r\n     */\r\n    var DiffChange = (function () {\r\n        /**\r\n         * Constructs a new DiffChange with the given sequence information\r\n         * and content.\r\n         */\r\n        function DiffChange(originalStart, originalLength, modifiedStart, modifiedLength) {\r\n            //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\r\n            this.originalStart = originalStart;\r\n            this.originalLength = originalLength;\r\n            this.modifiedStart = modifiedStart;\r\n            this.modifiedLength = modifiedLength;\r\n        }\r\n        /**\r\n         * The type of difference.\r\n         */\r\n        DiffChange.prototype.getChangeType = function () {\r\n            if (this.originalLength === 0) {\r\n                return exports.DifferenceType.Add;\r\n            }\r\n            else if (this.modifiedLength === 0) {\r\n                return exports.DifferenceType.Remove;\r\n            }\r\n            else {\r\n                return exports.DifferenceType.Change;\r\n            }\r\n        };\r\n        /**\r\n         * The end point (exclusive) of the change in the original sequence.\r\n         */\r\n        DiffChange.prototype.getOriginalEnd = function () {\r\n            return this.originalStart + this.originalLength;\r\n        };\r\n        /**\r\n         * The end point (exclusive) of the change in the modified sequence.\r\n         */\r\n        DiffChange.prototype.getModifiedEnd = function () {\r\n            return this.modifiedStart + this.modifiedLength;\r\n        };\r\n        return DiffChange;\r\n    }());\r\n    exports.DiffChange = DiffChange;\r\n});\r\n\ndefine(\"vs/base/common/diff/diff\", [\"require\", \"exports\", 'vs/base/common/diff/diffChange'], function (require, exports, diffChange_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    //\r\n    // The code below has been ported from a C# implementation in VS\r\n    //\r\n    var Debug = (function () {\r\n        function Debug() {\r\n        }\r\n        Debug.Assert = function (condition, message) {\r\n            if (!condition) {\r\n                throw new Error(message);\r\n            }\r\n        };\r\n        return Debug;\r\n    }());\r\n    exports.Debug = Debug;\r\n    var MyArray = (function () {\r\n        function MyArray() {\r\n        }\r\n        /**\r\n         * Copies a range of elements from an Array starting at the specified source index and pastes\r\n         * them to another Array starting at the specified destination index. The length and the indexes\r\n         * are specified as 64-bit integers.\r\n         * sourceArray:\r\n         *\t\tThe Array that contains the data to copy.\r\n         * sourceIndex:\r\n         *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\r\n         * destinationArray:\r\n         *\t\tThe Array that receives the data.\r\n         * destinationIndex:\r\n         *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\r\n         * length:\r\n         *\t\tA 64-bit integer that represents the number of elements to copy.\r\n         */\r\n        MyArray.Copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\r\n            for (var i = 0; i < length; i++) {\r\n                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\r\n            }\r\n        };\r\n        return MyArray;\r\n    }());\r\n    exports.MyArray = MyArray;\r\n    //*****************************************************************************\r\n    // LcsDiff.cs\r\n    //\r\n    // An implementation of the difference algorithm described in\r\n    // \"An O(ND) Difference Algorithm and its letiations\" by Eugene W. Myers\r\n    //\r\n    // Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\r\n    //*****************************************************************************\r\n    // Our total memory usage for storing history is (worst-case):\r\n    // 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\r\n    // 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\r\n    var MaxDifferencesHistory = 1447;\r\n    //let MaxDifferencesHistory = 100;\r\n    /**\r\n     * A utility class which helps to create the set of DiffChanges from\r\n     * a difference operation. This class accepts original DiffElements and\r\n     * modified DiffElements that are involved in a particular change. The\r\n     * MarktNextChange() method can be called to mark the separation between\r\n     * distinct changes. At the end, the Changes property can be called to retrieve\r\n     * the constructed changes.\r\n     */\r\n    var DiffChangeHelper = (function () {\r\n        /**\r\n         * Constructs a new DiffChangeHelper for the given DiffSequences.\r\n         */\r\n        function DiffChangeHelper() {\r\n            this.m_changes = [];\r\n            this.m_originalStart = Number.MAX_VALUE;\r\n            this.m_modifiedStart = Number.MAX_VALUE;\r\n            this.m_originalCount = 0;\r\n            this.m_modifiedCount = 0;\r\n        }\r\n        /**\r\n         * Marks the beginning of the next change in the set of differences.\r\n         */\r\n        DiffChangeHelper.prototype.MarkNextChange = function () {\r\n            // Only add to the list if there is something to add\r\n            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n                // Add the new change to our list\r\n                this.m_changes.push(new diffChange_1.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\r\n            }\r\n            // Reset for the next change\r\n            this.m_originalCount = 0;\r\n            this.m_modifiedCount = 0;\r\n            this.m_originalStart = Number.MAX_VALUE;\r\n            this.m_modifiedStart = Number.MAX_VALUE;\r\n        };\r\n        /**\r\n         * Adds the original element at the given position to the elements\r\n         * affected by the current change. The modified index gives context\r\n         * to the change position with respect to the original sequence.\r\n         * @param originalIndex The index of the original element to add.\r\n         * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\r\n         */\r\n        DiffChangeHelper.prototype.AddOriginalElement = function (originalIndex, modifiedIndex) {\r\n            // The 'true' start index is the smallest of the ones we've seen\r\n            this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n            this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n            this.m_originalCount++;\r\n        };\r\n        /**\r\n         * Adds the modified element at the given position to the elements\r\n         * affected by the current change. The original index gives context\r\n         * to the change position with respect to the modified sequence.\r\n         * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\r\n         * @param modifiedIndex The index of the modified element to add.\r\n         */\r\n        DiffChangeHelper.prototype.AddModifiedElement = function (originalIndex, modifiedIndex) {\r\n            // The 'true' start index is the smallest of the ones we've seen\r\n            this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\r\n            this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\r\n            this.m_modifiedCount++;\r\n        };\r\n        /**\r\n         * Retrieves all of the changes marked by the class.\r\n         */\r\n        DiffChangeHelper.prototype.getChanges = function () {\r\n            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n                // Finish up on whatever is left\r\n                this.MarkNextChange();\r\n            }\r\n            return this.m_changes;\r\n        };\r\n        DiffChangeHelper.prototype.getReverseChanges = function () {\r\n            /// <summary>\r\n            /// Retrieves all of the changes marked by the class in the reverse order\r\n            /// </summary>\r\n            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\r\n                // Finish up on whatever is left\r\n                this.MarkNextChange();\r\n            }\r\n            this.m_changes.reverse();\r\n            return this.m_changes;\r\n        };\r\n        return DiffChangeHelper;\r\n    }());\r\n    /**\r\n     * An implementation of the difference algorithm described in\r\n     * \"An O(ND) Difference Algorithm and its letiations\" by Eugene W. Myers\r\n     */\r\n    var LcsDiff = (function () {\r\n        /**\r\n         * Constructs the DiffFinder\r\n         */\r\n        function LcsDiff(originalSequence, newSequence, continueProcessingPredicate) {\r\n            if (continueProcessingPredicate === void 0) { continueProcessingPredicate = null; }\r\n            this.OriginalSequence = originalSequence;\r\n            this.ModifiedSequence = newSequence;\r\n            this.ContinueProcessingPredicate = continueProcessingPredicate;\r\n            this.m_originalIds = [];\r\n            this.m_modifiedIds = [];\r\n            this.m_forwardHistory = [];\r\n            this.m_reverseHistory = [];\r\n            this.ComputeUniqueIdentifiers();\r\n        }\r\n        LcsDiff.prototype.ComputeUniqueIdentifiers = function () {\r\n            var originalSequenceLength = this.OriginalSequence.getLength();\r\n            var modifiedSequenceLength = this.ModifiedSequence.getLength();\r\n            this.m_originalIds = new Array(originalSequenceLength);\r\n            this.m_modifiedIds = new Array(modifiedSequenceLength);\r\n            // Create a new hash table for unique elements from the original\r\n            // sequence.\r\n            var hashTable = {};\r\n            var currentUniqueId = 1;\r\n            var i;\r\n            // Fill up the hash table for unique elements\r\n            for (i = 0; i < originalSequenceLength; i++) {\r\n                var originalElementHash = this.OriginalSequence.getElementHash(i);\r\n                if (!hashTable.hasOwnProperty(originalElementHash)) {\r\n                    // No entry in the hashtable so this is a new unique element.\r\n                    // Assign the element a new unique identifier and add it to the\r\n                    // hash table\r\n                    this.m_originalIds[i] = currentUniqueId++;\r\n                    hashTable[originalElementHash] = this.m_originalIds[i];\r\n                }\r\n                else {\r\n                    this.m_originalIds[i] = hashTable[originalElementHash];\r\n                }\r\n            }\r\n            // Now match up modified elements\r\n            for (i = 0; i < modifiedSequenceLength; i++) {\r\n                var modifiedElementHash = this.ModifiedSequence.getElementHash(i);\r\n                if (!hashTable.hasOwnProperty(modifiedElementHash)) {\r\n                    this.m_modifiedIds[i] = currentUniqueId++;\r\n                    hashTable[modifiedElementHash] = this.m_modifiedIds[i];\r\n                }\r\n                else {\r\n                    this.m_modifiedIds[i] = hashTable[modifiedElementHash];\r\n                }\r\n            }\r\n        };\r\n        LcsDiff.prototype.ElementsAreEqual = function (originalIndex, newIndex) {\r\n            return this.m_originalIds[originalIndex] === this.m_modifiedIds[newIndex];\r\n        };\r\n        LcsDiff.prototype.ComputeDiff = function () {\r\n            return this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1);\r\n        };\r\n        /**\r\n         * Computes the differences between the original and modified input\r\n         * sequences on the bounded range.\r\n         * @returns An array of the differences between the two input sequences.\r\n         */\r\n        LcsDiff.prototype._ComputeDiff = function (originalStart, originalEnd, modifiedStart, modifiedEnd) {\r\n            var quitEarlyArr = [false];\r\n            return this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\r\n        };\r\n        /**\r\n         * Private helper method which computes the differences on the bounded range\r\n         * recursively.\r\n         * @returns An array of the differences between the two input sequences.\r\n         */\r\n        LcsDiff.prototype.ComputeDiffRecursive = function (originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\r\n            quitEarlyArr[0] = false;\r\n            // Find the start of the differences\r\n            while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\r\n                originalStart++;\r\n                modifiedStart++;\r\n            }\r\n            // Find the end of the differences\r\n            while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\r\n                originalEnd--;\r\n                modifiedEnd--;\r\n            }\r\n            // In the special case where we either have all insertions or all deletions or the sequences are identical\r\n            if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\r\n                var changes = void 0;\r\n                if (modifiedStart <= modifiedEnd) {\r\n                    Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                    // All insertions\r\n                    changes = [\r\n                        new diffChange_1.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                    ];\r\n                }\r\n                else if (originalStart <= originalEnd) {\r\n                    Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                    // All deletions\r\n                    changes = [\r\n                        new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\r\n                    ];\r\n                }\r\n                else {\r\n                    Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\r\n                    Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\r\n                    // Identical sequences - No differences\r\n                    changes = [];\r\n                }\r\n                return changes;\r\n            }\r\n            // This problem can be solved using the Divide-And-Conquer technique.\r\n            var midOriginalArr = [0], midModifiedArr = [0];\r\n            var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\r\n            var midOriginal = midOriginalArr[0];\r\n            var midModified = midModifiedArr[0];\r\n            if (result !== null) {\r\n                // Result is not-null when there was enough memory to compute the changes while\r\n                // searching for the recursion point\r\n                return result;\r\n            }\r\n            else if (!quitEarlyArr[0]) {\r\n                // We can break the problem down recursively by finding the changes in the\r\n                // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\r\n                // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\r\n                // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\r\n                var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\r\n                var rightChanges = [];\r\n                if (!quitEarlyArr[0]) {\r\n                    rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\r\n                }\r\n                else {\r\n                    // We did't have time to finish the first half, so we don't have time to compute this half.\r\n                    // Consider the entire rest of the sequence different.\r\n                    rightChanges = [\r\n                        new diffChange_1.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\r\n                    ];\r\n                }\r\n                return this.ConcatenateChanges(leftChanges, rightChanges);\r\n            }\r\n            // If we hit here, we quit early, and so can't return anything meaningful\r\n            return [\r\n                new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n            ];\r\n        };\r\n        LcsDiff.prototype.WALKTRACE = function (diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\r\n            var forwardChanges = null, reverseChanges = null;\r\n            // First, walk backward through the forward diagonals history\r\n            var changeHelper = new DiffChangeHelper();\r\n            var diagonalMin = diagonalForwardStart;\r\n            var diagonalMax = diagonalForwardEnd;\r\n            var diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\r\n            var lastOriginalIndex = Number.MIN_VALUE;\r\n            var historyIndex = this.m_forwardHistory.length - 1;\r\n            var diagonal;\r\n            do {\r\n                // Get the diagonal index from the relative diagonal number\r\n                diagonal = diagonalRelative + diagonalForwardBase;\r\n                // Figure out where we came from\r\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                    // Vertical line (the element is an insert)\r\n                    originalIndex = forwardPoints[diagonal + 1];\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                    if (originalIndex < lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex;\r\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\r\n                    diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\r\n                }\r\n                else {\r\n                    // Horizontal line (the element is a deletion)\r\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\r\n                    if (originalIndex < lastOriginalIndex) {\r\n                        changeHelper.MarkNextChange();\r\n                    }\r\n                    lastOriginalIndex = originalIndex - 1;\r\n                    changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\r\n                    diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\r\n                }\r\n                if (historyIndex >= 0) {\r\n                    forwardPoints = this.m_forwardHistory[historyIndex];\r\n                    diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\r\n                    diagonalMin = 1;\r\n                    diagonalMax = forwardPoints.length - 1;\r\n                }\r\n            } while (--historyIndex >= -1);\r\n            // Ironically, we get the forward changes as the reverse of the\r\n            // order we added them since we technically added them backwards\r\n            forwardChanges = changeHelper.getReverseChanges();\r\n            if (quitEarlyArr[0]) {\r\n                // TODO: Calculate a partial from the reverse diagonals.\r\n                //       For now, just assume everything after the midOriginal/midModified point is a diff\r\n                var originalStartPoint = midOriginalArr[0] + 1;\r\n                var modifiedStartPoint = midModifiedArr[0] + 1;\r\n                if (forwardChanges !== null && forwardChanges.length > 0) {\r\n                    var lastForwardChange = forwardChanges[forwardChanges.length - 1];\r\n                    originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\r\n                    modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\r\n                }\r\n                reverseChanges = [\r\n                    new diffChange_1.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\r\n                ];\r\n            }\r\n            else {\r\n                // Now walk backward through the reverse diagonals history\r\n                changeHelper = new DiffChangeHelper();\r\n                diagonalMin = diagonalReverseStart;\r\n                diagonalMax = diagonalReverseEnd;\r\n                diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\r\n                lastOriginalIndex = Number.MAX_VALUE;\r\n                historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\r\n                do {\r\n                    // Get the diagonal index from the relative diagonal number\r\n                    diagonal = diagonalRelative + diagonalReverseBase;\r\n                    // Figure out where we came from\r\n                    if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                        // Horizontal line (the element is a deletion))\r\n                        originalIndex = reversePoints[diagonal + 1] - 1;\r\n                        modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                        if (originalIndex > lastOriginalIndex) {\r\n                            changeHelper.MarkNextChange();\r\n                        }\r\n                        lastOriginalIndex = originalIndex + 1;\r\n                        changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\r\n                        diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\r\n                    }\r\n                    else {\r\n                        // Vertical line (the element is an insertion)\r\n                        originalIndex = reversePoints[diagonal - 1];\r\n                        modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\r\n                        if (originalIndex > lastOriginalIndex) {\r\n                            changeHelper.MarkNextChange();\r\n                        }\r\n                        lastOriginalIndex = originalIndex;\r\n                        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\r\n                        diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\r\n                    }\r\n                    if (historyIndex >= 0) {\r\n                        reversePoints = this.m_reverseHistory[historyIndex];\r\n                        diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\r\n                        diagonalMin = 1;\r\n                        diagonalMax = reversePoints.length - 1;\r\n                    }\r\n                } while (--historyIndex >= -1);\r\n                // There are cases where the reverse history will find diffs that\r\n                // are correct, but not intuitive, so we need shift them.\r\n                reverseChanges = changeHelper.getChanges();\r\n            }\r\n            return this.ConcatenateChanges(forwardChanges, reverseChanges);\r\n        };\r\n        /**\r\n         * Given the range to compute the diff on, this method finds the point:\r\n         * (midOriginal, midModified)\r\n         * that exists in the middle of the LCS of the two sequences and\r\n         * is the point at which the LCS problem may be broken down recursively.\r\n         * This method will try to keep the LCS trace in memory. If the LCS recursion\r\n         * point is calculated and the full trace is available in memory, then this method\r\n         * will return the change list.\r\n         * @param originalStart The start bound of the original sequence range\r\n         * @param originalEnd The end bound of the original sequence range\r\n         * @param modifiedStart The start bound of the modified sequence range\r\n         * @param modifiedEnd The end bound of the modified sequence range\r\n         * @param midOriginal The middle point of the original sequence range\r\n         * @param midModified The middle point of the modified sequence range\r\n         * @returns The diff changes, if available, otherwise null\r\n         */\r\n        LcsDiff.prototype.ComputeRecursionPoint = function (originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\r\n            var originalIndex, modifiedIndex;\r\n            var diagonalForwardStart = 0, diagonalForwardEnd = 0;\r\n            var diagonalReverseStart = 0, diagonalReverseEnd = 0;\r\n            var numDifferences;\r\n            // To traverse the edit graph and produce the proper LCS, our actual\r\n            // start position is just outside the given boundary\r\n            originalStart--;\r\n            modifiedStart--;\r\n            // We set these up to make the compiler happy, but they will\r\n            // be replaced before we return with the actual recursion point\r\n            midOriginalArr[0] = 0;\r\n            midModifiedArr[0] = 0;\r\n            // Clear out the history\r\n            this.m_forwardHistory = [];\r\n            this.m_reverseHistory = [];\r\n            // Each cell in the two arrays corresponds to a diagonal in the edit graph.\r\n            // The integer value in the cell represents the originalIndex of the furthest\r\n            // reaching point found so far that ends in that diagonal.\r\n            // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\r\n            var maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\r\n            var numDiagonals = maxDifferences + 1;\r\n            var forwardPoints = new Array(numDiagonals);\r\n            var reversePoints = new Array(numDiagonals);\r\n            // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\r\n            // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\r\n            var diagonalForwardBase = (modifiedEnd - modifiedStart);\r\n            var diagonalReverseBase = (originalEnd - originalStart);\r\n            // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n            //    diagonal number (relative to diagonalForwardBase)\r\n            // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\r\n            //    diagonal number (relative to diagonalReverseBase)\r\n            var diagonalForwardOffset = (originalStart - modifiedStart);\r\n            var diagonalReverseOffset = (originalEnd - modifiedEnd);\r\n            // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\r\n            //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\r\n            // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\r\n            var delta = diagonalReverseBase - diagonalForwardBase;\r\n            var deltaIsEven = (delta % 2 === 0);\r\n            // Here we set up the start and end points as the furthest points found so far\r\n            // in both the forward and reverse directions, respectively\r\n            forwardPoints[diagonalForwardBase] = originalStart;\r\n            reversePoints[diagonalReverseBase] = originalEnd;\r\n            // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\r\n            quitEarlyArr[0] = false;\r\n            // A couple of points:\r\n            // --With this method, we iterate on the number of differences between the two sequences.\r\n            //   The more differences there actually are, the longer this will take.\r\n            // --Also, as the number of differences increases, we have to search on diagonals further\r\n            //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\r\n            // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\r\n            //   is even and odd diagonals only when numDifferences is odd.\r\n            var diagonal, tempOriginalIndex;\r\n            for (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\r\n                var furthestOriginalIndex = 0;\r\n                var furthestModifiedIndex = 0;\r\n                // Run the algorithm in the forward direction\r\n                diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n                diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\r\n                for (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\r\n                    // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                    // by looking at the diagonals above and below and picking the one whose point\r\n                    // is further away from the start point (originalStart, modifiedStart)\r\n                    if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\r\n                        originalIndex = forwardPoints[diagonal + 1];\r\n                    }\r\n                    else {\r\n                        originalIndex = forwardPoints[diagonal - 1] + 1;\r\n                    }\r\n                    modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\r\n                    // Save the current originalIndex so we can test for false overlap in step 3\r\n                    tempOriginalIndex = originalIndex;\r\n                    // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                    // so long as the elements are equal.\r\n                    while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\r\n                        originalIndex++;\r\n                        modifiedIndex++;\r\n                    }\r\n                    forwardPoints[diagonal] = originalIndex;\r\n                    if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\r\n                        furthestOriginalIndex = originalIndex;\r\n                        furthestModifiedIndex = modifiedIndex;\r\n                    }\r\n                    // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\r\n                    // and diagonal is in the range of reverse diagonals computed for numDifferences-1\r\n                    // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\r\n                    // then check for overlap.\r\n                    if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\r\n                        if (originalIndex >= reversePoints[diagonal]) {\r\n                            midOriginalArr[0] = originalIndex;\r\n                            midModifiedArr[0] = modifiedIndex;\r\n                            if (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\r\n                                // BINGO! We overlapped, and we have the full trace in memory!\r\n                                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                            }\r\n                            else {\r\n                                // Either false overlap, or we didn't have enough memory for the full trace\r\n                                // Just return the recursion point\r\n                                return null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // Check to see if we should be quitting early, before moving on to the next iteration.\r\n                var matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\r\n                if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {\r\n                    // We can't finish, so skip ahead to generating a result from what we have.\r\n                    quitEarlyArr[0] = true;\r\n                    // Use the furthest distance we got in the forward direction.\r\n                    midOriginalArr[0] = furthestOriginalIndex;\r\n                    midModifiedArr[0] = furthestModifiedIndex;\r\n                    if (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\r\n                        // Enough of the history is in memory to walk it backwards\r\n                        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                    }\r\n                    else {\r\n                        // We didn't actually remember enough of the history.\r\n                        //Since we are quiting the diff early, we need to shift back the originalStart and modified start\r\n                        //back into the boundary limits since we decremented their value above beyond the boundary limit.\r\n                        originalStart++;\r\n                        modifiedStart++;\r\n                        return [\r\n                            new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\r\n                        ];\r\n                    }\r\n                }\r\n                // Run the algorithm in the reverse direction\r\n                diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n                diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\r\n                for (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\r\n                    // STEP 1: We extend the furthest reaching point in the present diagonal\r\n                    // by looking at the diagonals above and below and picking the one whose point\r\n                    // is further away from the start point (originalEnd, modifiedEnd)\r\n                    if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\r\n                        originalIndex = reversePoints[diagonal + 1] - 1;\r\n                    }\r\n                    else {\r\n                        originalIndex = reversePoints[diagonal - 1];\r\n                    }\r\n                    modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\r\n                    // Save the current originalIndex so we can test for false overlap\r\n                    tempOriginalIndex = originalIndex;\r\n                    // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\r\n                    // as long as the elements are equal.\r\n                    while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\r\n                        originalIndex--;\r\n                        modifiedIndex--;\r\n                    }\r\n                    reversePoints[diagonal] = originalIndex;\r\n                    // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\r\n                    // and diagonal is in the range of forward diagonals computed for numDifferences\r\n                    // then check for overlap.\r\n                    if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\r\n                        if (originalIndex <= forwardPoints[diagonal]) {\r\n                            midOriginalArr[0] = originalIndex;\r\n                            midModifiedArr[0] = modifiedIndex;\r\n                            if (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\r\n                                // BINGO! We overlapped, and we have the full trace in memory!\r\n                                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n                            }\r\n                            else {\r\n                                // Either false overlap, or we didn't have enough memory for the full trace\r\n                                // Just return the recursion point\r\n                                return null;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                // Save current vectors to history before the next iteration\r\n                if (numDifferences <= MaxDifferencesHistory) {\r\n                    // We are allocating space for one extra int, which we fill with\r\n                    // the index of the diagonal base index\r\n                    var temp = new Array(diagonalForwardEnd - diagonalForwardStart + 2);\r\n                    temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\r\n                    MyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\r\n                    this.m_forwardHistory.push(temp);\r\n                    temp = new Array(diagonalReverseEnd - diagonalReverseStart + 2);\r\n                    temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\r\n                    MyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\r\n                    this.m_reverseHistory.push(temp);\r\n                }\r\n            }\r\n            // If we got here, then we have the full trace in history. We just have to convert it to a change list\r\n            // NOTE: This part is a bit messy\r\n            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\r\n        };\r\n        /**\r\n         * Concatenates the two input DiffChange lists and returns the resulting\r\n         * list.\r\n         * @param The left changes\r\n         * @param The right changes\r\n         * @returns The concatenated list\r\n         */\r\n        LcsDiff.prototype.ConcatenateChanges = function (left, right) {\r\n            var mergedChangeArr = [];\r\n            var result = null;\r\n            if (left.length === 0 || right.length === 0) {\r\n                return (right.length > 0) ? right : left;\r\n            }\r\n            else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\r\n                // Since we break the problem down recursively, it is possible that we\r\n                // might recurse in the middle of a change thereby splitting it into\r\n                // two changes. Here in the combining stage, we detect and fuse those\r\n                // changes back together\r\n                result = new Array(left.length + right.length - 1);\r\n                MyArray.Copy(left, 0, result, 0, left.length - 1);\r\n                result[left.length - 1] = mergedChangeArr[0];\r\n                MyArray.Copy(right, 1, result, left.length, right.length - 1);\r\n                return result;\r\n            }\r\n            else {\r\n                result = new Array(left.length + right.length);\r\n                MyArray.Copy(left, 0, result, 0, left.length);\r\n                MyArray.Copy(right, 0, result, left.length, right.length);\r\n                return result;\r\n            }\r\n        };\r\n        /**\r\n         * Returns true if the two changes overlap and can be merged into a single\r\n         * change\r\n         * @param left The left change\r\n         * @param right The right change\r\n         * @param mergedChange The merged change if the two overlap, null otherwise\r\n         * @returns True if the two changes overlap\r\n         */\r\n        LcsDiff.prototype.ChangesOverlap = function (left, right, mergedChangeArr) {\r\n            Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\r\n            Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\r\n            if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n                var originalStart = left.originalStart;\r\n                var originalLength = left.originalLength;\r\n                var modifiedStart = left.modifiedStart;\r\n                var modifiedLength = left.modifiedLength;\r\n                if (left.originalStart + left.originalLength >= right.originalStart) {\r\n                    originalLength = right.originalStart + right.originalLength - left.originalStart;\r\n                }\r\n                if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\r\n                    modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\r\n                }\r\n                mergedChangeArr[0] = new diffChange_1.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\r\n                return true;\r\n            }\r\n            else {\r\n                mergedChangeArr[0] = null;\r\n                return false;\r\n            }\r\n        };\r\n        /**\r\n         * Helper method used to clip a diagonal index to the range of valid\r\n         * diagonals. This also decides whether or not the diagonal index,\r\n         * if it exceeds the boundary, should be clipped to the boundary or clipped\r\n         * one inside the boundary depending on the Even/Odd status of the boundary\r\n         * and numDifferences.\r\n         * @param diagonal The index of the diagonal to clip.\r\n         * @param numDifferences The current number of differences being iterated upon.\r\n         * @param diagonalBaseIndex The base reference diagonal.\r\n         * @param numDiagonals The total number of diagonals.\r\n         * @returns The clipped diagonal index.\r\n         */\r\n        LcsDiff.prototype.ClipDiagonalBound = function (diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\r\n            if (diagonal >= 0 && diagonal < numDiagonals) {\r\n                // Nothing to clip, its in range\r\n                return diagonal;\r\n            }\r\n            // diagonalsBelow: The number of diagonals below the reference diagonal\r\n            // diagonalsAbove: The number of diagonals above the reference diagonal\r\n            var diagonalsBelow = diagonalBaseIndex;\r\n            var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\r\n            var diffEven = (numDifferences % 2 === 0);\r\n            if (diagonal < 0) {\r\n                var lowerBoundEven = (diagonalsBelow % 2 === 0);\r\n                return (diffEven === lowerBoundEven) ? 0 : 1;\r\n            }\r\n            else {\r\n                var upperBoundEven = (diagonalsAbove % 2 === 0);\r\n                return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\r\n            }\r\n        };\r\n        return LcsDiff;\r\n    }());\r\n    exports.LcsDiff = LcsDiff;\r\n});\r\n\ndefine(\"vs/base/common/filters\", [\"require\", \"exports\", 'vs/base/common/strings', 'vs/base/common/map'], function (require, exports, strings, map_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    // Combined filters\r\n    /**\r\n     * @returns A filter which combines the provided set\r\n     * of filters with an or. The *first* filters that\r\n     * matches defined the return value of the returned\r\n     * filter.\r\n     */\r\n    function or() {\r\n        var filter = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            filter[_i - 0] = arguments[_i];\r\n        }\r\n        return function (word, wordToMatchAgainst) {\r\n            for (var i = 0, len = filter.length; i < len; i++) {\r\n                var match = filter[i](word, wordToMatchAgainst);\r\n                if (match) {\r\n                    return match;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n    }\r\n    exports.or = or;\r\n    /**\r\n     * @returns A filter which combines the provided set\r\n     * of filters with an and. The combines matches are\r\n     * returned if *all* filters match.\r\n     */\r\n    function and() {\r\n        var filter = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            filter[_i - 0] = arguments[_i];\r\n        }\r\n        return function (word, wordToMatchAgainst) {\r\n            var result = [];\r\n            for (var i = 0, len = filter.length; i < len; i++) {\r\n                var match = filter[i](word, wordToMatchAgainst);\r\n                if (!match) {\r\n                    return null;\r\n                }\r\n                result = result.concat(match);\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    exports.and = and;\r\n    // Prefix\r\n    exports.matchesStrictPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(false, word, wordToMatchAgainst); };\r\n    exports.matchesPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(true, word, wordToMatchAgainst); };\r\n    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\r\n        if (!wordToMatchAgainst || wordToMatchAgainst.length === 0 || wordToMatchAgainst.length < word.length) {\r\n            return null;\r\n        }\r\n        if (ignoreCase) {\r\n            word = word.toLowerCase();\r\n            wordToMatchAgainst = wordToMatchAgainst.toLowerCase();\r\n        }\r\n        for (var i = 0; i < word.length; i++) {\r\n            if (word[i] !== wordToMatchAgainst[i]) {\r\n                return null;\r\n            }\r\n        }\r\n        return word.length > 0 ? [{ start: 0, end: word.length }] : [];\r\n    }\r\n    // Contiguous Substring\r\n    function matchesContiguousSubString(word, wordToMatchAgainst) {\r\n        var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\r\n        if (index === -1) {\r\n            return null;\r\n        }\r\n        return [{ start: index, end: index + word.length }];\r\n    }\r\n    exports.matchesContiguousSubString = matchesContiguousSubString;\r\n    // Substring\r\n    function matchesSubString(word, wordToMatchAgainst) {\r\n        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\r\n    }\r\n    exports.matchesSubString = matchesSubString;\r\n    function _matchesSubString(word, wordToMatchAgainst, i, j) {\r\n        if (i === word.length) {\r\n            return [];\r\n        }\r\n        else if (j === wordToMatchAgainst.length) {\r\n            return null;\r\n        }\r\n        else {\r\n            if (word[i] === wordToMatchAgainst[j]) {\r\n                var result = null;\r\n                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\r\n                    return join({ start: j, end: j + 1 }, result);\r\n                }\r\n            }\r\n            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\r\n        }\r\n    }\r\n    // CamelCase\r\n    function isLower(code) {\r\n        return 97 <= code && code <= 122;\r\n    }\r\n    function isUpper(code) {\r\n        return 65 <= code && code <= 90;\r\n    }\r\n    function isNumber(code) {\r\n        return 48 <= code && code <= 57;\r\n    }\r\n    function isWhitespace(code) {\r\n        return [32, 9, 10, 13].indexOf(code) > -1;\r\n    }\r\n    function isAlphanumeric(code) {\r\n        return isLower(code) || isUpper(code) || isNumber(code);\r\n    }\r\n    function join(head, tail) {\r\n        if (tail.length === 0) {\r\n            tail = [head];\r\n        }\r\n        else if (head.end === tail[0].start) {\r\n            tail[0].start = head.start;\r\n        }\r\n        else {\r\n            tail.unshift(head);\r\n        }\r\n        return tail;\r\n    }\r\n    function nextAnchor(camelCaseWord, start) {\r\n        for (var i = start; i < camelCaseWord.length; i++) {\r\n            var c = camelCaseWord.charCodeAt(i);\r\n            if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\r\n                return i;\r\n            }\r\n        }\r\n        return camelCaseWord.length;\r\n    }\r\n    function _matchesCamelCase(word, camelCaseWord, i, j) {\r\n        if (i === word.length) {\r\n            return [];\r\n        }\r\n        else if (j === camelCaseWord.length) {\r\n            return null;\r\n        }\r\n        else if (word[i] !== camelCaseWord[j].toLowerCase()) {\r\n            return null;\r\n        }\r\n        else {\r\n            var result = null;\r\n            var nextUpperIndex = j + 1;\r\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\r\n            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\r\n                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\r\n                nextUpperIndex++;\r\n            }\r\n            return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n        }\r\n    }\r\n    // Heuristic to avoid computing camel case matcher for words that don't\r\n    // look like camelCaseWords.\r\n    function isCamelCaseWord(word) {\r\n        if (word.length > 60) {\r\n            return false;\r\n        }\r\n        var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\r\n        for (var i = 0; i < word.length; i++) {\r\n            code = word.charCodeAt(i);\r\n            if (isUpper(code)) {\r\n                upper++;\r\n            }\r\n            if (isLower(code)) {\r\n                lower++;\r\n            }\r\n            if (isAlphanumeric(code)) {\r\n                alpha++;\r\n            }\r\n            if (isNumber(code)) {\r\n                numeric++;\r\n            }\r\n        }\r\n        var upperPercent = upper / word.length;\r\n        var lowerPercent = lower / word.length;\r\n        var alphaPercent = alpha / word.length;\r\n        var numericPercent = numeric / word.length;\r\n        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\r\n    }\r\n    // Heuristic to avoid computing camel case matcher for words that don't\r\n    // look like camel case patterns.\r\n    function isCamelCasePattern(word) {\r\n        var upper = 0, lower = 0, code = 0, whitespace = 0;\r\n        for (var i = 0; i < word.length; i++) {\r\n            code = word.charCodeAt(i);\r\n            if (isUpper(code)) {\r\n                upper++;\r\n            }\r\n            if (isLower(code)) {\r\n                lower++;\r\n            }\r\n            if (isWhitespace(code)) {\r\n                whitespace++;\r\n            }\r\n        }\r\n        if ((upper === 0 || lower === 0) && whitespace === 0) {\r\n            return word.length <= 30;\r\n        }\r\n        else {\r\n            return upper <= 5;\r\n        }\r\n    }\r\n    function matchesCamelCase(word, camelCaseWord) {\r\n        if (!camelCaseWord || camelCaseWord.length === 0) {\r\n            return null;\r\n        }\r\n        if (!isCamelCasePattern(word)) {\r\n            return null;\r\n        }\r\n        if (!isCamelCaseWord(camelCaseWord)) {\r\n            return null;\r\n        }\r\n        var result = null;\r\n        var i = 0;\r\n        while (i < camelCaseWord.length && (result = _matchesCamelCase(word.toLowerCase(), camelCaseWord, 0, i)) === null) {\r\n            i = nextAnchor(camelCaseWord, i + 1);\r\n        }\r\n        return result;\r\n    }\r\n    exports.matchesCamelCase = matchesCamelCase;\r\n    // Matches beginning of words supporting non-ASCII languages\r\n    // E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\r\n    // Useful in cases where the target is words (e.g. command labels)\r\n    function matchesWords(word, target) {\r\n        if (!target || target.length === 0) {\r\n            return null;\r\n        }\r\n        var result = null;\r\n        var i = 0;\r\n        while (i < target.length && (result = _matchesWords(word.toLowerCase(), target, 0, i)) === null) {\r\n            i = nextWord(target, i + 1);\r\n        }\r\n        return result;\r\n    }\r\n    exports.matchesWords = matchesWords;\r\n    function _matchesWords(word, target, i, j) {\r\n        if (i === word.length) {\r\n            return [];\r\n        }\r\n        else if (j === target.length) {\r\n            return null;\r\n        }\r\n        else if (word[i] !== target[j].toLowerCase()) {\r\n            return null;\r\n        }\r\n        else {\r\n            var result = null;\r\n            var nextWordIndex = j + 1;\r\n            result = _matchesWords(word, target, i + 1, j + 1);\r\n            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\r\n                result = _matchesWords(word, target, i + 1, nextWordIndex);\r\n                nextWordIndex++;\r\n            }\r\n            return result === null ? null : join({ start: j, end: j + 1 }, result);\r\n        }\r\n    }\r\n    function nextWord(word, start) {\r\n        for (var i = start; i < word.length; i++) {\r\n            var c = word.charCodeAt(i);\r\n            if (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {\r\n                return i;\r\n            }\r\n        }\r\n        return word.length;\r\n    }\r\n    // Fuzzy\r\n    (function (SubstringMatching) {\r\n        SubstringMatching[SubstringMatching[\"Contiguous\"] = 0] = \"Contiguous\";\r\n        SubstringMatching[SubstringMatching[\"Separate\"] = 1] = \"Separate\";\r\n    })(exports.SubstringMatching || (exports.SubstringMatching = {}));\r\n    var SubstringMatching = exports.SubstringMatching;\r\n    exports.fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);\r\n    var fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);\r\n    var fuzzyRegExpCache = new map_1.LinkedMap(10000); // bounded to 10000 elements\r\n    function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {\r\n        if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }\r\n        if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\r\n            return null; // return early for invalid input\r\n        }\r\n        // Form RegExp for wildcard matches\r\n        var regexp = fuzzyRegExpCache.get(word);\r\n        if (!regexp) {\r\n            regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\r\n            fuzzyRegExpCache.set(word, regexp);\r\n        }\r\n        // RegExp Filter\r\n        var match = regexp.exec(wordToMatchAgainst);\r\n        if (match) {\r\n            return [{ start: match.index, end: match.index + match[0].length }];\r\n        }\r\n        // Default Filter\r\n        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : exports.fuzzyContiguousFilter(word, wordToMatchAgainst);\r\n    }\r\n    exports.matchesFuzzy = matchesFuzzy;\r\n});\r\n\ndefine(\"vs/base/common/uri\", [\"require\", \"exports\", 'vs/base/common/platform'], function (require, exports, platform) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    function _encode(ch) {\r\n        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();\r\n    }\r\n    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\r\n    function encodeURIComponent2(str) {\r\n        return encodeURIComponent(str).replace(/[!'()*]/g, _encode);\r\n    }\r\n    function encodeNoop(str) {\r\n        return str;\r\n    }\r\n    /**\r\n     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\r\n     * This class is a simple parser which creates the basic component paths\r\n     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\r\n     * and encoding.\r\n     *\r\n     *       foo://example.com:8042/over/there?name=ferret#nose\r\n     *       \\_/   \\______________/\\_________/ \\_________/ \\__/\r\n     *        |           |            |            |        |\r\n     *     scheme     authority       path        query   fragment\r\n     *        |   _____________________|__\r\n     *       / \\ /                        \\\r\n     *       urn:example:animal:ferret:nose\r\n     *\r\n     *\r\n     */\r\n    var URI = (function () {\r\n        function URI() {\r\n            this._scheme = URI._empty;\r\n            this._authority = URI._empty;\r\n            this._path = URI._empty;\r\n            this._query = URI._empty;\r\n            this._fragment = URI._empty;\r\n            this._formatted = null;\r\n            this._fsPath = null;\r\n        }\r\n        Object.defineProperty(URI.prototype, \"scheme\", {\r\n            /**\r\n             * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             * The part before the first colon.\r\n             */\r\n            get: function () {\r\n                return this._scheme;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"authority\", {\r\n            /**\r\n             * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             * The part between the first double slashes and the next slash.\r\n             */\r\n            get: function () {\r\n                return this._authority;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"path\", {\r\n            /**\r\n             * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             */\r\n            get: function () {\r\n                return this._path;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"query\", {\r\n            /**\r\n             * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             */\r\n            get: function () {\r\n                return this._query;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"fragment\", {\r\n            /**\r\n             * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\r\n             */\r\n            get: function () {\r\n                return this._fragment;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(URI.prototype, \"fsPath\", {\r\n            // ---- filesystem path -----------------------\r\n            /**\r\n             * Returns a string representing the corresponding file system path of this URI.\r\n             * Will handle UNC paths and normalize windows drive letters to lower-case. Also\r\n             * uses the platform specific path separator. Will *not* validate the path for\r\n             * invalid characters and semantics. Will *not* look at the scheme of this URI.\r\n             */\r\n            get: function () {\r\n                if (!this._fsPath) {\r\n                    var value;\r\n                    if (this._authority && this.scheme === 'file') {\r\n                        // unc path: file://shares/c$/far/boo\r\n                        value = \"//\" + this._authority + this._path;\r\n                    }\r\n                    else if (URI._driveLetterPath.test(this._path)) {\r\n                        // windows drive letter: file:///c:/far/boo\r\n                        value = this._path[1].toLowerCase() + this._path.substr(2);\r\n                    }\r\n                    else {\r\n                        // other path\r\n                        value = this._path;\r\n                    }\r\n                    if (platform.isWindows) {\r\n                        value = value.replace(/\\//g, '\\\\');\r\n                    }\r\n                    this._fsPath = value;\r\n                }\r\n                return this._fsPath;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        // ---- modify to new -------------------------\r\n        URI.prototype.with = function (change) {\r\n            var ret = new URI();\r\n            ret._scheme = change.scheme || this.scheme;\r\n            ret._authority = change.authority || this.authority;\r\n            ret._path = change.path || this.path;\r\n            ret._query = change.query || this.query;\r\n            ret._fragment = change.fragment || this.fragment;\r\n            URI._validate(ret);\r\n            return ret;\r\n        };\r\n        // ---- parse & validate ------------------------\r\n        URI.parse = function (value) {\r\n            var ret = new URI();\r\n            var data = URI._parseComponents(value);\r\n            ret._scheme = data.scheme;\r\n            ret._authority = decodeURIComponent(data.authority);\r\n            ret._path = decodeURIComponent(data.path);\r\n            ret._query = decodeURIComponent(data.query);\r\n            ret._fragment = decodeURIComponent(data.fragment);\r\n            URI._validate(ret);\r\n            return ret;\r\n        };\r\n        URI.file = function (path) {\r\n            var ret = new URI();\r\n            ret._scheme = 'file';\r\n            // normalize to fwd-slashes\r\n            path = path.replace(/\\\\/g, URI._slash);\r\n            // check for authority as used in UNC shares\r\n            // or use the path as given\r\n            if (path[0] === URI._slash && path[0] === path[1]) {\r\n                var idx = path.indexOf(URI._slash, 2);\r\n                if (idx === -1) {\r\n                    ret._authority = path.substring(2);\r\n                }\r\n                else {\r\n                    ret._authority = path.substring(2, idx);\r\n                    ret._path = path.substring(idx);\r\n                }\r\n            }\r\n            else {\r\n                ret._path = path;\r\n            }\r\n            // Ensure that path starts with a slash\r\n            // or that it is at least a slash\r\n            if (ret._path[0] !== URI._slash) {\r\n                ret._path = URI._slash + ret._path;\r\n            }\r\n            URI._validate(ret);\r\n            return ret;\r\n        };\r\n        URI._parseComponents = function (value) {\r\n            var ret = {\r\n                scheme: URI._empty,\r\n                authority: URI._empty,\r\n                path: URI._empty,\r\n                query: URI._empty,\r\n                fragment: URI._empty,\r\n            };\r\n            var match = URI._regexp.exec(value);\r\n            if (match) {\r\n                ret.scheme = match[2] || ret.scheme;\r\n                ret.authority = match[4] || ret.authority;\r\n                ret.path = match[5] || ret.path;\r\n                ret.query = match[7] || ret.query;\r\n                ret.fragment = match[9] || ret.fragment;\r\n            }\r\n            return ret;\r\n        };\r\n        URI.create = function (scheme, authority, path, query, fragment) {\r\n            return new URI().with({ scheme: scheme, authority: authority, path: path, query: query, fragment: fragment });\r\n        };\r\n        URI._validate = function (ret) {\r\n            // validation\r\n            // path, http://tools.ietf.org/html/rfc3986#section-3.3\r\n            // If a URI contains an authority component, then the path component\r\n            // must either be empty or begin with a slash (\"/\") character.  If a URI\r\n            // does not contain an authority component, then the path cannot begin\r\n            // with two slash characters (\"//\").\r\n            if (ret.authority && ret.path && ret.path[0] !== '/') {\r\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\r\n            }\r\n            if (!ret.authority && ret.path.indexOf('//') === 0) {\r\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\r\n            }\r\n        };\r\n        // ---- printing/externalize ---------------------------\r\n        /**\r\n         *\r\n         * @param skipEncoding Do not encode the result, default is `false`\r\n         */\r\n        URI.prototype.toString = function (skipEncoding) {\r\n            if (skipEncoding === void 0) { skipEncoding = false; }\r\n            if (!skipEncoding) {\r\n                if (!this._formatted) {\r\n                    this._formatted = URI._asFormatted(this, false);\r\n                }\r\n                return this._formatted;\r\n            }\r\n            else {\r\n                // we don't cache that\r\n                return URI._asFormatted(this, true);\r\n            }\r\n        };\r\n        URI._asFormatted = function (uri, skipEncoding) {\r\n            var encoder = !skipEncoding\r\n                ? encodeURIComponent2\r\n                : encodeNoop;\r\n            var parts = [];\r\n            var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;\r\n            if (scheme) {\r\n                parts.push(scheme, ':');\r\n            }\r\n            if (authority || scheme === 'file') {\r\n                parts.push('//');\r\n            }\r\n            if (authority) {\r\n                authority = authority.toLowerCase();\r\n                var idx = authority.indexOf(':');\r\n                if (idx === -1) {\r\n                    parts.push(encoder(authority));\r\n                }\r\n                else {\r\n                    parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));\r\n                }\r\n            }\r\n            if (path) {\r\n                // lower-case windown drive letters in /C:/fff\r\n                var m = URI._upperCaseDrive.exec(path);\r\n                if (m) {\r\n                    path = m[1] + m[2].toLowerCase() + path.substr(m[1].length + m[2].length);\r\n                }\r\n                // encode every segement but not slashes\r\n                // make sure that # and ? are always encoded\r\n                // when occurring in paths - otherwise the result\r\n                // cannot be parsed back again\r\n                var lastIdx = 0;\r\n                while (true) {\r\n                    var idx = path.indexOf(URI._slash, lastIdx);\r\n                    if (idx === -1) {\r\n                        parts.push(encoder(path.substring(lastIdx)).replace(/[#?]/, _encode));\r\n                        break;\r\n                    }\r\n                    parts.push(encoder(path.substring(lastIdx, idx)).replace(/[#?]/, _encode), URI._slash);\r\n                    lastIdx = idx + 1;\r\n                }\r\n                ;\r\n            }\r\n            if (query) {\r\n                parts.push('?', encoder(query));\r\n            }\r\n            if (fragment) {\r\n                parts.push('#', encoder(fragment));\r\n            }\r\n            return parts.join(URI._empty);\r\n        };\r\n        URI.prototype.toJSON = function () {\r\n            return {\r\n                scheme: this.scheme,\r\n                authority: this.authority,\r\n                path: this.path,\r\n                fsPath: this.fsPath,\r\n                query: this.query,\r\n                fragment: this.fragment.replace(/URL_MARSHAL_REMOVE.*$/, ''),\r\n                external: this.toString().replace(/#?URL_MARSHAL_REMOVE.*$/, ''),\r\n                $mid: 1\r\n            };\r\n        };\r\n        URI.revive = function (data) {\r\n            var result = new URI();\r\n            result._scheme = data.scheme;\r\n            result._authority = data.authority;\r\n            result._path = data.path;\r\n            result._query = data.query;\r\n            result._fragment = data.fragment;\r\n            result._fsPath = data.fsPath;\r\n            result._formatted = data.external;\r\n            URI._validate(result);\r\n            return result;\r\n        };\r\n        URI._empty = '';\r\n        URI._slash = '/';\r\n        URI._regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\r\n        URI._driveLetterPath = /^\\/[a-zA-z]:/;\r\n        URI._upperCaseDrive = /^(\\/)?([A-Z]:)/;\r\n        return URI;\r\n    }());\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.default = URI;\r\n});\r\n\ndefine(\"vs/editor/common/core/arrays\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var Arrays;\r\n    (function (Arrays) {\r\n        /**\r\n         * Given a sorted array of natural number segments, find the segment containing a natural number.\r\n         *    For example, the segments [0, 5), [5, 9), [9, infinity) will be represented in the following manner:\r\n         *       [{ startIndex: 0 }, { startIndex: 5 }, { startIndex: 9 }]\r\n         *    Searching for 0, 1, 2, 3 or 4 will return 0.\r\n         *    Searching for 5, 6, 7 or 8 will return 1.\r\n         *    Searching for 9, 10, 11, ... will return 2.\r\n         * @param arr A sorted array representing natural number segments\r\n         * @param desiredIndex The search\r\n         * @return The index of the containing segment in the array.\r\n         */\r\n        function findIndexInSegmentsArray(arr, desiredIndex) {\r\n            var low = 0;\r\n            var high = arr.length - 1;\r\n            if (high <= 0) {\r\n                return 0;\r\n            }\r\n            while (low < high) {\r\n                var mid = low + Math.ceil((high - low) / 2);\r\n                if (arr[mid].startIndex > desiredIndex) {\r\n                    high = mid - 1;\r\n                }\r\n                else {\r\n                    low = mid;\r\n                }\r\n            }\r\n            return low;\r\n        }\r\n        Arrays.findIndexInSegmentsArray = findIndexInSegmentsArray;\r\n    })(Arrays = exports.Arrays || (exports.Arrays = {}));\r\n});\r\n\ndefine(\"vs/editor/common/core/modeTransition\", [\"require\", \"exports\", 'vs/editor/common/core/arrays'], function (require, exports, arrays_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var ModeTransition = (function () {\r\n        function ModeTransition(startIndex, mode) {\r\n            this.startIndex = startIndex | 0;\r\n            this.mode = mode;\r\n        }\r\n        ModeTransition.findIndexInSegmentsArray = function (arr, desiredIndex) {\r\n            return arrays_1.Arrays.findIndexInSegmentsArray(arr, desiredIndex);\r\n        };\r\n        ModeTransition.create = function (modeTransitions) {\r\n            var result = [];\r\n            for (var i = 0, len = modeTransitions.length; i < len; i++) {\r\n                var modeTransition = modeTransitions[i];\r\n                result.push(new ModeTransition(modeTransition.startIndex, modeTransition.mode));\r\n            }\r\n            return result;\r\n        };\r\n        return ModeTransition;\r\n    }());\r\n    exports.ModeTransition = ModeTransition;\r\n});\r\n\ndefine(\"vs/editor/common/core/position\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    /**\r\n     * A position in the editor.\r\n     */\r\n    var Position = (function () {\r\n        function Position(lineNumber, column) {\r\n            this.lineNumber = lineNumber;\r\n            this.column = column;\r\n        }\r\n        /**\r\n         * Test if this position equals other position\r\n         */\r\n        Position.prototype.equals = function (other) {\r\n            return Position.equals(this, other);\r\n        };\r\n        Position.equals = function (a, b) {\r\n            if (!a && !b) {\r\n                return true;\r\n            }\r\n            return (!!a &&\r\n                !!b &&\r\n                a.lineNumber === b.lineNumber &&\r\n                a.column === b.column);\r\n        };\r\n        /**\r\n         * Test if this position is before other position. If the two positions are equal, the result will be false.\r\n         */\r\n        Position.prototype.isBefore = function (other) {\r\n            return Position.isBefore(this, other);\r\n        };\r\n        Position.isBefore = function (a, b) {\r\n            if (a.lineNumber < b.lineNumber) {\r\n                return true;\r\n            }\r\n            if (b.lineNumber < a.lineNumber) {\r\n                return false;\r\n            }\r\n            return a.column < b.column;\r\n        };\r\n        /**\r\n         * Test if this position is before other position. If the two positions are equal, the result will be true.\r\n         */\r\n        Position.prototype.isBeforeOrEqual = function (other) {\r\n            return Position.isBeforeOrEqual(this, other);\r\n        };\r\n        Position.isBeforeOrEqual = function (a, b) {\r\n            if (a.lineNumber < b.lineNumber) {\r\n                return true;\r\n            }\r\n            if (b.lineNumber < a.lineNumber) {\r\n                return false;\r\n            }\r\n            return a.column <= b.column;\r\n        };\r\n        /**\r\n         * Clone this position.\r\n         */\r\n        Position.prototype.clone = function () {\r\n            return new Position(this.lineNumber, this.column);\r\n        };\r\n        Position.prototype.toString = function () {\r\n            return '(' + this.lineNumber + ',' + this.column + ')';\r\n        };\r\n        // ---\r\n        Position.lift = function (pos) {\r\n            return new Position(pos.lineNumber, pos.column);\r\n        };\r\n        Position.isIPosition = function (obj) {\r\n            return (obj\r\n                && (typeof obj.lineNumber === 'number')\r\n                && (typeof obj.column === 'number'));\r\n        };\r\n        Position.asEmptyRange = function (position) {\r\n            return {\r\n                startLineNumber: position.lineNumber,\r\n                startColumn: position.column,\r\n                endLineNumber: position.lineNumber,\r\n                endColumn: position.column\r\n            };\r\n        };\r\n        Position.startPosition = function (range) {\r\n            return {\r\n                lineNumber: range.startLineNumber,\r\n                column: range.startColumn\r\n            };\r\n        };\r\n        Position.endPosition = function (range) {\r\n            return {\r\n                lineNumber: range.endLineNumber,\r\n                column: range.endColumn\r\n            };\r\n        };\r\n        return Position;\r\n    }());\r\n    exports.Position = Position;\r\n});\r\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\ndefine(\"vs/editor/common/core/range\", [\"require\", \"exports\", 'vs/editor/common/core/position'], function (require, exports, position_1) {\r\n    'use strict';\r\n    /**\r\n     * A range in the editor.\r\n     */\r\n    var Range = (function () {\r\n        function Range(startLineNumber, startColumn, endLineNumber, endColumn) {\r\n            if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\r\n                this.startLineNumber = endLineNumber;\r\n                this.startColumn = endColumn;\r\n                this.endLineNumber = startLineNumber;\r\n                this.endColumn = startColumn;\r\n            }\r\n            else {\r\n                this.startLineNumber = startLineNumber;\r\n                this.startColumn = startColumn;\r\n                this.endLineNumber = endLineNumber;\r\n                this.endColumn = endColumn;\r\n            }\r\n        }\r\n        /**\r\n         * Test if this range is empty.\r\n         */\r\n        Range.prototype.isEmpty = function () {\r\n            return Range.isEmpty(this);\r\n        };\r\n        /**\r\n         * Test if position is in this range. If the position is at the edges, will return true.\r\n         */\r\n        Range.prototype.containsPosition = function (position) {\r\n            return Range.containsPosition(this, position);\r\n        };\r\n        /**\r\n         * Test if range is in this range. If the range is equal to this range, will return true.\r\n         */\r\n        Range.prototype.containsRange = function (range) {\r\n            return Range.containsRange(this, range);\r\n        };\r\n        /**\r\n         * A reunion of the two ranges. The smallest position will be used as the start point, and the largest one as the end point.\r\n         */\r\n        Range.prototype.plusRange = function (range) {\r\n            return Range.plusRange(this, range);\r\n        };\r\n        /**\r\n         * A intersection of the two ranges.\r\n         */\r\n        Range.prototype.intersectRanges = function (range) {\r\n            return Range.intersectRanges(this, range);\r\n        };\r\n        /**\r\n         * Test if this range equals other.\r\n         */\r\n        Range.prototype.equalsRange = function (other) {\r\n            return Range.equalsRange(this, other);\r\n        };\r\n        /**\r\n         * Return the end position (which will be after or equal to the start position)\r\n         */\r\n        Range.prototype.getEndPosition = function () {\r\n            return new position_1.Position(this.endLineNumber, this.endColumn);\r\n        };\r\n        /**\r\n         * Return the start position (which will be before or equal to the end position)\r\n         */\r\n        Range.prototype.getStartPosition = function () {\r\n            return new position_1.Position(this.startLineNumber, this.startColumn);\r\n        };\r\n        /**\r\n         * Clone this range.\r\n         */\r\n        Range.prototype.cloneRange = function () {\r\n            return new Range(this.startLineNumber, this.startColumn, this.endLineNumber, this.endColumn);\r\n        };\r\n        /**\r\n         * Transform to a user presentable string representation.\r\n         */\r\n        Range.prototype.toString = function () {\r\n            return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\r\n        };\r\n        /**\r\n         * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\r\n         */\r\n        Range.prototype.setEndPosition = function (endLineNumber, endColumn) {\r\n            return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\r\n        };\r\n        /**\r\n         * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\r\n         */\r\n        Range.prototype.setStartPosition = function (startLineNumber, startColumn) {\r\n            return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\r\n        };\r\n        Range.prototype.collapseToStart = function () {\r\n            return new Range(this.startLineNumber, this.startColumn, this.startLineNumber, this.startColumn);\r\n        };\r\n        // ---\r\n        Range.lift = function (range) {\r\n            if (!range) {\r\n                return null;\r\n            }\r\n            return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\r\n        };\r\n        Range.isIRange = function (obj) {\r\n            return (obj\r\n                && (typeof obj.startLineNumber === 'number')\r\n                && (typeof obj.startColumn === 'number')\r\n                && (typeof obj.endLineNumber === 'number')\r\n                && (typeof obj.endColumn === 'number'));\r\n        };\r\n        Range.isEmpty = function (range) {\r\n            return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\r\n        };\r\n        Range.containsPosition = function (range, position) {\r\n            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\r\n                return false;\r\n            }\r\n            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\r\n                return false;\r\n            }\r\n            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        Range.containsRange = function (range, otherRange) {\r\n            if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\r\n                return false;\r\n            }\r\n            if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\r\n                return false;\r\n            }\r\n            if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\r\n                return false;\r\n            }\r\n            if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\r\n                return false;\r\n            }\r\n            return true;\r\n        };\r\n        Range.areIntersectingOrTouching = function (a, b) {\r\n            // Check if `a` is before `b`\r\n            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\r\n                return false;\r\n            }\r\n            // Check if `b` is before `a`\r\n            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\r\n                return false;\r\n            }\r\n            // These ranges must intersect\r\n            return true;\r\n        };\r\n        Range.intersectRanges = function (a, b) {\r\n            var resultStartLineNumber = a.startLineNumber, resultStartColumn = a.startColumn, resultEndLineNumber = a.endLineNumber, resultEndColumn = a.endColumn, otherStartLineNumber = b.startLineNumber, otherStartColumn = b.startColumn, otherEndLineNumber = b.endLineNumber, otherEndColumn = b.endColumn;\r\n            if (resultStartLineNumber < otherStartLineNumber) {\r\n                resultStartLineNumber = otherStartLineNumber;\r\n                resultStartColumn = otherStartColumn;\r\n            }\r\n            else if (resultStartLineNumber === otherStartLineNumber) {\r\n                resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\r\n            }\r\n            if (resultEndLineNumber > otherEndLineNumber) {\r\n                resultEndLineNumber = otherEndLineNumber;\r\n                resultEndColumn = otherEndColumn;\r\n            }\r\n            else if (resultEndLineNumber === otherEndLineNumber) {\r\n                resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\r\n            }\r\n            // Check if selection is now empty\r\n            if (resultStartLineNumber > resultEndLineNumber) {\r\n                return null;\r\n            }\r\n            if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\r\n                return null;\r\n            }\r\n            return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\r\n        };\r\n        Range.plusRange = function (a, b) {\r\n            var startLineNumber, startColumn, endLineNumber, endColumn;\r\n            if (b.startLineNumber < a.startLineNumber) {\r\n                startLineNumber = b.startLineNumber;\r\n                startColumn = b.startColumn;\r\n            }\r\n            else if (b.startLineNumber === a.startLineNumber) {\r\n                startLineNumber = b.startLineNumber;\r\n                startColumn = Math.min(b.startColumn, a.startColumn);\r\n            }\r\n            else {\r\n                startLineNumber = a.startLineNumber;\r\n                startColumn = a.startColumn;\r\n            }\r\n            if (b.endLineNumber > a.endLineNumber) {\r\n                endLineNumber = b.endLineNumber;\r\n                endColumn = b.endColumn;\r\n            }\r\n            else if (b.endLineNumber === a.endLineNumber) {\r\n                endLineNumber = b.endLineNumber;\r\n                endColumn = Math.max(b.endColumn, a.endColumn);\r\n            }\r\n            else {\r\n                endLineNumber = a.endLineNumber;\r\n                endColumn = a.endColumn;\r\n            }\r\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\r\n        };\r\n        Range.equalsRange = function (a, b) {\r\n            return (!!a &&\r\n                !!b &&\r\n                a.startLineNumber === b.startLineNumber &&\r\n                a.startColumn === b.startColumn &&\r\n                a.endLineNumber === b.endLineNumber &&\r\n                a.endColumn === b.endColumn);\r\n        };\r\n        /**\r\n         * A function that compares ranges, useful for sorting ranges\r\n         * It will first compare ranges on the startPosition and then on the endPosition\r\n         */\r\n        Range.compareRangesUsingStarts = function (a, b) {\r\n            var aStartLineNumber = a.startLineNumber | 0;\r\n            var bStartLineNumber = b.startLineNumber | 0;\r\n            var aStartColumn = a.startColumn | 0;\r\n            var bStartColumn = b.startColumn | 0;\r\n            var aEndLineNumber = a.endLineNumber | 0;\r\n            var bEndLineNumber = b.endLineNumber | 0;\r\n            var aEndColumn = a.endColumn | 0;\r\n            var bEndColumn = b.endColumn | 0;\r\n            if (aStartLineNumber === bStartLineNumber) {\r\n                if (aStartColumn === bStartColumn) {\r\n                    if (aEndLineNumber === bEndLineNumber) {\r\n                        return aEndColumn - bEndColumn;\r\n                    }\r\n                    return aEndLineNumber - bEndLineNumber;\r\n                }\r\n                return aStartColumn - bStartColumn;\r\n            }\r\n            return aStartLineNumber - bStartLineNumber;\r\n        };\r\n        /**\r\n         * A function that compares ranges, useful for sorting ranges\r\n         * It will first compare ranges on the endPosition and then on the startPosition\r\n         */\r\n        Range.compareRangesUsingEnds = function (a, b) {\r\n            if (a.endLineNumber === b.endLineNumber) {\r\n                if (a.endColumn === b.endColumn) {\r\n                    if (a.startLineNumber === b.startLineNumber) {\r\n                        return a.startColumn - b.startColumn;\r\n                    }\r\n                    return a.startLineNumber - b.startLineNumber;\r\n                }\r\n                return a.endColumn - b.endColumn;\r\n            }\r\n            return a.endLineNumber - b.endLineNumber;\r\n        };\r\n        Range.spansMultipleLines = function (range) {\r\n            return range.endLineNumber > range.startLineNumber;\r\n        };\r\n        Range.collapseToStart = function (range) {\r\n            return {\r\n                startLineNumber: range.startLineNumber,\r\n                startColumn: range.startColumn,\r\n                endLineNumber: range.startLineNumber,\r\n                endColumn: range.startColumn\r\n            };\r\n        };\r\n        return Range;\r\n    }());\r\n    exports.Range = Range;\r\n});\r\n\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\ndefine(\"vs/editor/common/diff/diffComputer\", [\"require\", \"exports\", 'vs/base/common/diff/diff', 'vs/base/common/strings'], function (require, exports, diff_1, strings) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var MAXIMUM_RUN_TIME = 5000; // 5 seconds\r\n    var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\r\n    function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate) {\r\n        var diffAlgo = new diff_1.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\r\n        return diffAlgo.ComputeDiff();\r\n    }\r\n    var MarkerSequence = (function () {\r\n        function MarkerSequence(buffer, startMarkers, endMarkers) {\r\n            this.buffer = buffer;\r\n            this.startMarkers = startMarkers;\r\n            this.endMarkers = endMarkers;\r\n        }\r\n        MarkerSequence.prototype.equals = function (other) {\r\n            if (!(other instanceof MarkerSequence)) {\r\n                return false;\r\n            }\r\n            var otherMarkerSequence = other;\r\n            if (this.getLength() !== otherMarkerSequence.getLength()) {\r\n                return false;\r\n            }\r\n            for (var i = 0, len = this.getLength(); i < len; i++) {\r\n                var myElement = this.getElementHash(i);\r\n                var otherElement = otherMarkerSequence.getElementHash(i);\r\n                if (myElement !== otherElement) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        MarkerSequence.prototype.getLength = function () {\r\n            return this.startMarkers.length;\r\n        };\r\n        MarkerSequence.prototype.getElementHash = function (i) {\r\n            return this.buffer.substring(this.startMarkers[i].offset, this.endMarkers[i].offset);\r\n        };\r\n        MarkerSequence.prototype.getStartLineNumber = function (i) {\r\n            if (i === this.startMarkers.length) {\r\n                // This is the special case where a change happened after the last marker\r\n                return this.startMarkers[i - 1].lineNumber + 1;\r\n            }\r\n            return this.startMarkers[i].lineNumber;\r\n        };\r\n        MarkerSequence.prototype.getStartColumn = function (i) {\r\n            return this.startMarkers[i].column;\r\n        };\r\n        MarkerSequence.prototype.getEndLineNumber = function (i) {\r\n            return this.endMarkers[i].lineNumber;\r\n        };\r\n        MarkerSequence.prototype.getEndColumn = function (i) {\r\n            return this.endMarkers[i].column;\r\n        };\r\n        return MarkerSequence;\r\n    }());\r\n    var LineMarkerSequence = (function (_super) {\r\n        __extends(LineMarkerSequence, _super);\r\n        function LineMarkerSequence(lines, shouldIgnoreTrimWhitespace) {\r\n            var i, length, pos;\r\n            var buffer = '';\r\n            var startMarkers = [], endMarkers = [], startColumn, endColumn;\r\n            for (pos = 0, i = 0, length = lines.length; i < length; i++) {\r\n                buffer += lines[i];\r\n                startColumn = 1;\r\n                endColumn = lines[i].length + 1;\r\n                if (shouldIgnoreTrimWhitespace) {\r\n                    startColumn = LineMarkerSequence._getFirstNonBlankColumn(lines[i], 1);\r\n                    endColumn = LineMarkerSequence._getLastNonBlankColumn(lines[i], 1);\r\n                }\r\n                startMarkers.push({\r\n                    offset: pos + startColumn - 1,\r\n                    lineNumber: i + 1,\r\n                    column: startColumn\r\n                });\r\n                endMarkers.push({\r\n                    offset: pos + endColumn - 1,\r\n                    lineNumber: i + 1,\r\n                    column: endColumn\r\n                });\r\n                pos += lines[i].length;\r\n            }\r\n            _super.call(this, buffer, startMarkers, endMarkers);\r\n        }\r\n        LineMarkerSequence._getFirstNonBlankColumn = function (txt, defaultValue) {\r\n            var r = strings.firstNonWhitespaceIndex(txt);\r\n            if (r === -1) {\r\n                return defaultValue;\r\n            }\r\n            return r + 1;\r\n        };\r\n        LineMarkerSequence._getLastNonBlankColumn = function (txt, defaultValue) {\r\n            var r = strings.lastNonWhitespaceIndex(txt);\r\n            if (r === -1) {\r\n                return defaultValue;\r\n            }\r\n            return r + 2;\r\n        };\r\n        LineMarkerSequence.prototype.getCharSequence = function (startIndex, endIndex) {\r\n            var startMarkers = [], endMarkers = [], index, i, startMarker, endMarker;\r\n            for (index = startIndex; index <= endIndex; index++) {\r\n                startMarker = this.startMarkers[index];\r\n                endMarker = this.endMarkers[index];\r\n                for (i = startMarker.offset; i < endMarker.offset; i++) {\r\n                    startMarkers.push({\r\n                        offset: i,\r\n                        lineNumber: startMarker.lineNumber,\r\n                        column: startMarker.column + (i - startMarker.offset)\r\n                    });\r\n                    endMarkers.push({\r\n                        offset: i + 1,\r\n                        lineNumber: startMarker.lineNumber,\r\n                        column: startMarker.column + (i - startMarker.offset) + 1\r\n                    });\r\n                }\r\n            }\r\n            return new MarkerSequence(this.buffer, startMarkers, endMarkers);\r\n        };\r\n        return LineMarkerSequence;\r\n    }(MarkerSequence));\r\n    var CharChange = (function () {\r\n        function CharChange(diffChange, originalCharSequence, modifiedCharSequence) {\r\n            if (diffChange.originalLength === 0) {\r\n                this.originalStartLineNumber = 0;\r\n                this.originalStartColumn = 0;\r\n                this.originalEndLineNumber = 0;\r\n                this.originalEndColumn = 0;\r\n            }\r\n            else {\r\n                this.originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\r\n                this.originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\r\n                this.originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n                this.originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\r\n            }\r\n            if (diffChange.modifiedLength === 0) {\r\n                this.modifiedStartLineNumber = 0;\r\n                this.modifiedStartColumn = 0;\r\n                this.modifiedEndLineNumber = 0;\r\n                this.modifiedEndColumn = 0;\r\n            }\r\n            else {\r\n                this.modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\r\n                this.modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\r\n                this.modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n                this.modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            }\r\n        }\r\n        return CharChange;\r\n    }());\r\n    function postProcessCharChanges(rawChanges) {\r\n        if (rawChanges.length <= 1) {\r\n            return rawChanges;\r\n        }\r\n        var result = [rawChanges[0]];\r\n        var i, len, originalMatchingLength, modifiedMatchingLength, matchingLength, prevChange = result[0], currChange;\r\n        for (i = 1, len = rawChanges.length; i < len; i++) {\r\n            currChange = rawChanges[i];\r\n            originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\r\n            modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\r\n            // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\r\n            matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\r\n            if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\r\n                // Merge the current change into the previous one\r\n                prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\r\n                prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\r\n            }\r\n            else {\r\n                // Add the current change\r\n                result.push(currChange);\r\n                prevChange = currChange;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    var LineChange = (function () {\r\n        function LineChange(diffChange, originalLineSequence, modifiedLineSequence, continueProcessingPredicate, shouldPostProcessCharChanges) {\r\n            if (diffChange.originalLength === 0) {\r\n                this.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\r\n                this.originalEndLineNumber = 0;\r\n            }\r\n            else {\r\n                this.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\r\n                this.originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\r\n            }\r\n            if (diffChange.modifiedLength === 0) {\r\n                this.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\r\n                this.modifiedEndLineNumber = 0;\r\n            }\r\n            else {\r\n                this.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\r\n                this.modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n            }\r\n            if (diffChange.originalLength !== 0 && diffChange.modifiedLength !== 0 && continueProcessingPredicate()) {\r\n                var originalCharSequence = originalLineSequence.getCharSequence(diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\r\n                var modifiedCharSequence = modifiedLineSequence.getCharSequence(diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\r\n                var rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueProcessingPredicate);\r\n                if (shouldPostProcessCharChanges) {\r\n                    rawChanges = postProcessCharChanges(rawChanges);\r\n                }\r\n                this.charChanges = [];\r\n                for (var i = 0, length = rawChanges.length; i < length; i++) {\r\n                    this.charChanges.push(new CharChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\r\n                }\r\n            }\r\n        }\r\n        return LineChange;\r\n    }());\r\n    var DiffComputer = (function () {\r\n        function DiffComputer(originalLines, modifiedLines, opts) {\r\n            this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\r\n            this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\r\n            this.maximumRunTimeMs = MAXIMUM_RUN_TIME;\r\n            this.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);\r\n            this.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);\r\n            if (opts.shouldConsiderTrimWhitespaceInEmptyCase && this.shouldIgnoreTrimWhitespace && this.original.equals(this.modified)) {\r\n                // Diff would be empty with `shouldIgnoreTrimWhitespace`\r\n                this.shouldIgnoreTrimWhitespace = false;\r\n                this.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);\r\n                this.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);\r\n            }\r\n        }\r\n        DiffComputer.prototype.computeDiff = function () {\r\n            this.computationStartTime = (new Date()).getTime();\r\n            var rawChanges = computeDiff(this.original, this.modified, this._continueProcessingPredicate.bind(this));\r\n            var lineChanges = [];\r\n            for (var i = 0, length = rawChanges.length; i < length; i++) {\r\n                lineChanges.push(new LineChange(rawChanges[i], this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldPostProcessCharChanges));\r\n            }\r\n            return lineChanges;\r\n        };\r\n        DiffComputer.prototype._continueProcessingPredicate = function () {\r\n            if (this.maximumRunTimeMs === 0) {\r\n                return true;\r\n            }\r\n            var now = (new Date()).getTime();\r\n            return now - this.computationStartTime < this.maximumRunTimeMs;\r\n        };\r\n        return DiffComputer;\r\n    }());\r\n    exports.DiffComputer = DiffComputer;\r\n});\r\n\ndefine(\"vs/editor/common/modes/linkComputer\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    // State machine for http:// or https://\r\n    var STATE_MAP = [], START_STATE = 1, END_STATE = 9, ACCEPT_STATE = 10;\r\n    STATE_MAP[1] = { 'h': 2, 'H': 2, 'f': 11, 'F': 11 };\r\n    STATE_MAP[2] = { 't': 3, 'T': 3 };\r\n    STATE_MAP[3] = { 't': 4, 'T': 4 };\r\n    STATE_MAP[4] = { 'p': 5, 'P': 5 };\r\n    STATE_MAP[5] = { 's': 6, 'S': 6, ':': 7 };\r\n    STATE_MAP[6] = { ':': 7 };\r\n    STATE_MAP[7] = { '/': 8 };\r\n    STATE_MAP[8] = { '/': 9 };\r\n    STATE_MAP[11] = { 'i': 12, 'I': 12 };\r\n    STATE_MAP[12] = { 'l': 13, 'L': 13 };\r\n    STATE_MAP[13] = { 'e': 6, 'E': 6 };\r\n    var CharacterClass;\r\n    (function (CharacterClass) {\r\n        CharacterClass[CharacterClass[\"None\"] = 0] = \"None\";\r\n        CharacterClass[CharacterClass[\"ForceTermination\"] = 1] = \"ForceTermination\";\r\n        CharacterClass[CharacterClass[\"CannotEndIn\"] = 2] = \"CannotEndIn\";\r\n    })(CharacterClass || (CharacterClass = {}));\r\n    var _openParens = '('.charCodeAt(0);\r\n    var _closeParens = ')'.charCodeAt(0);\r\n    var _openSquareBracket = '['.charCodeAt(0);\r\n    var _closeSquareBracket = ']'.charCodeAt(0);\r\n    var _openCurlyBracket = '{'.charCodeAt(0);\r\n    var _closeCurlyBracket = '}'.charCodeAt(0);\r\n    var CharacterClassifier = (function () {\r\n        function CharacterClassifier() {\r\n            var FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\r\n            var CANNOT_END_WITH_CHARACTERS = '.,;';\r\n            this._asciiMap = [];\r\n            for (var i = 0; i < 256; i++) {\r\n                this._asciiMap[i] = CharacterClass.None;\r\n            }\r\n            this._map = [];\r\n            for (var i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\r\n                this._set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), CharacterClass.ForceTermination);\r\n            }\r\n            for (var i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\r\n                this._set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), CharacterClass.CannotEndIn);\r\n            }\r\n        }\r\n        CharacterClassifier.prototype._set = function (charCode, charClass) {\r\n            if (charCode < 256) {\r\n                this._asciiMap[charCode] = charClass;\r\n            }\r\n            this._map[charCode] = charClass;\r\n        };\r\n        CharacterClassifier.prototype.classify = function (charCode) {\r\n            if (charCode < 256) {\r\n                return this._asciiMap[charCode];\r\n            }\r\n            var charClass = this._map[charCode];\r\n            if (charClass) {\r\n                return charClass;\r\n            }\r\n            return CharacterClass.None;\r\n        };\r\n        return CharacterClassifier;\r\n    }());\r\n    var LinkComputer = (function () {\r\n        function LinkComputer() {\r\n        }\r\n        LinkComputer._createLink = function (line, lineNumber, linkBeginIndex, linkEndIndex) {\r\n            return {\r\n                range: {\r\n                    startLineNumber: lineNumber,\r\n                    startColumn: linkBeginIndex + 1,\r\n                    endLineNumber: lineNumber,\r\n                    endColumn: linkEndIndex + 1\r\n                },\r\n                url: line.substring(linkBeginIndex, linkEndIndex)\r\n            };\r\n        };\r\n        LinkComputer.computeLinks = function (model) {\r\n            var i, lineCount, result = [];\r\n            var line, j, lastIncludedCharIndex, len, linkBeginIndex, state, ch, chCode, chClass, resetStateMachine, hasOpenParens, hasOpenSquareBracket, hasOpenCurlyBracket, characterClassifier = LinkComputer._characterClassifier;\r\n            for (i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\r\n                line = model.getLineContent(i);\r\n                j = 0;\r\n                len = line.length;\r\n                linkBeginIndex = 0;\r\n                state = START_STATE;\r\n                hasOpenParens = false;\r\n                hasOpenSquareBracket = false;\r\n                hasOpenCurlyBracket = false;\r\n                while (j < len) {\r\n                    ch = line.charAt(j);\r\n                    chCode = line.charCodeAt(j);\r\n                    resetStateMachine = false;\r\n                    if (state === ACCEPT_STATE) {\r\n                        switch (chCode) {\r\n                            case _openParens:\r\n                                hasOpenParens = true;\r\n                                chClass = CharacterClass.None;\r\n                                break;\r\n                            case _closeParens:\r\n                                chClass = (hasOpenParens ? CharacterClass.None : CharacterClass.ForceTermination);\r\n                                break;\r\n                            case _openSquareBracket:\r\n                                hasOpenSquareBracket = true;\r\n                                chClass = CharacterClass.None;\r\n                                break;\r\n                            case _closeSquareBracket:\r\n                                chClass = (hasOpenSquareBracket ? CharacterClass.None : CharacterClass.ForceTermination);\r\n                                break;\r\n                            case _openCurlyBracket:\r\n                                hasOpenCurlyBracket = true;\r\n                                chClass = CharacterClass.None;\r\n                                break;\r\n                            case _closeCurlyBracket:\r\n                                chClass = (hasOpenCurlyBracket ? CharacterClass.None : CharacterClass.ForceTermination);\r\n                                break;\r\n                            default:\r\n                                chClass = characterClassifier.classify(chCode);\r\n                        }\r\n                        // Check if character terminates link\r\n                        if (chClass === CharacterClass.ForceTermination) {\r\n                            // Do not allow to end link in certain characters...\r\n                            lastIncludedCharIndex = j - 1;\r\n                            do {\r\n                                chCode = line.charCodeAt(lastIncludedCharIndex);\r\n                                chClass = characterClassifier.classify(chCode);\r\n                                if (chClass !== CharacterClass.CannotEndIn) {\r\n                                    break;\r\n                                }\r\n                                lastIncludedCharIndex--;\r\n                            } while (lastIncludedCharIndex > linkBeginIndex);\r\n                            result.push(LinkComputer._createLink(line, i, linkBeginIndex, lastIncludedCharIndex + 1));\r\n                            resetStateMachine = true;\r\n                        }\r\n                    }\r\n                    else if (state === END_STATE) {\r\n                        chClass = characterClassifier.classify(chCode);\r\n                        // Check if character terminates link\r\n                        if (chClass === CharacterClass.ForceTermination) {\r\n                            resetStateMachine = true;\r\n                        }\r\n                        else {\r\n                            state = ACCEPT_STATE;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (STATE_MAP[state].hasOwnProperty(ch)) {\r\n                            state = STATE_MAP[state][ch];\r\n                        }\r\n                        else {\r\n                            resetStateMachine = true;\r\n                        }\r\n                    }\r\n                    if (resetStateMachine) {\r\n                        state = START_STATE;\r\n                        hasOpenParens = false;\r\n                        hasOpenSquareBracket = false;\r\n                        hasOpenCurlyBracket = false;\r\n                        // Record where the link started\r\n                        linkBeginIndex = j + 1;\r\n                    }\r\n                    j++;\r\n                }\r\n                if (state === ACCEPT_STATE) {\r\n                    result.push(LinkComputer._createLink(line, i, linkBeginIndex, len));\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        LinkComputer._characterClassifier = new CharacterClassifier();\r\n        return LinkComputer;\r\n    }());\r\n    /**\r\n     * Returns an array of all links contains in the provided\r\n     * document. *Note* that this operation is computational\r\n     * expensive and should not run in the UI thread.\r\n     */\r\n    function computeLinks(model) {\r\n        if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\r\n            // Unknown caller!\r\n            return [];\r\n        }\r\n        return LinkComputer.computeLinks(model);\r\n    }\r\n    exports.computeLinks = computeLinks;\r\n});\r\n\ndefine(\"vs/editor/common/modes/supports/inplaceReplaceSupport\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var BasicInplaceReplace = (function () {\r\n        function BasicInplaceReplace() {\r\n            this._defaultValueSet = [\r\n                ['true', 'false'],\r\n                ['True', 'False'],\r\n                ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\r\n                ['public', 'protected', 'private'],\r\n            ];\r\n        }\r\n        BasicInplaceReplace.prototype.navigateValueSet = function (range1, text1, range2, text2, up) {\r\n            if (range1 && text1) {\r\n                var result = this.doNavigateValueSet(text1, up);\r\n                if (result) {\r\n                    return {\r\n                        range: range1,\r\n                        value: result\r\n                    };\r\n                }\r\n            }\r\n            if (range2 && text2) {\r\n                var result = this.doNavigateValueSet(text2, up);\r\n                if (result) {\r\n                    return {\r\n                        range: range2,\r\n                        value: result\r\n                    };\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        BasicInplaceReplace.prototype.doNavigateValueSet = function (text, up) {\r\n            var numberResult = this.numberReplace(text, up);\r\n            if (numberResult !== null) {\r\n                return numberResult;\r\n            }\r\n            return this.textReplace(text, up);\r\n        };\r\n        BasicInplaceReplace.prototype.numberReplace = function (value, up) {\r\n            var precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1)), n1 = Number(value), n2 = parseFloat(value);\r\n            if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\r\n                if (n1 === 0 && !up) {\r\n                    return null; // don't do negative\r\n                }\r\n                else {\r\n                    n1 = Math.floor(n1 * precision);\r\n                    n1 += up ? precision : -precision;\r\n                    return String(n1 / precision);\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        BasicInplaceReplace.prototype.textReplace = function (value, up) {\r\n            return this.valueSetsReplace(this._defaultValueSet, value, up);\r\n        };\r\n        BasicInplaceReplace.prototype.valueSetsReplace = function (valueSets, value, up) {\r\n            var result = null;\r\n            for (var i = 0, len = valueSets.length; result === null && i < len; i++) {\r\n                result = this.valueSetReplace(valueSets[i], value, up);\r\n            }\r\n            return result;\r\n        };\r\n        BasicInplaceReplace.prototype.valueSetReplace = function (valueSet, value, up) {\r\n            var idx = valueSet.indexOf(value);\r\n            if (idx >= 0) {\r\n                idx += up ? +1 : -1;\r\n                if (idx < 0) {\r\n                    idx = valueSet.length - 1;\r\n                }\r\n                else {\r\n                    idx %= valueSet.length;\r\n                }\r\n                return valueSet[idx];\r\n            }\r\n            return null;\r\n        };\r\n        BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\r\n        return BasicInplaceReplace;\r\n    }());\r\n    exports.BasicInplaceReplace = BasicInplaceReplace;\r\n});\r\n\ndefine(\"vs/editor/common/services/editorSimpleWorkerCommon\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var EditorSimpleWorker = (function () {\r\n        function EditorSimpleWorker() {\r\n        }\r\n        EditorSimpleWorker.prototype.acceptNewModel = function (data) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.acceptModelChanged = function (modelUrl, events) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.acceptRemovedModel = function (modelUrl) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.computeDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.computeDirtyDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.computeLinks = function (modelUrl) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.textualSuggest = function (modelUrl, position, wordDef, wordDefFlags) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        EditorSimpleWorker.prototype.navigateValueSet = function (modelUrl, range, up, wordDef, wordDefFlags) {\r\n            throw new Error('Not implemented!');\r\n        };\r\n        return EditorSimpleWorker;\r\n    }());\r\n    exports.EditorSimpleWorker = EditorSimpleWorker;\r\n});\r\n\ndefine(\"vs/editor/common/viewModel/prefixSumComputer\", [\"require\", \"exports\"], function (require, exports) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var PrefixSumIndexOfResult = (function () {\r\n        function PrefixSumIndexOfResult(index, remainder) {\r\n            this.index = index;\r\n            this.remainder = remainder;\r\n        }\r\n        return PrefixSumIndexOfResult;\r\n    }());\r\n    exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;\r\n    var PrefixSumComputer = (function () {\r\n        function PrefixSumComputer(values) {\r\n            this.values = values;\r\n            this.prefixSum = [];\r\n            for (var i = 0, len = this.values.length; i < len; i++) {\r\n                this.prefixSum[i] = 0;\r\n            }\r\n            this.prefixSumValidIndex = -1;\r\n        }\r\n        PrefixSumComputer.prototype.getCount = function () {\r\n            return this.values.length;\r\n        };\r\n        PrefixSumComputer.prototype.insertValue = function (insertIndex, value) {\r\n            insertIndex = Math.floor(insertIndex); //@perf\r\n            value = Math.floor(value); //@perf\r\n            this.values.splice(insertIndex, 0, value);\r\n            this.prefixSum.splice(insertIndex, 0, 0);\r\n            if (insertIndex - 1 < this.prefixSumValidIndex) {\r\n                this.prefixSumValidIndex = insertIndex - 1;\r\n            }\r\n        };\r\n        PrefixSumComputer.prototype.insertValues = function (insertIndex, values) {\r\n            insertIndex = Math.floor(insertIndex); //@perf\r\n            if (values.length === 0) {\r\n                return;\r\n            }\r\n            this.values = this.values.slice(0, insertIndex).concat(values).concat(this.values.slice(insertIndex));\r\n            this.prefixSum = this.prefixSum.slice(0, insertIndex).concat(PrefixSumComputer._zeroArray(values.length)).concat(this.prefixSum.slice(insertIndex));\r\n            if (insertIndex - 1 < this.prefixSumValidIndex) {\r\n                this.prefixSumValidIndex = insertIndex - 1;\r\n            }\r\n        };\r\n        PrefixSumComputer._zeroArray = function (count) {\r\n            count = Math.floor(count); //@perf\r\n            var r = [];\r\n            for (var i = 0; i < count; i++) {\r\n                r[i] = 0;\r\n            }\r\n            return r;\r\n        };\r\n        PrefixSumComputer.prototype.changeValue = function (index, value) {\r\n            index = Math.floor(index); //@perf\r\n            value = Math.floor(value); //@perf\r\n            if (this.values[index] === value) {\r\n                return;\r\n            }\r\n            this.values[index] = value;\r\n            if (index - 1 < this.prefixSumValidIndex) {\r\n                this.prefixSumValidIndex = index - 1;\r\n            }\r\n        };\r\n        PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {\r\n            startIndex = Math.floor(startIndex); //@perf\r\n            cnt = Math.floor(cnt); //@perf\r\n            this.values.splice(startIndex, cnt);\r\n            this.prefixSum.splice(startIndex, cnt);\r\n            if (startIndex - 1 < this.prefixSumValidIndex) {\r\n                this.prefixSumValidIndex = startIndex - 1;\r\n            }\r\n        };\r\n        PrefixSumComputer.prototype.getTotalValue = function () {\r\n            if (this.values.length === 0) {\r\n                return 0;\r\n            }\r\n            return this.getAccumulatedValue(this.values.length - 1);\r\n        };\r\n        PrefixSumComputer.prototype.getAccumulatedValue = function (index) {\r\n            index = Math.floor(index); //@perf\r\n            if (index < 0) {\r\n                return 0;\r\n            }\r\n            if (index <= this.prefixSumValidIndex) {\r\n                return this.prefixSum[index];\r\n            }\r\n            var startIndex = this.prefixSumValidIndex + 1;\r\n            if (startIndex === 0) {\r\n                this.prefixSum[0] = this.values[0];\r\n                startIndex++;\r\n            }\r\n            if (index >= this.values.length) {\r\n                index = this.values.length - 1;\r\n            }\r\n            for (var i = startIndex; i <= index; i++) {\r\n                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\r\n            }\r\n            this.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);\r\n            return this.prefixSum[index];\r\n        };\r\n        PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {\r\n            accumulatedValue = Math.floor(accumulatedValue); //@perf\r\n            var low = 0;\r\n            var high = this.values.length - 1;\r\n            var mid;\r\n            var midStop;\r\n            var midStart;\r\n            while (low <= high) {\r\n                mid = low + ((high - low) / 2) | 0;\r\n                midStop = this.getAccumulatedValue(mid);\r\n                midStart = midStop - this.values[mid];\r\n                if (accumulatedValue < midStart) {\r\n                    high = mid - 1;\r\n                }\r\n                else if (accumulatedValue >= midStop) {\r\n                    low = mid + 1;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);\r\n        };\r\n        return PrefixSumComputer;\r\n    }());\r\n    exports.PrefixSumComputer = PrefixSumComputer;\r\n});\r\n\ndefine(\"vs/editor/common/model/mirrorModel2\", [\"require\", \"exports\", 'vs/editor/common/viewModel/prefixSumComputer'], function (require, exports, prefixSumComputer_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var MirrorModel2 = (function () {\r\n        function MirrorModel2(uri, lines, eol, versionId) {\r\n            this._uri = uri;\r\n            this._lines = lines;\r\n            this._eol = eol;\r\n            this._versionId = versionId;\r\n        }\r\n        MirrorModel2.prototype.dispose = function () {\r\n            this._lines.length = 0;\r\n        };\r\n        Object.defineProperty(MirrorModel2.prototype, \"version\", {\r\n            get: function () {\r\n                return this._versionId;\r\n            },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        MirrorModel2.prototype.getText = function () {\r\n            return this._lines.join(this._eol);\r\n        };\r\n        MirrorModel2.prototype.onEvents = function (events) {\r\n            var newEOL = null;\r\n            for (var i = 0, len = events.length; i < len; i++) {\r\n                var e = events[i];\r\n                if (e.eol) {\r\n                    newEOL = e.eol;\r\n                }\r\n            }\r\n            if (newEOL && newEOL !== this._eol) {\r\n                this._eol = newEOL;\r\n                this._lineStarts = null;\r\n            }\r\n            // Update my lines\r\n            var lastVersionId = -1;\r\n            for (var i = 0, len = events.length; i < len; i++) {\r\n                var e = events[i];\r\n                this._acceptDeleteRange(e.range);\r\n                this._acceptInsertText({\r\n                    lineNumber: e.range.startLineNumber,\r\n                    column: e.range.startColumn\r\n                }, e.text);\r\n                lastVersionId = Math.max(lastVersionId, e.versionId);\r\n            }\r\n            if (lastVersionId !== -1) {\r\n                this._versionId = lastVersionId;\r\n            }\r\n        };\r\n        MirrorModel2.prototype._ensureLineStarts = function () {\r\n            if (!this._lineStarts) {\r\n                var lineStartValues = [];\r\n                var eolLength = this._eol.length;\r\n                for (var i = 0, len = this._lines.length; i < len; i++) {\r\n                    lineStartValues.push(this._lines[i].length + eolLength);\r\n                }\r\n                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);\r\n            }\r\n        };\r\n        /**\r\n         * All changes to a line's text go through this method\r\n         */\r\n        MirrorModel2.prototype._setLineText = function (lineIndex, newValue) {\r\n            this._lines[lineIndex] = newValue;\r\n            if (this._lineStarts) {\r\n                // update prefix sum\r\n                this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\r\n            }\r\n        };\r\n        MirrorModel2.prototype._acceptDeleteRange = function (range) {\r\n            if (range.startLineNumber === range.endLineNumber) {\r\n                if (range.startColumn === range.endColumn) {\r\n                    // Nothing to delete\r\n                    return;\r\n                }\r\n                // Delete text on the affected line\r\n                this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\r\n                    + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\r\n                return;\r\n            }\r\n            // Take remaining text on last line and append it to remaining text on first line\r\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\r\n                + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\r\n            // Delete middle lines\r\n            this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n            if (this._lineStarts) {\r\n                // update prefix sum\r\n                this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\r\n            }\r\n        };\r\n        MirrorModel2.prototype._acceptInsertText = function (position, insertText) {\r\n            if (insertText.length === 0) {\r\n                // Nothing to insert\r\n                return;\r\n            }\r\n            var insertLines = insertText.split(/\\r\\n|\\r|\\n/);\r\n            if (insertLines.length === 1) {\r\n                // Inserting text on one line\r\n                this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\r\n                    + insertLines[0]\r\n                    + this._lines[position.lineNumber - 1].substring(position.column - 1));\r\n                return;\r\n            }\r\n            // Append overflowing text from first line to the end of text to insert\r\n            insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\r\n            // Delete overflowing text from first line and insert text on first line\r\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\r\n                + insertLines[0]);\r\n            // Insert new lines & store lengths\r\n            var newLengths = new Array(insertLines.length - 1);\r\n            for (var i = 1; i < insertLines.length; i++) {\r\n                this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\r\n                newLengths[i - 1] = insertLines[i].length + this._eol.length;\r\n            }\r\n            if (this._lineStarts) {\r\n                // update prefix sum\r\n                this._lineStarts.insertValues(position.lineNumber, newLengths);\r\n            }\r\n        };\r\n        return MirrorModel2;\r\n    }());\r\n    exports.MirrorModel2 = MirrorModel2;\r\n});\r\n\ndefine(\"vs/nls!vs/editor/common/config/defaultConfig\",['vs/nls', 'vs/nls!vs/editor/common/services/editorSimpleWorker'], function(nls, data) { return nls.create(\"vs/editor/common/config/defaultConfig\", data); });\ndefine(\"vs/editor/common/config/defaultConfig\", [\"require\", \"exports\", 'vs/nls!vs/editor/common/config/defaultConfig', 'vs/base/common/platform'], function (require, exports, nls, platform) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\r\n    exports.DEFAULT_INDENTATION = {\r\n        tabSize: 4,\r\n        insertSpaces: true,\r\n        detectIndentation: true\r\n    };\r\n    exports.DEFAULT_TRIM_AUTO_WHITESPACE = true;\r\n    var DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\r\n    var DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\r\n    var DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'Courier New\\', monospace, \\'Droid Sans Fallback\\'';\r\n    /**\r\n     * Determined from empirical observations.\r\n     */\r\n    exports.GOLDEN_LINE_HEIGHT_RATIO = platform.isMacintosh ? 1.5 : 1.35;\r\n    var ConfigClass = (function () {\r\n        function ConfigClass() {\r\n            this.editor = {\r\n                experimentalScreenReader: true,\r\n                rulers: [],\r\n                wordSeparators: exports.USUAL_WORD_SEPARATORS,\r\n                selectionClipboard: true,\r\n                ariaLabel: nls.localize(0, null),\r\n                lineNumbers: true,\r\n                selectOnLineNumbers: true,\r\n                lineNumbersMinChars: 5,\r\n                glyphMargin: false,\r\n                lineDecorationsWidth: 10,\r\n                revealHorizontalRightPadding: 30,\r\n                roundedSelection: true,\r\n                theme: 'vs',\r\n                readOnly: false,\r\n                scrollbar: {\r\n                    verticalScrollbarSize: 14,\r\n                    horizontal: 'auto',\r\n                    useShadows: true,\r\n                    verticalHasArrows: false,\r\n                    horizontalHasArrows: false\r\n                },\r\n                overviewRulerLanes: 2,\r\n                cursorBlinking: 'blink',\r\n                cursorStyle: 'line',\r\n                fontLigatures: false,\r\n                disableTranslate3d: false,\r\n                hideCursorInOverviewRuler: false,\r\n                scrollBeyondLastLine: true,\r\n                automaticLayout: false,\r\n                wrappingColumn: 300,\r\n                wrappingIndent: 'same',\r\n                wordWrapBreakBeforeCharacters: '([{+',\r\n                wordWrapBreakAfterCharacters: ' \\t})]?|&,;',\r\n                wordWrapBreakObtrusiveCharacters: '.',\r\n                tabFocusMode: false,\r\n                // Features\r\n                hover: true,\r\n                contextmenu: true,\r\n                mouseWheelScrollSensitivity: 1,\r\n                quickSuggestions: true,\r\n                quickSuggestionsDelay: 10,\r\n                iconsInSuggestions: true,\r\n                autoClosingBrackets: true,\r\n                formatOnType: false,\r\n                suggestOnTriggerCharacters: true,\r\n                acceptSuggestionOnEnter: true,\r\n                selectionHighlight: true,\r\n                outlineMarkers: false,\r\n                referenceInfos: true,\r\n                folding: true,\r\n                renderWhitespace: false,\r\n                indentGuides: false,\r\n                useTabStops: true,\r\n                fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),\r\n                fontSize: (platform.isMacintosh ? 12 : 14),\r\n                lineHeight: 0\r\n            };\r\n        }\r\n        return ConfigClass;\r\n    }());\r\n    exports.DefaultConfig = new ConfigClass();\r\n});\r\n\ndefine(\"vs/editor/common/modes/nullMode\", [\"require\", \"exports\", 'vs/editor/common/config/defaultConfig'], function (require, exports, defaultConfig_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var NullState = (function () {\r\n        function NullState(mode, stateData) {\r\n            this.mode = mode;\r\n            this.stateData = stateData;\r\n        }\r\n        NullState.prototype.clone = function () {\r\n            var stateDataClone = (this.stateData ? this.stateData.clone() : null);\r\n            return new NullState(this.mode, stateDataClone);\r\n        };\r\n        NullState.prototype.equals = function (other) {\r\n            if (this.mode !== other.getMode()) {\r\n                return false;\r\n            }\r\n            var otherStateData = other.getStateData();\r\n            if (!this.stateData && !otherStateData) {\r\n                return true;\r\n            }\r\n            if (this.stateData && otherStateData) {\r\n                return this.stateData.equals(otherStateData);\r\n            }\r\n            return false;\r\n        };\r\n        NullState.prototype.getMode = function () {\r\n            return this.mode;\r\n        };\r\n        NullState.prototype.tokenize = function (stream) {\r\n            stream.advanceToEOS();\r\n            return { type: '' };\r\n        };\r\n        NullState.prototype.getStateData = function () {\r\n            return this.stateData;\r\n        };\r\n        NullState.prototype.setStateData = function (stateData) {\r\n            this.stateData = stateData;\r\n        };\r\n        return NullState;\r\n    }());\r\n    exports.NullState = NullState;\r\n    var NullMode = (function () {\r\n        function NullMode() {\r\n            this.richEditSupport = {\r\n                wordDefinition: NullMode.DEFAULT_WORD_REGEXP\r\n            };\r\n        }\r\n        /**\r\n         * Create a word definition regular expression based on default word separators.\r\n         * Optionally provide allowed separators that should be included in words.\r\n         *\r\n         * The default would look like this:\r\n         * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\r\n         */\r\n        NullMode.createWordRegExp = function (allowInWords) {\r\n            if (allowInWords === void 0) { allowInWords = ''; }\r\n            var usualSeparators = defaultConfig_1.USUAL_WORD_SEPARATORS;\r\n            var source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\r\n            for (var i = 0; i < usualSeparators.length; i++) {\r\n                if (allowInWords.indexOf(usualSeparators[i]) >= 0) {\r\n                    continue;\r\n                }\r\n                source += '\\\\' + usualSeparators[i];\r\n            }\r\n            source += '\\\\s]+)';\r\n            return new RegExp(source, 'g');\r\n        };\r\n        NullMode.prototype.getId = function () {\r\n            return NullMode.ID;\r\n        };\r\n        NullMode.prototype.toSimplifiedMode = function () {\r\n            return this;\r\n        };\r\n        // catches numbers (including floating numbers) in the first group, and alphanum in the second\r\n        NullMode.DEFAULT_WORD_REGEXP = NullMode.createWordRegExp();\r\n        NullMode.ID = 'vs.editor.modes.nullMode';\r\n        return NullMode;\r\n    }());\r\n    exports.NullMode = NullMode;\r\n    function nullTokenize(mode, buffer, state, deltaOffset, stopAtOffset) {\r\n        if (deltaOffset === void 0) { deltaOffset = 0; }\r\n        var tokens = [\r\n            {\r\n                startIndex: deltaOffset,\r\n                type: ''\r\n            }\r\n        ];\r\n        var modeTransitions = [\r\n            {\r\n                startIndex: deltaOffset,\r\n                mode: mode\r\n            }\r\n        ];\r\n        return {\r\n            tokens: tokens,\r\n            actualStopOffset: deltaOffset + buffer.length,\r\n            endState: state,\r\n            modeTransitions: modeTransitions\r\n        };\r\n    }\r\n    exports.nullTokenize = nullTokenize;\r\n});\r\n\ndefine(\"vs/editor/common/model/textModelWithTokensHelpers\", [\"require\", \"exports\", 'vs/editor/common/modes/nullMode', 'vs/editor/common/core/modeTransition'], function (require, exports, nullMode_1, modeTransition_1) {\r\n    /*---------------------------------------------------------------------------------------------\r\n     *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n     *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n     *--------------------------------------------------------------------------------------------*/\r\n    'use strict';\r\n    var WordHelper = (function () {\r\n        function WordHelper() {\r\n        }\r\n        WordHelper._safeGetWordDefinition = function (mode) {\r\n            return (mode.richEditSupport ? mode.richEditSupport.wordDefinition : null);\r\n        };\r\n        WordHelper.ensureValidWordDefinition = function (wordDefinition) {\r\n            var result = nullMode_1.NullMode.DEFAULT_WORD_REGEXP;\r\n            if (wordDefinition && (wordDefinition instanceof RegExp)) {\r\n                if (!wordDefinition.global) {\r\n                    var flags = 'g';\r\n                    if (wordDefinition.ignoreCase) {\r\n                        flags += 'i';\r\n                    }\r\n                    if (wordDefinition.multiline) {\r\n                        flags += 'm';\r\n                    }\r\n                    result = new RegExp(wordDefinition.source, flags);\r\n                }\r\n                else {\r\n                    result = wordDefinition;\r\n                }\r\n            }\r\n            result.lastIndex = 0;\r\n            return result;\r\n        };\r\n        WordHelper.massageWordDefinitionOf = function (mode) {\r\n            return WordHelper.ensureValidWordDefinition(WordHelper._safeGetWordDefinition(mode));\r\n        };\r\n        WordHelper._getWordAtColumn = function (txt, column, modeIndex, modeTransitions) {\r\n            var modeStartIndex = modeTransitions[modeIndex].startIndex, modeEndIndex = (modeIndex + 1 < modeTransitions.length ? modeTransitions[modeIndex + 1].startIndex : txt.length), mode = modeTransitions[modeIndex].mode;\r\n            return WordHelper._getWordAtText(column, WordHelper.massageWordDefinitionOf(mode), txt.substring(modeStartIndex, modeEndIndex), modeStartIndex);\r\n        };\r\n        WordHelper.getWordAtPosition = function (textSource, position) {\r\n            if (!textSource._lineIsTokenized(position.lineNumber)) {\r\n                return WordHelper._getWordAtText(position.column, WordHelper.massageWordDefinitionOf(textSource.getMode()), textSource.getLineContent(position.lineNumber), 0);\r\n            }\r\n            var result = null;\r\n            var txt = textSource.getLineContent(position.lineNumber), modeTransitions = textSource._getLineModeTransitions(position.lineNumber), columnIndex = position.column - 1, modeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, columnIndex);\r\n            result = WordHelper._getWordAtColumn(txt, position.column, modeIndex, modeTransitions);\r\n            if (!result && modeIndex > 0 && modeTransitions[modeIndex].startIndex === columnIndex) {\r\n                // The position is right at the beginning of `modeIndex`, so try looking at `modeIndex` - 1 too\r\n                result = WordHelper._getWordAtColumn(txt, position.column, modeIndex - 1, modeTransitions);\r\n            }\r\n            return result;\r\n        };\r\n        WordHelper._getWordAtText = function (column, wordDefinition, text, textOffset) {\r\n            // console.log('_getWordAtText: ', column, text, textOffset);\r\n            var words = text.match(wordDefinition), k, startWord, endWord, startColumn, endColumn, word;\r\n            if (words) {\r\n                for (k = 0; k < words.length; k++) {\r\n                    word = words[k].trim();\r\n                    if (word.length > 0) {\r\n                        startWord = text.indexOf(word, endWord);\r\n                        endWord = startWord + word.length;\r\n                        startColumn = textOffset + startWord + 1;\r\n                        endColumn = textOffset + endWord + 1;\r\n                        if (startColumn <= column && column <= endColumn) {\r\n                            return {\r\n                                word: word,\r\n                                startColumn: startColumn,\r\n                                endColumn: endColumn\r\n                            };\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        return WordHelper;\r\n    }());\r\n    exports.WordHelper = WordHelper;\r\n});\r\n\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\ndefine(\"vs/editor/common/services/editorSimpleWorker\", [\"require\", \"exports\", 'vs/base/common/uri', 'vs/base/common/winjs.base', 'vs/editor/common/core/range', 'vs/base/common/filters', 'vs/editor/common/diff/diffComputer', 'vs/editor/common/model/mirrorModel2', 'vs/editor/common/model/textModelWithTokensHelpers', 'vs/editor/common/modes/linkComputer', 'vs/editor/common/modes/supports/inplaceReplaceSupport', 'vs/editor/common/services/editorSimpleWorkerCommon'], function (require, exports, uri_1, winjs_base_1, range_1, filters_1, diffComputer_1, mirrorModel2_1, textModelWithTokensHelpers_1, linkComputer_1, inplaceReplaceSupport_1, editorSimpleWorkerCommon_1) {\r\n    'use strict';\r\n    var MirrorModel = (function (_super) {\r\n        __extends(MirrorModel, _super);\r\n        function MirrorModel() {\r\n            _super.apply(this, arguments);\r\n        }\r\n        MirrorModel.prototype.getLinesContent = function () {\r\n            return this._lines.slice(0);\r\n        };\r\n        MirrorModel.prototype.getLineCount = function () {\r\n            return this._lines.length;\r\n        };\r\n        MirrorModel.prototype.getLineContent = function (lineNumber) {\r\n            return this._lines[lineNumber - 1];\r\n        };\r\n        MirrorModel.prototype.getWordAtPosition = function (position, wordDefinition) {\r\n            var wordAtText = textModelWithTokensHelpers_1.WordHelper._getWordAtText(position.column, textModelWithTokensHelpers_1.WordHelper.ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\r\n            if (wordAtText) {\r\n                return new range_1.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\r\n            }\r\n            return null;\r\n        };\r\n        MirrorModel.prototype.getWordUntilPosition = function (position, wordDefinition) {\r\n            var wordAtPosition = this.getWordAtPosition(position, wordDefinition);\r\n            if (!wordAtPosition) {\r\n                return {\r\n                    word: '',\r\n                    startColumn: position.column,\r\n                    endColumn: position.column\r\n                };\r\n            }\r\n            return {\r\n                word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\r\n                startColumn: wordAtPosition.startColumn,\r\n                endColumn: position.column\r\n            };\r\n        };\r\n        MirrorModel.prototype._getAllWords = function (wordDefinition) {\r\n            var _this = this;\r\n            var result = [];\r\n            this._lines.forEach(function (line) {\r\n                _this._wordenize(line, wordDefinition).forEach(function (info) {\r\n                    result.push(line.substring(info.start, info.end));\r\n                });\r\n            });\r\n            return result;\r\n        };\r\n        MirrorModel.prototype.getAllUniqueWords = function (wordDefinition, skipWordOnce) {\r\n            var foundSkipWord = false;\r\n            var uniqueWords = {};\r\n            return this._getAllWords(wordDefinition).filter(function (word) {\r\n                if (skipWordOnce && !foundSkipWord && skipWordOnce === word) {\r\n                    foundSkipWord = true;\r\n                    return false;\r\n                }\r\n                else if (uniqueWords[word]) {\r\n                    return false;\r\n                }\r\n                else {\r\n                    uniqueWords[word] = true;\r\n                    return true;\r\n                }\r\n            });\r\n        };\r\n        //\t// TODO@Joh, TODO@Alex - remove these and make sure the super-things work\r\n        MirrorModel.prototype._wordenize = function (content, wordDefinition) {\r\n            var result = [];\r\n            var match;\r\n            while (match = wordDefinition.exec(content)) {\r\n                if (match[0].length === 0) {\r\n                    // it did match the empty string\r\n                    break;\r\n                }\r\n                result.push({ start: match.index, end: match.index + match[0].length });\r\n            }\r\n            return result;\r\n        };\r\n        MirrorModel.prototype.getValueInRange = function (range) {\r\n            if (range.startLineNumber === range.endLineNumber) {\r\n                return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\r\n            }\r\n            var lineEnding = this._eol, startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];\r\n            resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\r\n            for (var i = startLineIndex + 1; i < endLineIndex; i++) {\r\n                resultLines.push(this._lines[i]);\r\n            }\r\n            resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\r\n            return resultLines.join(lineEnding);\r\n        };\r\n        return MirrorModel;\r\n    }(mirrorModel2_1.MirrorModel2));\r\n    var EditorSimpleWorkerImpl = (function (_super) {\r\n        __extends(EditorSimpleWorkerImpl, _super);\r\n        function EditorSimpleWorkerImpl() {\r\n            _super.call(this);\r\n            this._models = Object.create(null);\r\n        }\r\n        EditorSimpleWorkerImpl.prototype.acceptNewModel = function (data) {\r\n            this._models[data.url] = new MirrorModel(uri_1.default.parse(data.url), data.value.lines, data.value.EOL, data.versionId);\r\n        };\r\n        EditorSimpleWorkerImpl.prototype.acceptModelChanged = function (strURL, events) {\r\n            if (!this._models[strURL]) {\r\n                return;\r\n            }\r\n            var model = this._models[strURL];\r\n            model.onEvents(events);\r\n        };\r\n        EditorSimpleWorkerImpl.prototype.acceptRemovedModel = function (strURL) {\r\n            if (!this._models[strURL]) {\r\n                return;\r\n            }\r\n            delete this._models[strURL];\r\n        };\r\n        // ---- BEGIN diff --------------------------------------------------------------------------\r\n        EditorSimpleWorkerImpl.prototype.computeDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\r\n            var original = this._models[originalUrl];\r\n            var modified = this._models[modifiedUrl];\r\n            if (!original || !modified) {\r\n                return null;\r\n            }\r\n            var originalLines = original.getLinesContent();\r\n            var modifiedLines = modified.getLinesContent();\r\n            var diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {\r\n                shouldPostProcessCharChanges: true,\r\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\r\n                shouldConsiderTrimWhitespaceInEmptyCase: true\r\n            });\r\n            return winjs_base_1.TPromise.as(diffComputer.computeDiff());\r\n        };\r\n        EditorSimpleWorkerImpl.prototype.computeDirtyDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {\r\n            var original = this._models[originalUrl];\r\n            var modified = this._models[modifiedUrl];\r\n            if (!original || !modified) {\r\n                return null;\r\n            }\r\n            var originalLines = original.getLinesContent();\r\n            var modifiedLines = modified.getLinesContent();\r\n            var diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {\r\n                shouldPostProcessCharChanges: false,\r\n                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\r\n                shouldConsiderTrimWhitespaceInEmptyCase: false\r\n            });\r\n            return winjs_base_1.TPromise.as(diffComputer.computeDiff());\r\n        };\r\n        // ---- END diff --------------------------------------------------------------------------\r\n        EditorSimpleWorkerImpl.prototype.computeLinks = function (modelUrl) {\r\n            var model = this._models[modelUrl];\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            return winjs_base_1.TPromise.as(linkComputer_1.computeLinks(model));\r\n        };\r\n        // ---- BEGIN suggest --------------------------------------------------------------------------\r\n        EditorSimpleWorkerImpl.prototype.textualSuggest = function (modelUrl, position, wordDef, wordDefFlags) {\r\n            var model = this._models[modelUrl];\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            return winjs_base_1.TPromise.as(this._suggestFiltered(model, position, new RegExp(wordDef, wordDefFlags)));\r\n        };\r\n        EditorSimpleWorkerImpl.prototype._suggestFiltered = function (model, position, wordDefRegExp) {\r\n            var value = this._suggestUnfiltered(model, position, wordDefRegExp);\r\n            // filter suggestions\r\n            return [{\r\n                    currentWord: value.currentWord,\r\n                    suggestions: value.suggestions.filter(function (element) { return !!filters_1.fuzzyContiguousFilter(value.currentWord, element.label); }),\r\n                    incomplete: value.incomplete\r\n                }];\r\n        };\r\n        EditorSimpleWorkerImpl.prototype._suggestUnfiltered = function (model, position, wordDefRegExp) {\r\n            var currentWord = model.getWordUntilPosition(position, wordDefRegExp).word;\r\n            var allWords = model.getAllUniqueWords(wordDefRegExp, currentWord);\r\n            var suggestions = allWords.filter(function (word) {\r\n                return !(/^-?\\d*\\.?\\d/.test(word)); // filter out numbers\r\n            }).map(function (word) {\r\n                return {\r\n                    type: 'text',\r\n                    label: word,\r\n                    codeSnippet: word,\r\n                    noAutoAccept: true\r\n                };\r\n            });\r\n            return {\r\n                currentWord: currentWord,\r\n                suggestions: suggestions\r\n            };\r\n        };\r\n        // ---- END suggest --------------------------------------------------------------------------\r\n        EditorSimpleWorkerImpl.prototype.navigateValueSet = function (modelUrl, range, up, wordDef, wordDefFlags) {\r\n            var model = this._models[modelUrl];\r\n            if (!model) {\r\n                return null;\r\n            }\r\n            var wordDefRegExp = new RegExp(wordDef, wordDefFlags);\r\n            if (range.startColumn === range.endColumn) {\r\n                range.endColumn += 1;\r\n            }\r\n            var selectionText = model.getValueInRange(range);\r\n            var wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\r\n            var word = null;\r\n            if (wordRange !== null) {\r\n                word = model.getValueInRange(wordRange);\r\n            }\r\n            var result = inplaceReplaceSupport_1.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\r\n            return winjs_base_1.TPromise.as(result);\r\n        };\r\n        return EditorSimpleWorkerImpl;\r\n    }(editorSimpleWorkerCommon_1.EditorSimpleWorker));\r\n    exports.EditorSimpleWorkerImpl = EditorSimpleWorkerImpl;\r\n    /**\r\n     * Called on the worker side\r\n     */\r\n    function create() {\r\n        return new EditorSimpleWorkerImpl();\r\n    }\r\n    exports.create = create;\r\n});\r\n\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport const DifferenceType = {\n\tAdd : 0,\n\tRemove : 1,\n\tChange : 2\n};\n\n/**\n * Represents information about a specific difference between two sequences.\n */\nexport class DiffChange {\n\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\tpublic originalStart:number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\tpublic originalLength:number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tpublic modifiedStart:number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tpublic modifiedLength:number;\n\n\t/**\n\t * Constructs a new DiffChange with the given sequence information\n\t * and content.\n\t */\n\tconstructor(originalStart:number, originalLength:number, modifiedStart:number, modifiedLength:number) {\n\t\t//Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n\t\tthis.originalStart = originalStart;\n\t\tthis.originalLength = originalLength;\n\t\tthis.modifiedStart = modifiedStart;\n\t\tthis.modifiedLength = modifiedLength;\n\t}\n\n\t/**\n\t * The type of difference.\n\t */\n\tpublic getChangeType() {\n\t\tif (this.originalLength === 0) {\n\t\t\treturn DifferenceType.Add;\n\t\t} else if (this.modifiedLength === 0) {\n\t\t\treturn DifferenceType.Remove;\n\t\t} else {\n\t\t\treturn DifferenceType.Change;\n\t\t}\n\t}\n\n\t/**\n\t * The end point (exclusive) of the change in the original sequence.\n\t */\n\tpublic getOriginalEnd() {\n\t\treturn this.originalStart + this.originalLength;\n\t}\n\n\t/**\n\t * The end point (exclusive) of the change in the modified sequence.\n\t */\n\tpublic getModifiedEnd() {\n\t\treturn this.modifiedStart + this.modifiedLength;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {DiffChange} from 'vs/base/common/diff/diffChange';\n\nexport interface ISequence {\n\tgetLength(): number;\n\tgetElementHash(index:number): string;\n}\n\nexport interface IDiffChange {\n\t/**\n\t * The position of the first element in the original sequence which\n\t * this change affects.\n\t */\n\toriginalStart:number;\n\n\t/**\n\t * The number of elements from the original sequence which were\n\t * affected.\n\t */\n\toriginalLength:number;\n\n\t/**\n\t * The position of the first element in the modified sequence which\n\t * this change affects.\n\t */\n\tmodifiedStart:number;\n\n\t/**\n\t * The number of elements from the modified sequence which were\n\t * affected (added).\n\t */\n\tmodifiedLength:number;\n}\n\nexport interface IContinueProcessingPredicate {\n\t(furthestOriginalIndex:number, originalSequence:ISequence, matchLengthOfLongest:number): boolean;\n}\n\n//\n// The code below has been ported from a C# implementation in VS\n//\n\nexport class Debug {\n\n\tpublic static Assert(condition:boolean, message:string): void {\n\t\tif (!condition) {\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n}\n\nexport class MyArray {\n\t/**\n\t * Copies a range of elements from an Array starting at the specified source index and pastes\n\t * them to another Array starting at the specified destination index. The length and the indexes\n\t * are specified as 64-bit integers.\n\t * sourceArray:\n\t *\t\tThe Array that contains the data to copy.\n\t * sourceIndex:\n\t *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n\t * destinationArray:\n\t *\t\tThe Array that receives the data.\n\t * destinationIndex:\n\t *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n\t * length:\n\t *\t\tA 64-bit integer that represents the number of elements to copy.\n\t */\n\tpublic static Copy(sourceArray:any[], sourceIndex:number, destinationArray:any[], destinationIndex:number, length:number) {\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tdestinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n\t\t}\n\t}\n}\n\n//*****************************************************************************\n// LcsDiff.cs\n//\n// An implementation of the difference algorithm described in\n// \"An O(ND) Difference Algorithm and its letiations\" by Eugene W. Myers\n//\n// Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve\n//*****************************************************************************\n\n// Our total memory usage for storing history is (worst-case):\n// 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)\n// 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB\nlet MaxDifferencesHistory = 1447;\n//let MaxDifferencesHistory = 100;\n\n\n\n\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarktNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n\n\tprivate m_changes:DiffChange[];\n\tprivate m_originalStart:number;\n\tprivate m_modifiedStart:number;\n\tprivate m_originalCount:number;\n\tprivate m_modifiedCount:number;\n\n\t/**\n\t * Constructs a new DiffChangeHelper for the given DiffSequences.\n\t */\n\tconstructor() {\n\t\tthis.m_changes = [];\n\t\tthis.m_originalStart = Number.MAX_VALUE;\n\t\tthis.m_modifiedStart = Number.MAX_VALUE;\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t}\n\n\t/**\n\t * Marks the beginning of the next change in the set of differences.\n\t */\n\tpublic MarkNextChange(): void {\n\t\t// Only add to the list if there is something to add\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Add the new change to our list\n\t\t\tthis.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount,\n\t\t\t\tthis.m_modifiedStart, this.m_modifiedCount));\n\t\t}\n\n\t\t// Reset for the next change\n\t\tthis.m_originalCount = 0;\n\t\tthis.m_modifiedCount = 0;\n\t\tthis.m_originalStart = Number.MAX_VALUE;\n\t\tthis.m_modifiedStart = Number.MAX_VALUE;\n\t}\n\n\t/**\n\t * Adds the original element at the given position to the elements\n\t * affected by the current change. The modified index gives context\n\t * to the change position with respect to the original sequence.\n\t * @param originalIndex The index of the original element to add.\n\t * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n\t */\n\tpublic AddOriginalElement(originalIndex:number, modifiedIndex:number) {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_originalCount++;\n\t}\n\n\t/**\n\t * Adds the modified element at the given position to the elements\n\t * affected by the current change. The original index gives context\n\t * to the change position with respect to the modified sequence.\n\t * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n\t * @param modifiedIndex The index of the modified element to add.\n\t */\n\tpublic AddModifiedElement(originalIndex:number, modifiedIndex:number): void {\n\t\t// The 'true' start index is the smallest of the ones we've seen\n\t\tthis.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n\t\tthis.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n\n\t\tthis.m_modifiedCount++;\n\t}\n\n\t/**\n\t * Retrieves all of the changes marked by the class.\n\t */\n\tpublic getChanges(): DiffChange[] {\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\treturn this.m_changes;\n\t}\n\n\tpublic getReverseChanges(): DiffChange[] {\n\t\t/// <summary>\n\t\t/// Retrieves all of the changes marked by the class in the reverse order\n\t\t/// </summary>\n\t\tif (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n\t\t\t// Finish up on whatever is left\n\t\t\tthis.MarkNextChange();\n\t\t}\n\n\t\tthis.m_changes.reverse();\n\t\treturn this.m_changes;\n\t}\n\n}\n\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its letiations\" by Eugene W. Myers\n */\nexport class LcsDiff {\n\n\tprivate OriginalSequence:ISequence;\n\tprivate ModifiedSequence:ISequence;\n\tprivate ContinueProcessingPredicate:IContinueProcessingPredicate;\n\n\tprivate m_originalIds:number[];\n\tprivate m_modifiedIds:number[];\n\tprivate m_forwardHistory:number[][];\n\tprivate m_reverseHistory:number[][];\n\n\t/**\n\t * Constructs the DiffFinder\n\t */\n\tconstructor(originalSequence:ISequence, newSequence:ISequence, continueProcessingPredicate:IContinueProcessingPredicate = null) {\n\t\tthis.OriginalSequence = originalSequence;\n\t\tthis.ModifiedSequence = newSequence;\n\t\tthis.ContinueProcessingPredicate = continueProcessingPredicate;\n\t\tthis.m_originalIds = [];\n\t\tthis.m_modifiedIds = [];\n\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\n\t\tthis.ComputeUniqueIdentifiers();\n\t}\n\n\tprivate ComputeUniqueIdentifiers(): void {\n\t\tlet originalSequenceLength = this.OriginalSequence.getLength();\n\t\tlet modifiedSequenceLength = this.ModifiedSequence.getLength();\n\t\tthis.m_originalIds = new Array<number>(originalSequenceLength);\n\t\tthis.m_modifiedIds = new Array<number>(modifiedSequenceLength);\n\n\t\t// Create a new hash table for unique elements from the original\n\t\t// sequence.\n\t\tlet hashTable:{[key:string]:number;} = {};\n\t\tlet currentUniqueId = 1;\n\t\tlet i: number;\n\n\t\t// Fill up the hash table for unique elements\n\t\tfor (i = 0; i < originalSequenceLength; i++) {\n\t\t\tlet originalElementHash = this.OriginalSequence.getElementHash(i);\n\t\t\tif (!hashTable.hasOwnProperty(originalElementHash)) {\n\t\t\t\t// No entry in the hashtable so this is a new unique element.\n\t\t\t\t// Assign the element a new unique identifier and add it to the\n\t\t\t\t// hash table\n\t\t\t\tthis.m_originalIds[i] = currentUniqueId++;\n\t\t\t\thashTable[originalElementHash] = this.m_originalIds[i];\n\t\t\t} else {\n\t\t\t\tthis.m_originalIds[i] = hashTable[originalElementHash];\n\t\t\t}\n\t\t}\n\n\t\t// Now match up modified elements\n\t\tfor (i = 0; i < modifiedSequenceLength; i++) {\n\t\t\tlet modifiedElementHash = this.ModifiedSequence.getElementHash(i);\n\t\t\tif (!hashTable.hasOwnProperty(modifiedElementHash)) {\n\t\t\t\tthis.m_modifiedIds[i] = currentUniqueId++;\n\t\t\t\thashTable[modifiedElementHash] = this.m_modifiedIds[i];\n\t\t\t} else {\n\t\t\t\tthis.m_modifiedIds[i] = hashTable[modifiedElementHash];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate ElementsAreEqual(originalIndex:number, newIndex:number): boolean {\n\t\treturn this.m_originalIds[originalIndex] === this.m_modifiedIds[newIndex];\n\t}\n\n\tpublic ComputeDiff(): IDiffChange[] {\n\t\treturn this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1);\n\t}\n\n\t/**\n\t * Computes the differences between the original and modified input\n\t * sequences on the bounded range.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate _ComputeDiff(originalStart:number, originalEnd:number, modifiedStart:number, modifiedEnd:number): DiffChange[] {\n\t\tlet quitEarlyArr = [ false ];\n\t\treturn this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n\t}\n\n\t/**\n\t * Private helper method which computes the differences on the bounded range\n\t * recursively.\n\t * @returns An array of the differences between the two input sequences.\n\t */\n\tprivate ComputeDiffRecursive(originalStart:number, originalEnd:number, modifiedStart:number, modifiedEnd:number, quitEarlyArr:boolean[]): DiffChange[] {\n\t\tquitEarlyArr[0] = false;\n\n\t\t// Find the start of the differences\n\t\twhile (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n\t\t\toriginalStart++;\n\t\t\tmodifiedStart++;\n\t\t}\n\n\t\t// Find the end of the differences\n\t\twhile (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n\t\t\toriginalEnd--;\n\t\t\tmodifiedEnd--;\n\t\t}\n\n\t\t// In the special case where we either have all insertions or all deletions or the sequences are identical\n\t\tif (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n\t\t\tlet changes:DiffChange[];\n\n\t\t\tif (modifiedStart <= modifiedEnd) {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\n\t\t\t\t// All insertions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t];\n\t\t\t} else if (originalStart <= originalEnd) {\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// All deletions\n\t\t\t\tchanges = [\n\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tDebug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n\t\t\t\tDebug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n\n\t\t\t\t// Identical sequences - No differences\n\t\t\t\tchanges = [];\n\t\t\t}\n\n\t\t\treturn changes;\n\t\t}\n\n\t\t// This problem can be solved using the Divide-And-Conquer technique.\n\t\tlet midOriginalArr = [0], midModifiedArr = [0];\n\t\tlet result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n\n\t\tlet midOriginal = midOriginalArr[0];\n\t\tlet midModified = midModifiedArr[0];\n\n\t\tif (result !== null) {\n\t\t\t// Result is not-null when there was enough memory to compute the changes while\n\t\t\t// searching for the recursion point\n\t\t\treturn result;\n\t\t} else if (!quitEarlyArr[0]) {\n\t\t\t// We can break the problem down recursively by finding the changes in the\n\t\t\t// First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n\t\t\t// Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n\t\t\t// NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n\n\t\t\tlet leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n\t\t\tlet rightChanges: DiffChange[] = [];\n\n\t\t\tif (!quitEarlyArr[0]) {\n\t\t\t\trightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n\t\t\t} else {\n\t\t\t\t// We did't have time to finish the first half, so we don't have time to compute this half.\n\t\t\t\t// Consider the entire rest of the sequence different.\n\t\t\t\trightChanges = [\n\t\t\t\t\tnew DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n\t\t\t\t];\n\t\t\t}\n\n\t\t\treturn this.ConcatenateChanges(leftChanges, rightChanges);\n\t\t}\n\n\t\t// If we hit here, we quit early, and so can't return anything meaningful\n\t\treturn [\n\t\t\tnew DiffChange(originalStart, originalEnd -originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t];\n\t}\n\n\tprivate WALKTRACE(diagonalForwardBase:number, diagonalForwardStart:number, diagonalForwardEnd:number, diagonalForwardOffset:number,\n\t\t\t\t\tdiagonalReverseBase:number, diagonalReverseStart:number, diagonalReverseEnd:number, diagonalReverseOffset:number,\n\t\t\t\t\tforwardPoints:number[], reversePoints:number[],\n\t\t\t\t\toriginalIndex:number, originalEnd:number, midOriginalArr:number[],\n\t\t\t\t\tmodifiedIndex:number, modifiedEnd:number, midModifiedArr:number[],\n\t\t\t\t\tdeltaIsEven:boolean, quitEarlyArr:boolean[]): DiffChange[] {\n\t\tlet forwardChanges: DiffChange[] = null, reverseChanges: DiffChange[] = null;\n\n\t\t// First, walk backward through the forward diagonals history\n\t\tlet changeHelper = new DiffChangeHelper();\n\t\tlet diagonalMin = diagonalForwardStart;\n\t\tlet diagonalMax = diagonalForwardEnd;\n\t\tlet diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n\t\tlet lastOriginalIndex = Number.MIN_VALUE;\n\t\tlet historyIndex = this.m_forwardHistory.length - 1;\n\t\tlet diagonal: number;\n\n\t\tdo {\n\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\tdiagonal = diagonalRelative + diagonalForwardBase;\n\n\t\t\t// Figure out where we came from\n\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t// Vertical line (the element is an insert)\n\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t} else {\n\t\t\t\t// Horizontal line (the element is a deletion)\n\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n\t\t\t\tif (originalIndex < lastOriginalIndex) {\n\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t}\n\t\t\t\tlastOriginalIndex = originalIndex - 1;\n\t\t\t\tchangeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n\t\t\t}\n\n\t\t\tif (historyIndex >= 0) {\n\t\t\t\tforwardPoints = this.m_forwardHistory[historyIndex];\n\t\t\t\tdiagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n\t\t\t\tdiagonalMin = 1;\n\t\t\t\tdiagonalMax = forwardPoints.length - 1;\n\t\t\t}\n\t\t} while (--historyIndex >= -1);\n\n\t\t// Ironically, we get the forward changes as the reverse of the\n\t\t// order we added them since we technically added them backwards\n\t\tforwardChanges = changeHelper.getReverseChanges();\n\n\t\tif (quitEarlyArr[0]) {\n\t\t\t// TODO: Calculate a partial from the reverse diagonals.\n\t\t\t//       For now, just assume everything after the midOriginal/midModified point is a diff\n\n\t\t\tlet originalStartPoint = midOriginalArr[0] + 1;\n\t\t\tlet modifiedStartPoint = midModifiedArr[0] + 1;\n\n\t\t\tif (forwardChanges !== null && forwardChanges.length > 0) {\n\t\t\t\tlet lastForwardChange = forwardChanges[forwardChanges.length - 1];\n\t\t\t\toriginalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n\t\t\t\tmodifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n\t\t\t}\n\n\t\t\treverseChanges = [\n\t\t\t\tnew DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1,\n\t\t\t\t\t\t\tmodifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n\t\t\t];\n\t\t} else {\n\t\t\t// Now walk backward through the reverse diagonals history\n\t\t\tchangeHelper = new DiffChangeHelper();\n\t\t\tdiagonalMin = diagonalReverseStart;\n\t\t\tdiagonalMax = diagonalReverseEnd;\n\t\t\tdiagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n\t\t\tlastOriginalIndex = Number.MAX_VALUE;\n\t\t\thistoryIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n\n\t\t\tdo {\n\t\t\t\t// Get the diagonal index from the relative diagonal number\n\t\t\t\tdiagonal = diagonalRelative + diagonalReverseBase;\n\n\t\t\t\t// Figure out where we came from\n\t\t\t\tif (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\t// Horizontal line (the element is a deletion))\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex + 1;\n\t\t\t\t\tchangeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t} else {\n\t\t\t\t\t// Vertical line (the element is an insertion)\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t\tmodifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n\t\t\t\t\tif (originalIndex > lastOriginalIndex) {\n\t\t\t\t\t\tchangeHelper.MarkNextChange();\n\t\t\t\t\t}\n\t\t\t\t\tlastOriginalIndex = originalIndex;\n\t\t\t\t\tchangeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n\t\t\t\t\tdiagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n\t\t\t\t}\n\n\t\t\t\tif (historyIndex >= 0) {\n\t\t\t\t\treversePoints = this.m_reverseHistory[historyIndex];\n\t\t\t\t\tdiagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n\t\t\t\t\tdiagonalMin = 1;\n\t\t\t\t\tdiagonalMax = reversePoints.length - 1;\n\t\t\t\t}\n\t\t\t} while (--historyIndex >= -1);\n\n\t\t\t// There are cases where the reverse history will find diffs that\n\t\t\t// are correct, but not intuitive, so we need shift them.\n\t\t\treverseChanges = changeHelper.getChanges();\n\t\t}\n\n\t\treturn this.ConcatenateChanges(forwardChanges, reverseChanges);\n\t}\n\n\t/**\n\t * Given the range to compute the diff on, this method finds the point:\n\t * (midOriginal, midModified)\n\t * that exists in the middle of the LCS of the two sequences and\n\t * is the point at which the LCS problem may be broken down recursively.\n\t * This method will try to keep the LCS trace in memory. If the LCS recursion\n\t * point is calculated and the full trace is available in memory, then this method\n\t * will return the change list.\n\t * @param originalStart The start bound of the original sequence range\n\t * @param originalEnd The end bound of the original sequence range\n\t * @param modifiedStart The start bound of the modified sequence range\n\t * @param modifiedEnd The end bound of the modified sequence range\n\t * @param midOriginal The middle point of the original sequence range\n\t * @param midModified The middle point of the modified sequence range\n\t * @returns The diff changes, if available, otherwise null\n\t */\n\tprivate ComputeRecursionPoint(originalStart:number, originalEnd:number, modifiedStart:number, modifiedEnd:number, midOriginalArr:number[], midModifiedArr:number[], quitEarlyArr:boolean[]) {\n\t\tlet originalIndex:number, modifiedIndex:number;\n\t\tlet diagonalForwardStart = 0, diagonalForwardEnd = 0;\n\t\tlet diagonalReverseStart = 0, diagonalReverseEnd = 0;\n\t\tlet numDifferences:number;\n\n\t\t// To traverse the edit graph and produce the proper LCS, our actual\n\t\t// start position is just outside the given boundary\n\t\toriginalStart--;\n\t\tmodifiedStart--;\n\n\t\t// We set these up to make the compiler happy, but they will\n\t\t// be replaced before we return with the actual recursion point\n\t\tmidOriginalArr[0] = 0;\n\t\tmidModifiedArr[0] = 0;\n\n\t\t// Clear out the history\n\t\tthis.m_forwardHistory = [];\n\t\tthis.m_reverseHistory = [];\n\n\t\t// Each cell in the two arrays corresponds to a diagonal in the edit graph.\n\t\t// The integer value in the cell represents the originalIndex of the furthest\n\t\t// reaching point found so far that ends in that diagonal.\n\t\t// The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n\t\tlet maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n\t\tlet numDiagonals = maxDifferences + 1;\n\t\tlet forwardPoints:number[] = new Array<number>(numDiagonals);\n\t\tlet reversePoints:number[] = new Array<number>(numDiagonals);\n\t\t// diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n\t\t// diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n\t\tlet diagonalForwardBase = (modifiedEnd - modifiedStart);\n\t\tlet diagonalReverseBase = (originalEnd - originalStart);\n\t\t// diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalForwardBase)\n\t\t// diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n\t\t//    diagonal number (relative to diagonalReverseBase)\n\t\tlet diagonalForwardOffset = (originalStart - modifiedStart);\n\t\tlet diagonalReverseOffset = (originalEnd - modifiedEnd);\n\n\t\t// delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n\t\t//   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n\t\t// The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n\t\tlet delta = diagonalReverseBase - diagonalForwardBase;\n\t\tlet deltaIsEven = (delta % 2 === 0);\n\n\t\t// Here we set up the start and end points as the furthest points found so far\n\t\t// in both the forward and reverse directions, respectively\n\t\tforwardPoints[diagonalForwardBase] = originalStart;\n\t\treversePoints[diagonalReverseBase] = originalEnd;\n\n\t\t// Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n\t\tquitEarlyArr[0] = false;\n\n\n\n\t\t// A couple of points:\n\t\t// --With this method, we iterate on the number of differences between the two sequences.\n\t\t//   The more differences there actually are, the longer this will take.\n\t\t// --Also, as the number of differences increases, we have to search on diagonals further\n\t\t//   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n\t\t// --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n\t\t//   is even and odd diagonals only when numDifferences is odd.\n\t\tlet diagonal:number, tempOriginalIndex:number;\n\t\tfor (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n\t\t\tlet furthestOriginalIndex = 0;\n\t\t\tlet furthestModifiedIndex = 0;\n\n\t\t\t// Run the algorithm in the forward direction\n\t\t\tdiagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tdiagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n\t\t\tfor (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalStart, modifiedStart)\n\t\t\t\tif (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal + 1];\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = forwardPoints[diagonal - 1] + 1;\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap in step 3\n\t\t\t\ttempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// so long as the elements are equal.\n\t\t\t\twhile (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n\t\t\t\t\toriginalIndex++;\n\t\t\t\t\tmodifiedIndex++;\n\t\t\t\t}\n\t\t\t\tforwardPoints[diagonal] = originalIndex;\n\n\t\t\t\tif (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n\t\t\t\t\tfurthestOriginalIndex = originalIndex;\n\t\t\t\t\tfurthestModifiedIndex = modifiedIndex;\n\t\t\t\t}\n\n\t\t\t\t// STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n\t\t\t\t// and diagonal is in the range of reverse diagonals computed for numDifferences-1\n\t\t\t\t// (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n\t\t\t\t\tif (originalIndex >= reversePoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Check to see if we should be quitting early, before moving on to the next iteration.\n\t\t\tlet matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n\n\t\t\tif (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {\n\t\t\t\t// We can't finish, so skip ahead to generating a result from what we have.\n\t\t\t\tquitEarlyArr[0] = true;\n\n\t\t\t\t// Use the furthest distance we got in the forward direction.\n\t\t\t\tmidOriginalArr[0] = furthestOriginalIndex;\n\t\t\t\tmidModifiedArr[0] = furthestModifiedIndex;\n\n\t\t\t\tif (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t// Enough of the history is in memory to walk it backwards\n\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\t// We didn't actually remember enough of the history.\n\n\t\t\t\t\t//Since we are quiting the diff early, we need to shift back the originalStart and modified start\n\t\t\t\t\t//back into the boundary limits since we decremented their value above beyond the boundary limit.\n\t\t\t\t\toriginalStart++;\n\t\t\t\t\tmodifiedStart++;\n\n\t\t\t\t\treturn [\n\t\t\t\t\t\tnew DiffChange(originalStart, originalEnd - originalStart + 1,\n\t\t\t\t\t\t\t\tmodifiedStart, modifiedEnd - modifiedStart + 1)\n\t\t\t\t\t];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Run the algorithm in the reverse direction\n\t\t\tdiagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tdiagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n\t\t\tfor (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n\t\t\t\t// STEP 1: We extend the furthest reaching point in the present diagonal\n\t\t\t\t// by looking at the diagonals above and below and picking the one whose point\n\t\t\t\t// is further away from the start point (originalEnd, modifiedEnd)\n\t\t\t\tif (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal + 1] - 1;\n\t\t\t\t} else {\n\t\t\t\t\toriginalIndex = reversePoints[diagonal - 1];\n\t\t\t\t}\n\t\t\t\tmodifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n\n\t\t\t\t// Save the current originalIndex so we can test for false overlap\n\t\t\t\ttempOriginalIndex = originalIndex;\n\n\t\t\t\t// STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n\t\t\t\t// as long as the elements are equal.\n\t\t\t\twhile (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n\t\t\t\t\toriginalIndex--;\n\t\t\t\t\tmodifiedIndex--;\n\t\t\t\t}\n\t\t\t\treversePoints[diagonal] = originalIndex;\n\n\t\t\t\t// STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n\t\t\t\t// and diagonal is in the range of forward diagonals computed for numDifferences\n\t\t\t\t// then check for overlap.\n\t\t\t\tif (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n\t\t\t\t\tif (originalIndex <= forwardPoints[diagonal]) {\n\t\t\t\t\t\tmidOriginalArr[0] = originalIndex;\n\t\t\t\t\t\tmidModifiedArr[0] = modifiedIndex;\n\n\t\t\t\t\t\tif (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {\n\t\t\t\t\t\t\t// BINGO! We overlapped, and we have the full trace in memory!\n\t\t\t\t\t\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\t\t\t\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\t\t\t\t\t\tforwardPoints, reversePoints,\n\t\t\t\t\t\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\t\t\t\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\t\t\t\t\t\tdeltaIsEven, quitEarlyArr\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Either false overlap, or we didn't have enough memory for the full trace\n\t\t\t\t\t\t\t// Just return the recursion point\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Save current vectors to history before the next iteration\n\t\t\tif (numDifferences <= MaxDifferencesHistory) {\n\t\t\t\t// We are allocating space for one extra int, which we fill with\n\t\t\t\t// the index of the diagonal base index\n\t\t\t\tlet temp:number[] = new Array<number>(diagonalForwardEnd - diagonalForwardStart + 2);\n\t\t\t\ttemp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n\t\t\t\tMyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n\t\t\t\tthis.m_forwardHistory.push(temp);\n\n\t\t\t\ttemp = new Array<number>(diagonalReverseEnd - diagonalReverseStart + 2);\n\t\t\t\ttemp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n\t\t\t\tMyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n\t\t\t\tthis.m_reverseHistory.push(temp);\n\t\t\t}\n\n\t\t}\n\n\n\n\t\t// If we got here, then we have the full trace in history. We just have to convert it to a change list\n\t\t// NOTE: This part is a bit messy\n\t\treturn this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset,\n\t\t\tdiagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset,\n\t\t\tforwardPoints, reversePoints,\n\t\t\toriginalIndex, originalEnd, midOriginalArr,\n\t\t\tmodifiedIndex, modifiedEnd, midModifiedArr,\n\t\t\tdeltaIsEven, quitEarlyArr\n\t\t);\n\t}\n\n\t/**\n\t * Concatenates the two input DiffChange lists and returns the resulting\n\t * list.\n\t * @param The left changes\n\t * @param The right changes\n\t * @returns The concatenated list\n\t */\n\tprivate ConcatenateChanges(left:DiffChange[], right:DiffChange[]): DiffChange[] {\n\t\tlet mergedChangeArr:DiffChange[] = [];\n\t\tlet result:DiffChange[] = null;\n\n\t\tif (left.length === 0 || right.length === 0) {\n\t\t\treturn (right.length > 0) ? right : left;\n\t\t} else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n\t\t\t// Since we break the problem down recursively, it is possible that we\n\t\t\t// might recurse in the middle of a change thereby splitting it into\n\t\t\t// two changes. Here in the combining stage, we detect and fuse those\n\t\t\t// changes back together\n\t\t\tresult = new Array<DiffChange>(left.length + right.length - 1);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length - 1);\n\t\t\tresult[left.length - 1] = mergedChangeArr[0];\n\t\t\tMyArray.Copy(right, 1, result, left.length, right.length - 1);\n\n\t\t\treturn result;\n\t\t} else {\n\t\t\tresult = new Array<DiffChange>(left.length + right.length);\n\t\t\tMyArray.Copy(left, 0, result, 0, left.length);\n\t\t\tMyArray.Copy(right, 0, result, left.length, right.length);\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the two changes overlap and can be merged into a single\n\t * change\n\t * @param left The left change\n\t * @param right The right change\n\t * @param mergedChange The merged change if the two overlap, null otherwise\n\t * @returns True if the two changes overlap\n\t */\n\tprivate ChangesOverlap(left:DiffChange, right:DiffChange, mergedChangeArr:DiffChange[]): boolean {\n\t\tDebug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n\t\tDebug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n\n\t\tif (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart)\n\t\t{\n\t\t\tlet originalStart = left.originalStart;\n\t\t\tlet originalLength = left.originalLength;\n\t\t\tlet modifiedStart = left.modifiedStart;\n\t\t\tlet modifiedLength = left.modifiedLength;\n\n\t\t\tif (left.originalStart + left.originalLength >= right.originalStart) {\n\t\t\t\toriginalLength = right.originalStart + right.originalLength - left.originalStart;\n\t\t\t}\n\t\t\tif (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n\t\t\t\tmodifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n\t\t\t}\n\n\t\t\tmergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n\t\t\treturn true;\n\t\t} else {\n\t\t\tmergedChangeArr[0] = null;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * Helper method used to clip a diagonal index to the range of valid\n\t * diagonals. This also decides whether or not the diagonal index,\n\t * if it exceeds the boundary, should be clipped to the boundary or clipped\n\t * one inside the boundary depending on the Even/Odd status of the boundary\n\t * and numDifferences.\n\t * @param diagonal The index of the diagonal to clip.\n\t * @param numDifferences The current number of differences being iterated upon.\n\t * @param diagonalBaseIndex The base reference diagonal.\n\t * @param numDiagonals The total number of diagonals.\n\t * @returns The clipped diagonal index.\n\t */\n\n\tprivate ClipDiagonalBound(diagonal:number, numDifferences:number, diagonalBaseIndex:number, numDiagonals:number): number {\n\t\tif (diagonal >= 0 && diagonal < numDiagonals) {\n\t\t\t// Nothing to clip, its in range\n\t\t\treturn diagonal;\n\t\t}\n\n\t\t// diagonalsBelow: The number of diagonals below the reference diagonal\n\t\t// diagonalsAbove: The number of diagonals above the reference diagonal\n\t\tlet diagonalsBelow = diagonalBaseIndex;\n\t\tlet diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n\t\tlet diffEven = (numDifferences % 2 === 0);\n\n\t\tif (diagonal < 0) {\n\t\t\tlet lowerBoundEven = (diagonalsBelow % 2 === 0);\n\t\t\treturn (diffEven === lowerBoundEven) ? 0 : 1;\n\t\t} else {\n\t\t\tlet upperBoundEven = (diagonalsAbove % 2 === 0);\n\t\t\treturn (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n\t\t}\n\t}\n\n}","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport strings = require('vs/base/common/strings');\nimport {LinkedMap} from 'vs/base/common/map';\n\nexport interface IFilter {\n\t// Returns null if word doesn't match.\n\t(word: string, wordToMatchAgainst: string): IMatch[];\n}\n\nexport interface IMatch {\n\tstart: number;\n\tend: number;\n}\n\n// Combined filters\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an or. The *first* filters that\n * matches defined the return value of the returned\n * filter.\n */\nexport function or(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] {\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tlet match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (match) {\n\t\t\t\treturn match;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t};\n}\n\n/**\n * @returns A filter which combines the provided set\n * of filters with an and. The combines matches are\n * returned if *all* filters match.\n */\nexport function and(...filter: IFilter[]): IFilter {\n\treturn function (word: string, wordToMatchAgainst: string): IMatch[] {\n\t\tlet result: IMatch[] = [];\n\t\tfor (let i = 0, len = filter.length; i < len; i++) {\n\t\t\tlet match = filter[i](word, wordToMatchAgainst);\n\t\t\tif (!match) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tresult = result.concat(match);\n\t\t}\n\t\treturn result;\n\t};\n}\n\n// Prefix\n\nexport let matchesStrictPrefix: IFilter = (word: string, wordToMatchAgainst: string): IMatch[] => { return _matchesPrefix(false, word, wordToMatchAgainst); };\nexport let matchesPrefix: IFilter = (word: string, wordToMatchAgainst: string): IMatch[] => { return _matchesPrefix(true, word, wordToMatchAgainst); };\n\nfunction _matchesPrefix(ignoreCase: boolean, word: string, wordToMatchAgainst: string): IMatch[] {\n\tif (!wordToMatchAgainst || wordToMatchAgainst.length === 0 || wordToMatchAgainst.length < word.length) {\n\t\treturn null;\n\t}\n\tif (ignoreCase) {\n\t\tword = word.toLowerCase();\n\t\twordToMatchAgainst = wordToMatchAgainst.toLowerCase();\n\t}\n\tfor (let i = 0; i < word.length; i++) {\n\t\tif (word[i] !== wordToMatchAgainst[i]) {\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\n\n// Contiguous Substring\n\nexport function matchesContiguousSubString(word: string, wordToMatchAgainst: string): IMatch[] {\n\tlet index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n\tif (index === -1) {\n\t\treturn null;\n\t}\n\n\treturn [{ start: index, end: index + word.length }];\n}\n\n// Substring\n\nexport function matchesSubString(word: string, wordToMatchAgainst: string): IMatch[] {\n\treturn _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\n\nfunction _matchesSubString(word: string, wordToMatchAgainst: string, i: number, j: number): IMatch[] {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === wordToMatchAgainst.length) {\n\t\treturn null;\n\t} else {\n\t\tif (word[i] === wordToMatchAgainst[j]) {\n\t\t\tlet result: IMatch[] = null;\n\t\t\tif (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n\t\t\t\treturn join({ start: j, end: j + 1 }, result);\n\t\t\t}\n\t\t}\n\n\t\treturn _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n\t}\n}\n\n// CamelCase\n\nfunction isLower(code: number): boolean {\n\treturn 97 <= code && code <= 122;\n}\n\nfunction isUpper(code: number): boolean {\n\treturn 65 <= code && code <= 90;\n}\n\nfunction isNumber(code: number): boolean {\n\treturn 48 <= code && code <= 57;\n}\n\nfunction isWhitespace(code: number): boolean {\n\treturn [32, 9, 10, 13].indexOf(code) > -1;\n}\n\nfunction isAlphanumeric(code: number): boolean {\n\treturn isLower(code) || isUpper(code) || isNumber(code);\n}\n\nfunction join(head: IMatch, tail: IMatch[]): IMatch[] {\n\tif (tail.length === 0) {\n\t\ttail = [head];\n\t} else if (head.end === tail[0].start) {\n\t\ttail[0].start = head.start;\n\t} else {\n\t\ttail.unshift(head);\n\t}\n\treturn tail;\n}\n\nfunction nextAnchor(camelCaseWord: string, start: number): number {\n\tfor (let i = start; i < camelCaseWord.length; i++) {\n\t\tlet c = camelCaseWord.charCodeAt(i);\n\t\tif (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn camelCaseWord.length;\n}\n\nfunction _matchesCamelCase(word: string, camelCaseWord: string, i: number, j: number): IMatch[] {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === camelCaseWord.length) {\n\t\treturn null;\n\t} else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result = null;\n\t\tlet nextUpperIndex = j + 1;\n\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n\t\twhile (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n\t\t\tresult = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n\t\t\tnextUpperIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camelCaseWords.\nfunction isCamelCaseWord(word: string): boolean {\n\tif (word.length > 60) {\n\t\treturn false;\n\t}\n\n\tlet upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isAlphanumeric(code)) { alpha++; }\n\t\tif (isNumber(code)) { numeric++; }\n\t}\n\n\tlet upperPercent = upper / word.length;\n\tlet lowerPercent = lower / word.length;\n\tlet alphaPercent = alpha / word.length;\n\tlet numericPercent = numeric / word.length;\n\n\treturn lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\n\n// Heuristic to avoid computing camel case matcher for words that don't\n// look like camel case patterns.\nfunction isCamelCasePattern(word: string): boolean {\n\tlet upper = 0, lower = 0, code = 0, whitespace = 0;\n\n\tfor (let i = 0; i < word.length; i++) {\n\t\tcode = word.charCodeAt(i);\n\n\t\tif (isUpper(code)) { upper++; }\n\t\tif (isLower(code)) { lower++; }\n\t\tif (isWhitespace(code)) { whitespace++; }\n\t}\n\n\tif ((upper === 0 || lower === 0) && whitespace === 0) {\n\t\treturn word.length <= 30;\n\t} else {\n\t\treturn upper <= 5;\n\t}\n}\n\nexport function matchesCamelCase(word: string, camelCaseWord: string): IMatch[] {\n\tif (!camelCaseWord || camelCaseWord.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCasePattern(word)) {\n\t\treturn null;\n\t}\n\n\tif (!isCamelCaseWord(camelCaseWord)) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] = null;\n\tlet i = 0;\n\n\twhile (i < camelCaseWord.length && (result = _matchesCamelCase(word.toLowerCase(), camelCaseWord, 0, i)) === null) {\n\t\ti = nextAnchor(camelCaseWord, i + 1);\n\t}\n\n\treturn result;\n}\n\n// Matches beginning of words supporting non-ASCII languages\n// E.g. \"gp\" or \"g p\" will match \"Git: Pull\"\n// Useful in cases where the target is words (e.g. command labels)\n\nexport function matchesWords(word: string, target: string): IMatch[] {\n\tif (!target || target.length === 0) {\n\t\treturn null;\n\t}\n\n\tlet result: IMatch[] = null;\n\tlet i = 0;\n\n\twhile (i < target.length && (result = _matchesWords(word.toLowerCase(), target, 0, i)) === null) {\n\t\ti = nextWord(target, i + 1);\n\t}\n\n\treturn result;\n}\n\nfunction _matchesWords(word: string, target: string, i: number, j: number): IMatch[] {\n\tif (i === word.length) {\n\t\treturn [];\n\t} else if (j === target.length) {\n\t\treturn null;\n\t} else if (word[i] !== target[j].toLowerCase()) {\n\t\treturn null;\n\t} else {\n\t\tlet result = null;\n\t\tlet nextWordIndex = j + 1;\n\t\tresult = _matchesWords(word, target, i + 1, j + 1);\n\t\twhile (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n\t\t\tresult = _matchesWords(word, target, i + 1, nextWordIndex);\n\t\t\tnextWordIndex++;\n\t\t}\n\t\treturn result === null ? null : join({ start: j, end: j + 1 }, result);\n\t}\n}\n\nfunction nextWord(word: string, start: number): number {\n\tfor (let i = start; i < word.length; i++) {\n\t\tlet c = word.charCodeAt(i);\n\t\tif (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {\n\t\t\treturn i;\n\t\t}\n\t}\n\treturn word.length;\n}\n\n// Fuzzy\n\nexport enum SubstringMatching {\n\tContiguous,\n\tSeparate\n}\n\nexport const fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LinkedMap<RegExp>(10000); // bounded to 10000 elements\n\nexport function matchesFuzzy(word: string, wordToMatchAgainst: string, enableSeparateSubstringMatching = false): IMatch[] {\n\tif (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n\t\treturn null; // return early for invalid input\n\t}\n\n\t// Form RegExp for wildcard matches\n\tlet regexp = fuzzyRegExpCache.get(word);\n\tif (!regexp) {\n\t\tregexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');\n\t\tfuzzyRegExpCache.set(word, regexp);\n\t}\n\n\t// RegExp Filter\n\tlet match: RegExpExecArray = regexp.exec(wordToMatchAgainst);\n\tif (match) {\n\t\treturn [{ start: match.index, end: match.index + match[0].length }];\n\t}\n\n\t// Default Filter\n\treturn enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport platform = require('vs/base/common/platform');\n\n\nfunction _encode(ch: string): string {\n\treturn '%' + ch.charCodeAt(0).toString(16).toUpperCase();\n}\n\n// see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent\nfunction encodeURIComponent2(str: string): string {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, _encode);\n}\n\nfunction encodeNoop(str: string): string {\n\treturn str;\n}\n\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component paths\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n *\n *\n */\nexport default class URI {\n\n\tprivate static _empty = '';\n\tprivate static _slash = '/';\n\tprivate static _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\tprivate static _driveLetterPath = /^\\/[a-zA-z]:/;\n\tprivate static _upperCaseDrive = /^(\\/)?([A-Z]:)/;\n\n\tprivate _scheme: string;\n\tprivate _authority: string;\n\tprivate _path: string;\n\tprivate _query: string;\n\tprivate _fragment: string;\n\tprivate _formatted: string;\n\tprivate _fsPath: string;\n\n\tconstructor() {\n\t\tthis._scheme = URI._empty;\n\t\tthis._authority = URI._empty;\n\t\tthis._path = URI._empty;\n\t\tthis._query = URI._empty;\n\t\tthis._fragment = URI._empty;\n\n\t\tthis._formatted = null;\n\t\tthis._fsPath = null;\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\tget scheme() {\n\t\treturn this._scheme;\n\t}\n\n\t/**\n\t * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\tget authority() {\n\t\treturn this._authority;\n\t}\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\tget path() {\n\t\treturn this._path;\n\t}\n\n\t/**\n\t * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\tget query() {\n\t\treturn this._query;\n\t}\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.\n\t */\n\tget fragment() {\n\t\treturn this._fragment;\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths and normalize windows drive letters to lower-case. Also\n\t * uses the platform specific path separator. Will *not* validate the path for\n\t * invalid characters and semantics. Will *not* look at the scheme of this URI.\n\t */\n\tget fsPath() {\n\t\tif (!this._fsPath) {\n\t\t\tvar value: string;\n\t\t\tif (this._authority && this.scheme === 'file') {\n\t\t\t\t// unc path: file://shares/c$/far/boo\n\t\t\t\tvalue = `//${this._authority}${this._path}`;\n\t\t\t} else if (URI._driveLetterPath.test(this._path)) {\n\t\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\t\tvalue = this._path[1].toLowerCase() + this._path.substr(2);\n\t\t\t} else {\n\t\t\t\t// other path\n\t\t\t\tvalue = this._path;\n\t\t\t}\n\t\t\tif (platform.isWindows) {\n\t\t\t\tvalue = value.replace(/\\//g, '\\\\');\n\t\t\t}\n\t\t\tthis._fsPath = value;\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\t// ---- modify to new -------------------------\n\n\tpublic with(change: { scheme?: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\tvar ret = new URI();\n\t\tret._scheme = change.scheme || this.scheme;\n\t\tret._authority = change.authority || this.authority;\n\t\tret._path = change.path || this.path;\n\t\tret._query = change.query || this.query;\n\t\tret._fragment = change.fragment || this.fragment;\n\t\tURI._validate(ret);\n\t\treturn ret;\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\tpublic static parse(value: string): URI {\n\t\tconst ret = new URI();\n\t\tconst data = URI._parseComponents(value);\n\t\tret._scheme = data.scheme;\n\t\tret._authority = decodeURIComponent(data.authority);\n\t\tret._path = decodeURIComponent(data.path);\n\t\tret._query = decodeURIComponent(data.query);\n\t\tret._fragment = decodeURIComponent(data.fragment);\n\t\tURI._validate(ret);\n\t\treturn ret;\n\t}\n\n\tpublic static file(path: string): URI {\n\n\t\tconst ret = new URI();\n\t\tret._scheme = 'file';\n\n\t\t// normalize to fwd-slashes\n\t\tpath = path.replace(/\\\\/g, URI._slash);\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === URI._slash && path[0] === path[1]) {\n\t\t\tlet idx = path.indexOf(URI._slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tret._authority = path.substring(2);\n\t\t\t} else {\n\t\t\t\tret._authority = path.substring(2, idx);\n\t\t\t\tret._path = path.substring(idx);\n\t\t\t}\n\t\t} else {\n\t\t\tret._path = path;\n\t\t}\n\n\t\t// Ensure that path starts with a slash\n\t\t// or that it is at least a slash\n\t\tif (ret._path[0] !== URI._slash) {\n\t\t\tret._path = URI._slash + ret._path;\n\t\t}\n\n\t\tURI._validate(ret);\n\n\t\treturn ret;\n\t}\n\n\tprivate static _parseComponents(value: string): UriComponents {\n\n\t\tconst ret: UriComponents = {\n\t\t\tscheme: URI._empty,\n\t\t\tauthority: URI._empty,\n\t\t\tpath: URI._empty,\n\t\t\tquery: URI._empty,\n\t\t\tfragment: URI._empty,\n\t\t};\n\n\t\tconst match = URI._regexp.exec(value);\n\t\tif (match) {\n\t\t\tret.scheme = match[2] || ret.scheme;\n\t\t\tret.authority = match[4] || ret.authority;\n\t\t\tret.path = match[5] || ret.path;\n\t\t\tret.query = match[7] || ret.query;\n\t\t\tret.fragment = match[9] || ret.fragment;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static create(scheme?: string, authority?: string, path?: string, query?: string, fragment?: string): URI {\n\t\treturn new URI().with({ scheme, authority, path, query, fragment });\n\t}\n\n\tprivate static _validate(ret: URI): void {\n\n\t\t// validation\n\t\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t\t// If a URI contains an authority component, then the path component\n\t\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t\t// does not contain an authority component, then the path cannot begin\n\t\t// with two slash characters (\"//\").\n\t\tif (ret.authority && ret.path && ret.path[0] !== '/') {\n\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t}\n\t\tif (!ret.authority && ret.path.indexOf('//') === 0) {\n\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t}\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\tpublic toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = URI._asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn URI._asFormatted(this, true);\n\t\t}\n\t}\n\n\tprivate static _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\t\tconst encoder = !skipEncoding\n\t\t\t? encodeURIComponent2\n\t\t\t: encodeNoop;\n\n\t\tconst parts: string[] = [];\n\n\t\tlet {scheme, authority, path, query, fragment} = uri;\n\t\tif (scheme) {\n\t\t\tparts.push(scheme, ':');\n\t\t}\n\t\tif (authority || scheme === 'file') {\n\t\t\tparts.push('//');\n\t\t}\n\t\tif (authority) {\n\t\t\tauthority = authority.toLowerCase();\n\t\t\tlet idx = authority.indexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tparts.push(encoder(authority));\n\t\t\t} else {\n\t\t\t\tparts.push(encoder(authority.substr(0, idx)), authority.substr(idx));\n\t\t\t}\n\t\t}\n\t\tif (path) {\n\t\t\t// lower-case windown drive letters in /C:/fff\n\t\t\tconst m = URI._upperCaseDrive.exec(path);\n\t\t\tif (m) {\n\t\t\t\tpath = m[1] + m[2].toLowerCase() + path.substr(m[1].length + m[2].length);\n\t\t\t}\n\n\t\t\t// encode every segement but not slashes\n\t\t\t// make sure that # and ? are always encoded\n\t\t\t// when occurring in paths - otherwise the result\n\t\t\t// cannot be parsed back again\n\t\t\tlet lastIdx = 0;\n\t\t\twhile(true) {\n\t\t\t\tlet idx = path.indexOf(URI._slash, lastIdx);\n\t\t\t\tif (idx === -1) {\n\t\t\t\t\tparts.push(encoder(path.substring(lastIdx)).replace(/[#?]/, _encode));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tparts.push(encoder(path.substring(lastIdx, idx)).replace(/[#?]/, _encode), URI._slash);\n\t\t\t\tlastIdx = idx + 1;\n\t\t\t};\n\t\t}\n\t\tif (query) {\n\t\t\tparts.push('?', encoder(query));\n\t\t}\n\t\tif (fragment) {\n\t\t\tparts.push('#', encoder(fragment));\n\t\t}\n\n\t\treturn parts.join(URI._empty);\n\t}\n\n\tpublic toJSON(): any {\n\t\treturn <UriState> {\n\t\t\tscheme: this.scheme,\n\t\t\tauthority: this.authority,\n\t\t\tpath: this.path,\n\t\t\tfsPath: this.fsPath,\n\t\t\tquery: this.query,\n\t\t\tfragment: this.fragment.replace(/URL_MARSHAL_REMOVE.*$/, ''), // TODO@Alex: implement derived resources (embedded mirror models) better\n\t\t\texternal: this.toString().replace(/#?URL_MARSHAL_REMOVE.*$/, ''), // TODO@Alex: implement derived resources (embedded mirror models) better\n\t\t\t$mid: 1\n\t\t};\n\t}\n\n\tstatic revive(data: any): URI {\n\t\tlet result = new URI();\n\t\tresult._scheme = (<UriState> data).scheme;\n\t\tresult._authority = (<UriState> data).authority;\n\t\tresult._path = (<UriState> data).path;\n\t\tresult._query = (<UriState> data).query;\n\t\tresult._fragment = (<UriState> data).fragment;\n\t\tresult._fsPath = (<UriState> data).fsPath;\n\t\tresult._formatted = (<UriState>data).external;\n\t\tURI._validate(result);\n\t\treturn result;\n\t}\n}\n\ninterface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\tfsPath: string;\n\texternal: string;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport namespace Arrays {\n\n\t/**\n\t * Given a sorted array of natural number segments, find the segment containing a natural number.\n\t *    For example, the segments [0, 5), [5, 9), [9, infinity) will be represented in the following manner:\n\t *       [{ startIndex: 0 }, { startIndex: 5 }, { startIndex: 9 }]\n\t *    Searching for 0, 1, 2, 3 or 4 will return 0.\n\t *    Searching for 5, 6, 7 or 8 will return 1.\n\t *    Searching for 9, 10, 11, ... will return 2.\n\t * @param arr A sorted array representing natural number segments\n\t * @param desiredIndex The search\n\t * @return The index of the containing segment in the array.\n\t */\n\texport function findIndexInSegmentsArray(arr: { startIndex: number; }[], desiredIndex: number): number {\n\n\t\tlet low = 0;\n\t\tlet high = arr.length - 1;\n\n\t\tif (high <= 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\twhile (low < high) {\n\n\t\t\tlet mid = low + Math.ceil((high - low) / 2);\n\n\t\t\tif (arr[mid].startIndex > desiredIndex) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlow = mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IMode, IModeTransition} from 'vs/editor/common/modes';\nimport {Arrays} from 'vs/editor/common/core/arrays';\n\nexport class ModeTransition {\n\t_modeTransitionBrand: void;\n\n\tpublic startIndex:number;\n\tpublic mode:IMode;\n\n\tconstructor(startIndex:number, mode:IMode) {\n\t\tthis.startIndex = startIndex|0;\n\t\tthis.mode = mode;\n\t}\n\n\tpublic static findIndexInSegmentsArray(arr:ModeTransition[], desiredIndex: number): number {\n\t\treturn Arrays.findIndexInSegmentsArray(arr, desiredIndex);\n\t}\n\n\tpublic static create(modeTransitions:IModeTransition[]): ModeTransition[] {\n\t\tlet result:ModeTransition[] = [];\n\t\tfor (let i = 0, len = modeTransitions.length; i < len; i++) {\n\t\t\tlet modeTransition = modeTransitions[i];\n\t\t\tresult.push(new ModeTransition(modeTransition.startIndex, modeTransition.mode));\n\t\t}\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IPosition, IRange} from 'vs/editor/common/editorCommon';\n\n/**\n * A position in the editor.\n */\nexport class Position {\n\n\tpublic lineNumber: number;\n\tpublic column: number;\n\n\tconstructor(lineNumber: number, column: number) {\n\t\tthis.lineNumber = lineNumber;\n\t\tthis.column = column;\n\t}\n\n\t/**\n\t * Test if this position equals other position\n\t */\n\tpublic equals(other:IPosition): boolean {\n\t\treturn Position.equals(this, other);\n\t}\n\tpublic static equals(a:IPosition, b:IPosition): boolean {\n\t\tif (!a && !b) {\n\t\t\treturn true;\n\t\t}\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.lineNumber === b.lineNumber &&\n\t\t\ta.column === b.column\n\t\t);\n\t}\n\n\t/**\n\t * Test if this position is before other position. If the two positions are equal, the result will be false.\n\t */\n\tpublic isBefore(other:IPosition): boolean {\n\t\treturn Position.isBefore(this, other);\n\t}\n\tpublic static isBefore(a:IPosition, b:IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column < b.column;\n\t}\n\n\t/**\n\t * Test if this position is before other position. If the two positions are equal, the result will be true.\n\t */\n\tpublic isBeforeOrEqual(other:IPosition): boolean {\n\t\treturn Position.isBeforeOrEqual(this, other);\n\t}\n\tpublic static isBeforeOrEqual(a:IPosition, b:IPosition): boolean {\n\t\tif (a.lineNumber < b.lineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (b.lineNumber < a.lineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\treturn a.column <= b.column;\n\t}\n\n\t/**\n\t * Clone this position.\n\t */\n\tpublic clone(): Position {\n\t\treturn new Position(this.lineNumber, this.column);\n\t}\n\n\tpublic toString(): string {\n\t\treturn '(' + this.lineNumber + ',' + this.column + ')';\n\t}\n\n\t// ---\n\n\tpublic static lift(pos:IPosition): Position {\n\t\treturn new Position(pos.lineNumber, pos.column);\n\t}\n\n\tpublic static isIPosition(obj: any): obj is IPosition {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.lineNumber === 'number')\n\t\t\t&& (typeof obj.column === 'number')\n\t\t);\n\t}\n\n\tpublic static asEmptyRange(position:IPosition):IRange {\n\t\treturn {\n\t\t\tstartLineNumber: position.lineNumber,\n\t\t\tstartColumn: position.column,\n\t\t\tendLineNumber: position.lineNumber,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\tpublic static startPosition(range:IRange):IPosition {\n\t\treturn {\n\t\t\tlineNumber: range.startLineNumber,\n\t\t\tcolumn: range.startColumn\n\t\t};\n\t}\n\n\tpublic static endPosition(range:IRange):IPosition {\n\t\treturn {\n\t\t\tlineNumber: range.endLineNumber,\n\t\t\tcolumn: range.endColumn\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport {Position} from 'vs/editor/common/core/position';\nimport {IPosition, IRange} from 'vs/editor/common/editorCommon';\n\n/**\n * A range in the editor.\n */\nexport class Range {\n\n\tpublic startLineNumber:number;\n\tpublic startColumn:number;\n\tpublic endLineNumber:number;\n\tpublic endColumn:number;\n\n\tconstructor(startLineNumber:number, startColumn:number, endLineNumber:number, endColumn:number) {\n\t\tif ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n\t\t\tthis.startLineNumber = endLineNumber;\n\t\t\tthis.startColumn = endColumn;\n\t\t\tthis.endLineNumber = startLineNumber;\n\t\t\tthis.endColumn = startColumn;\n\t\t} else {\n\t\t\tthis.startLineNumber = startLineNumber;\n\t\t\tthis.startColumn = startColumn;\n\t\t\tthis.endLineNumber = endLineNumber;\n\t\t\tthis.endColumn = endColumn;\n\t\t}\n\t}\n\n\t/**\n\t * Test if this range is empty.\n\t */\n\tpublic isEmpty(): boolean {\n\t\treturn Range.isEmpty(this);\n\t}\n\n\t/**\n\t * Test if position is in this range. If the position is at the edges, will return true.\n\t */\n\tpublic containsPosition(position:IPosition): boolean {\n\t\treturn Range.containsPosition(this, position);\n\t}\n\n\t/**\n\t * Test if range is in this range. If the range is equal to this range, will return true.\n\t */\n\tpublic containsRange(range:IRange): boolean {\n\t\treturn Range.containsRange(this, range);\n\t}\n\n\t/**\n\t * A reunion of the two ranges. The smallest position will be used as the start point, and the largest one as the end point.\n\t */\n\tpublic plusRange(range:IRange): Range {\n\t\treturn Range.plusRange(this, range);\n\t}\n\n\t/**\n\t * A intersection of the two ranges.\n\t */\n\tpublic intersectRanges(range:IRange): Range {\n\t\treturn Range.intersectRanges(this, range);\n\t}\n\n\t/**\n\t * Test if this range equals other.\n\t */\n\tpublic equalsRange(other:IRange): boolean {\n\t\treturn Range.equalsRange(this, other);\n\t}\n\n\t/**\n\t * Return the end position (which will be after or equal to the start position)\n\t */\n\tpublic getEndPosition(): Position {\n\t\treturn new Position(this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Return the start position (which will be before or equal to the end position)\n\t */\n\tpublic getStartPosition(): Position {\n\t\treturn new Position(this.startLineNumber, this.startColumn);\n\t}\n\n\t/**\n\t * Clone this range.\n\t */\n\tpublic cloneRange(): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\t/**\n\t * Transform to a user presentable string representation.\n\t */\n\tpublic toString(): string {\n\t\treturn '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n\t}\n\n\t/**\n\t * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n\t */\n\tpublic setEndPosition(endLineNumber: number, endColumn: number): Range {\n\t\treturn new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n\t}\n\n\t/**\n\t * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n\t */\n\tpublic setStartPosition(startLineNumber: number, startColumn: number): Range {\n\t\treturn new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n\t}\n\n\tpublic collapseToStart():Range  {\n\t\treturn new Range(this.startLineNumber, this.startColumn, this.startLineNumber, this.startColumn);\n\t}\n\n\t// ---\n\n\tpublic static lift(range:IRange): Range {\n\t\tif (!range) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n\t}\n\n\tpublic static isIRange(obj: any): obj is IRange {\n\t\treturn (\n\t\t\tobj\n\t\t\t&& (typeof obj.startLineNumber === 'number')\n\t\t\t&& (typeof obj.startColumn === 'number')\n\t\t\t&& (typeof obj.endLineNumber === 'number')\n\t\t\t&& (typeof obj.endColumn === 'number')\n\t\t);\n\t}\n\n\tpublic static isEmpty(range:IRange): boolean {\n\t\treturn (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n\t}\n\n\tpublic static containsPosition(range:IRange, position:IPosition): boolean {\n\t\tif (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static containsRange(range:IRange, otherRange:IRange): boolean {\n\t\tif (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n\t\t\treturn false;\n\t\t}\n\t\tif (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static areIntersectingOrTouching(a:IRange, b:IRange): boolean {\n\t\t// Check if `a` is before `b`\n\t\tif (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check if `b` is before `a`\n\t\tif (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// These ranges must intersect\n\t\treturn true;\n\t}\n\n\tpublic static intersectRanges(a:IRange, b:IRange): Range {\n\t\tvar resultStartLineNumber = a.startLineNumber,\n\t\t\tresultStartColumn = a.startColumn,\n\t\t\tresultEndLineNumber = a.endLineNumber,\n\t\t\tresultEndColumn = a.endColumn,\n\t\t\totherStartLineNumber = b.startLineNumber,\n\t\t\totherStartColumn = b.startColumn,\n\t\t\totherEndLineNumber = b.endLineNumber,\n\t\t\totherEndColumn = b.endColumn;\n\n\t\tif (resultStartLineNumber < otherStartLineNumber) {\n\t\t\tresultStartLineNumber = otherStartLineNumber;\n\t\t\tresultStartColumn = otherStartColumn;\n\t\t} else if (resultStartLineNumber === otherStartLineNumber) {\n\t\t\tresultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n\t\t}\n\n\t\tif (resultEndLineNumber > otherEndLineNumber) {\n\t\t\tresultEndLineNumber = otherEndLineNumber;\n\t\t\tresultEndColumn = otherEndColumn;\n\t\t} else if (resultEndLineNumber === otherEndLineNumber) {\n\t\t\tresultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n\t\t}\n\n\t\t// Check if selection is now empty\n\t\tif (resultStartLineNumber > resultEndLineNumber) {\n\t\t\treturn null;\n\t\t}\n\t\tif (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n\t\t\treturn null;\n\t\t}\n\t\treturn new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n\t}\n\n\tpublic static plusRange(a:IRange, b:IRange): Range {\n\t\tvar startLineNumber:number, startColumn:number, endLineNumber:number, endColumn:number;\n\t\tif (b.startLineNumber < a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = b.startColumn;\n\t\t} else if (b.startLineNumber === a.startLineNumber) {\n\t\t\tstartLineNumber = b.startLineNumber;\n\t\t\tstartColumn = Math.min(b.startColumn, a.startColumn);\n\t\t} else {\n\t\t\tstartLineNumber = a.startLineNumber;\n\t\t\tstartColumn = a.startColumn;\n\t\t}\n\n\t\tif (b.endLineNumber > a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = b.endColumn;\n\t\t} else if (b.endLineNumber === a.endLineNumber) {\n\t\t\tendLineNumber = b.endLineNumber;\n\t\t\tendColumn = Math.max(b.endColumn, a.endColumn);\n\t\t} else {\n\t\t\tendLineNumber = a.endLineNumber;\n\t\t\tendColumn = a.endColumn;\n\t\t}\n\n\t\treturn new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n\t}\n\n\tpublic static equalsRange(a:IRange, b:IRange): boolean {\n\t\treturn (\n\t\t\t!!a &&\n\t\t\t!!b &&\n\t\t\ta.startLineNumber === b.startLineNumber &&\n\t\t\ta.startColumn === b.startColumn &&\n\t\t\ta.endLineNumber === b.endLineNumber &&\n\t\t\ta.endColumn === b.endColumn\n\t\t);\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the startPosition and then on the endPosition\n\t */\n\tpublic static compareRangesUsingStarts(a:IRange, b:IRange): number {\n\t\tlet aStartLineNumber = a.startLineNumber|0;\n\t\tlet bStartLineNumber = b.startLineNumber|0;\n\t\tlet aStartColumn = a.startColumn|0;\n\t\tlet bStartColumn = b.startColumn|0;\n\t\tlet aEndLineNumber = a.endLineNumber|0;\n\t\tlet bEndLineNumber = b.endLineNumber|0;\n\t\tlet aEndColumn = a.endColumn|0;\n\t\tlet bEndColumn = b.endColumn|0;\n\n\t\tif (aStartLineNumber === bStartLineNumber) {\n\t\t\tif (aStartColumn === bStartColumn) {\n\t\t\t\tif (aEndLineNumber === bEndLineNumber) {\n\t\t\t\t\treturn aEndColumn - bEndColumn;\n\t\t\t\t}\n\t\t\t\treturn aEndLineNumber - bEndLineNumber;\n\t\t\t}\n\t\t\treturn aStartColumn - bStartColumn;\n\t\t}\n\t\treturn aStartLineNumber - bStartLineNumber;\n\t}\n\n\t/**\n\t * A function that compares ranges, useful for sorting ranges\n\t * It will first compare ranges on the endPosition and then on the startPosition\n\t */\n\tpublic static compareRangesUsingEnds(a:IRange, b:IRange): number {\n\t\tif (a.endLineNumber === b.endLineNumber) {\n\t\t\tif (a.endColumn === b.endColumn) {\n\t\t\t\tif (a.startLineNumber === b.startLineNumber) {\n\t\t\t\t\treturn a.startColumn - b.startColumn;\n\t\t\t\t}\n\t\t\t\treturn a.startLineNumber - b.startLineNumber;\n\t\t\t}\n\t\t\treturn a.endColumn - b.endColumn;\n\t\t}\n\t\treturn a.endLineNumber - b.endLineNumber;\n\t}\n\n\tpublic static spansMultipleLines(range:IRange):boolean {\n\t\treturn range.endLineNumber > range.startLineNumber;\n\t}\n\n\tpublic static collapseToStart(range:IRange):IRange  {\n\t\treturn {\n\t\t\tstartLineNumber: range.startLineNumber,\n\t\t\tstartColumn: range.startColumn,\n\t\t\tendLineNumber: range.startLineNumber,\n\t\t\tendColumn: range.startColumn\n\t\t};\n\t}\n\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IDiffChange, ISequence, LcsDiff} from 'vs/base/common/diff/diff';\nimport * as strings from 'vs/base/common/strings';\nimport {ICharChange, ILineChange} from 'vs/editor/common/editorCommon';\n\nvar MAXIMUM_RUN_TIME = 5000; // 5 seconds\nvar MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\n\ninterface IMarker {\n\tlineNumber: number;\n\tcolumn: number;\n\toffset: number;\n}\n\nfunction computeDiff(originalSequence:ISequence, modifiedSequence:ISequence, continueProcessingPredicate:()=>boolean): IDiffChange[] {\n\tvar diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n\treturn diffAlgo.ComputeDiff();\n}\n\nclass MarkerSequence implements ISequence {\n\n\tpublic buffer:string;\n\tpublic startMarkers:IMarker[];\n\tpublic endMarkers:IMarker[];\n\n\tconstructor(buffer:string, startMarkers:IMarker[], endMarkers:IMarker[]) {\n\t\tthis.buffer = buffer;\n\t\tthis.startMarkers = startMarkers;\n\t\tthis.endMarkers = endMarkers;\n\t}\n\n\tpublic equals(other:any): boolean {\n\t\tif (!(other instanceof MarkerSequence)) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherMarkerSequence = <MarkerSequence>other;\n\t\tif (this.getLength() !== otherMarkerSequence.getLength()) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (var i = 0, len = this.getLength(); i < len; i++) {\n\t\t\tvar myElement = this.getElementHash(i);\n\t\t\tvar otherElement = otherMarkerSequence.getElementHash(i);\n\t\t\tif (myElement !== otherElement) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getLength(): number {\n\t\treturn this.startMarkers.length;\n\t}\n\n\tpublic getElementHash(i:number): string {\n\t\treturn this.buffer.substring(this.startMarkers[i].offset, this.endMarkers[i].offset);\n\t}\n\n\tpublic getStartLineNumber(i:number): number {\n\t\tif (i === this.startMarkers.length) {\n\t\t\t// This is the special case where a change happened after the last marker\n\t\t\treturn this.startMarkers[i - 1].lineNumber + 1;\n\t\t}\n\t\treturn this.startMarkers[i].lineNumber;\n\t}\n\n\tpublic getStartColumn(i:number): number {\n\t\treturn this.startMarkers[i].column;\n\t}\n\n\tpublic getEndLineNumber(i:number): number {\n\t\treturn this.endMarkers[i].lineNumber;\n\t}\n\n\tpublic getEndColumn(i:number): number {\n\t\treturn this.endMarkers[i].column;\n\t}\n\n}\n\nclass LineMarkerSequence extends MarkerSequence {\n\n\tconstructor(lines:string[], shouldIgnoreTrimWhitespace:boolean) {\n\t\tvar i:number, length:number, pos:number;\n\t\tvar buffer = '';\n\t\tvar startMarkers:IMarker[] = [], endMarkers:IMarker[] = [], startColumn:number, endColumn:number;\n\n\t\tfor (pos = 0, i = 0, length = lines.length; i < length; i++) {\n\t\t\tbuffer += lines[i];\n\t\t\tstartColumn = 1;\n\t\t\tendColumn = lines[i].length + 1;\n\n\t\t\tif (shouldIgnoreTrimWhitespace) {\n\t\t\t\tstartColumn = LineMarkerSequence._getFirstNonBlankColumn(lines[i], 1);\n\t\t\t\tendColumn = LineMarkerSequence._getLastNonBlankColumn(lines[i], 1);\n\t\t\t}\n\n\t\t\tstartMarkers.push({\n\t\t\t\toffset: pos + startColumn - 1,\n\t\t\t\tlineNumber: i + 1,\n\t\t\t\tcolumn: startColumn\n\t\t\t});\n\n\t\t\tendMarkers.push({\n\t\t\t\toffset: pos + endColumn - 1,\n\t\t\t\tlineNumber: i+1,\n\t\t\t\tcolumn: endColumn\n\t\t\t});\n\n\t\t\tpos += lines[i].length;\n\t\t}\n\n\t\tsuper(buffer, startMarkers, endMarkers);\n\t}\n\n\tprivate static _getFirstNonBlankColumn(txt:string, defaultValue:number): number {\n\t\tvar r = strings.firstNonWhitespaceIndex(txt);\n\t\tif (r === -1) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn r + 1;\n\t}\n\n\tprivate static _getLastNonBlankColumn(txt:string, defaultValue:number): number {\n\t\tvar r = strings.lastNonWhitespaceIndex(txt);\n\t\tif (r === -1) {\n\t\t\treturn defaultValue;\n\t\t}\n\t\treturn r + 2;\n\t}\n\n\tpublic getCharSequence(startIndex:number, endIndex:number):MarkerSequence {\n\t\tvar startMarkers:IMarker[] = [], endMarkers:IMarker[] = [], index:number, i:number, startMarker:IMarker, endMarker:IMarker;\n\t\tfor (index = startIndex; index <= endIndex; index++) {\n\t\t\tstartMarker = this.startMarkers[index];\n\t\t\tendMarker = this.endMarkers[index];\n\t\t\tfor (i = startMarker.offset; i < endMarker.offset; i++) {\n\t\t\t\tstartMarkers.push({\n\t\t\t\t\toffset: i,\n\t\t\t\t\tlineNumber: startMarker.lineNumber,\n\t\t\t\t\tcolumn: startMarker.column + (i - startMarker.offset)\n\t\t\t\t});\n\t\t\t\tendMarkers.push({\n\t\t\t\t\toffset: i + 1,\n\t\t\t\t\tlineNumber: startMarker.lineNumber,\n\t\t\t\t\tcolumn: startMarker.column + (i - startMarker.offset) + 1\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\treturn new MarkerSequence(this.buffer, startMarkers, endMarkers);\n\t}\n}\n\nclass CharChange implements ICharChange {\n\n\tpublic originalStartLineNumber:number;\n\tpublic originalStartColumn:number;\n\tpublic originalEndLineNumber:number;\n\tpublic originalEndColumn:number;\n\n\tpublic modifiedStartLineNumber:number;\n\tpublic modifiedStartColumn:number;\n\tpublic modifiedEndLineNumber:number;\n\tpublic modifiedEndColumn:number;\n\n\tconstructor(diffChange:IDiffChange, originalCharSequence:MarkerSequence, modifiedCharSequence:MarkerSequence) {\n\t\tif (diffChange.originalLength === 0) {\n\t\t\tthis.originalStartLineNumber = 0;\n\t\t\tthis.originalStartColumn = 0;\n\t\t\tthis.originalEndLineNumber = 0;\n\t\t\tthis.originalEndColumn = 0;\n\t\t} else {\n\t\t\tthis.originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\tthis.originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n\t\t\tthis.originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tthis.originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tthis.modifiedStartLineNumber = 0;\n\t\t\tthis.modifiedStartColumn = 0;\n\t\t\tthis.modifiedEndLineNumber = 0;\n\t\t\tthis.modifiedEndColumn = 0;\n\t\t} else {\n\t\t\tthis.modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tthis.modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n\t\t\tthis.modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t\tthis.modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\t}\n\n}\n\nfunction postProcessCharChanges(rawChanges:IDiffChange[]): IDiffChange[] {\n\tif (rawChanges.length <= 1) {\n\t\treturn rawChanges;\n\t}\n\tvar result = [ rawChanges[0] ];\n\n\tvar i:number, len:number, originalMatchingLength:number, modifiedMatchingLength:number, matchingLength:number, prevChange = result[0], currChange:IDiffChange;\n\tfor (i = 1, len = rawChanges.length; i < len; i++) {\n\t\tcurrChange = rawChanges[i];\n\n\t\toriginalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n\t\tmodifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n\t\t// Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n\t\tmatchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n\n\t\tif (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n\t\t\t// Merge the current change into the previous one\n\t\t\tprevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n\t\t\tprevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n\t\t} else {\n\t\t\t// Add the current change\n\t\t\tresult.push(currChange);\n\t\t\tprevChange = currChange;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nclass LineChange implements ILineChange {\n\tpublic originalStartLineNumber:number;\n\tpublic originalEndLineNumber:number;\n\tpublic modifiedStartLineNumber:number;\n\tpublic modifiedEndLineNumber:number;\n\tpublic charChanges:CharChange[];\n\n\tconstructor(diffChange:IDiffChange, originalLineSequence:LineMarkerSequence, modifiedLineSequence:LineMarkerSequence, continueProcessingPredicate:()=>boolean, shouldPostProcessCharChanges:boolean) {\n\t\tif (diffChange.originalLength === 0) {\n\t\t\tthis.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n\t\t\tthis.originalEndLineNumber = 0;\n\t\t} else {\n\t\t\tthis.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n\t\t\tthis.originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n\t\t}\n\n\t\tif (diffChange.modifiedLength === 0) {\n\t\t\tthis.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n\t\t\tthis.modifiedEndLineNumber = 0;\n\t\t} else {\n\t\t\tthis.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n\t\t\tthis.modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\t\t}\n\n\t\tif (diffChange.originalLength !== 0 && diffChange.modifiedLength !== 0 && continueProcessingPredicate()) {\n\t\t\tvar originalCharSequence = originalLineSequence.getCharSequence(diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n\t\t\tvar modifiedCharSequence = modifiedLineSequence.getCharSequence(diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n\n\t\t\tvar rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueProcessingPredicate);\n\n\t\t\tif (shouldPostProcessCharChanges) {\n\t\t\t\trawChanges = postProcessCharChanges(rawChanges);\n\t\t\t}\n\n\t\t\tthis.charChanges = [];\n\t\t\tfor (var i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\t\tthis.charChanges.push(new CharChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nexport interface IDiffComputerOpts {\n\tshouldPostProcessCharChanges: boolean;\n\tshouldIgnoreTrimWhitespace: boolean;\n\tshouldConsiderTrimWhitespaceInEmptyCase: boolean;\n}\n\nexport class DiffComputer {\n\n\tprivate shouldPostProcessCharChanges:boolean;\n\tprivate shouldIgnoreTrimWhitespace:boolean;\n\tprivate maximumRunTimeMs:number;\n\tprivate original:LineMarkerSequence;\n\tprivate modified:LineMarkerSequence;\n\n\tprivate computationStartTime:number;\n\n\tconstructor(originalLines:string[], modifiedLines:string[], opts:IDiffComputerOpts) {\n\t\tthis.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n\t\tthis.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n\t\tthis.maximumRunTimeMs = MAXIMUM_RUN_TIME;\n\t\tthis.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);\n\t\tthis.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);\n\t\tif (opts.shouldConsiderTrimWhitespaceInEmptyCase && this.shouldIgnoreTrimWhitespace && this.original.equals(this.modified)) {\n\t\t\t// Diff would be empty with `shouldIgnoreTrimWhitespace`\n\t\t\tthis.shouldIgnoreTrimWhitespace = false;\n\t\t\tthis.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);\n\t\t\tthis.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);\n\t\t}\n\t}\n\n\tpublic computeDiff():ILineChange[] {\n\t\tthis.computationStartTime = (new Date()).getTime();\n\n\t\tvar rawChanges = computeDiff(this.original, this.modified, this._continueProcessingPredicate.bind(this));\n\n\t\tvar lineChanges: ILineChange[] = [];\n\t\tfor (var i = 0, length = rawChanges.length; i < length; i++) {\n\t\t\tlineChanges.push(new LineChange(rawChanges[i], this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldPostProcessCharChanges));\n\t\t}\n\t\treturn lineChanges;\n\t}\n\n\tprivate _continueProcessingPredicate(): boolean {\n\t\tif (this.maximumRunTimeMs === 0) {\n\t\t\treturn true;\n\t\t}\n\t\tvar now = (new Date()).getTime();\n\t\treturn now - this.computationStartTime < this.maximumRunTimeMs;\n\t}\n\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {ILink} from 'vs/editor/common/modes';\n\nexport interface ILinkComputerTarget {\n\tgetLineCount(): number;\n\tgetLineContent(lineNumber:number): string;\n}\n\n// State machine for http:// or https://\nvar STATE_MAP:{[ch:string]:number}[] = [], START_STATE = 1, END_STATE = 9, ACCEPT_STATE = 10;\nSTATE_MAP[1] = { 'h': 2, 'H': 2, 'f': 11, 'F': 11 };\nSTATE_MAP[2] = { 't': 3, 'T': 3 };\nSTATE_MAP[3] = { 't': 4, 'T': 4 };\nSTATE_MAP[4] = { 'p': 5, 'P': 5 };\nSTATE_MAP[5] = { 's': 6, 'S': 6, ':': 7 };\nSTATE_MAP[6] = { ':': 7 };\nSTATE_MAP[7] = { '/': 8 };\nSTATE_MAP[8] = { '/': 9 };\nSTATE_MAP[11] = { 'i': 12, 'I': 12 };\nSTATE_MAP[12] = { 'l': 13, 'L': 13 };\nSTATE_MAP[13] = { 'e': 6, 'E': 6 };\n\nenum CharacterClass {\n\tNone = 0,\n\tForceTermination = 1,\n\tCannotEndIn = 2\n}\n\nlet _openParens = '('.charCodeAt(0);\nlet _closeParens = ')'.charCodeAt(0);\nlet _openSquareBracket = '['.charCodeAt(0);\nlet _closeSquareBracket = ']'.charCodeAt(0);\nlet _openCurlyBracket = '{'.charCodeAt(0);\nlet _closeCurlyBracket = '}'.charCodeAt(0);\n\nclass CharacterClassifier {\n\n\t/**\n\t * Maintain a compact (fully initialized ASCII map for quickly classifying ASCII characters - used more often in code).\n\t */\n\tprivate _asciiMap: CharacterClass[];\n\n\t/**\n\t * The entire map (sparse array).\n\t */\n\tprivate _map: CharacterClass[];\n\n\tconstructor() {\n\t\tvar FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\n\t\tvar CANNOT_END_WITH_CHARACTERS = '.,;';\n\n\t\tthis._asciiMap = [];\n\t\tfor (let i = 0; i < 256; i++) {\n\t\t\tthis._asciiMap[i] = CharacterClass.None;\n\t\t}\n\n\t\tthis._map = [];\n\n\t\tfor (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n\t\t\tthis._set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), CharacterClass.ForceTermination);\n\t\t}\n\n\t\tfor (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n\t\t\tthis._set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), CharacterClass.CannotEndIn);\n\t\t}\n\t}\n\n\tprivate _set(charCode:number, charClass:CharacterClass): void {\n\t\tif (charCode < 256) {\n\t\t\tthis._asciiMap[charCode] = charClass;\n\t\t}\n\t\tthis._map[charCode] = charClass;\n\t}\n\n\tpublic classify(charCode:number): CharacterClass {\n\t\tif (charCode < 256) {\n\t\t\treturn this._asciiMap[charCode];\n\t\t}\n\n\t\tlet charClass = this._map[charCode];\n\t\tif (charClass) {\n\t\t\treturn charClass;\n\t\t}\n\n\t\treturn CharacterClass.None;\n\t}\n}\n\nclass LinkComputer {\n\n\tprivate static _characterClassifier = new CharacterClassifier();\n\n\tprivate static _createLink(line:string, lineNumber:number, linkBeginIndex:number, linkEndIndex:number):ILink {\n\t\treturn {\n\t\t\trange: {\n\t\t\t\tstartLineNumber: lineNumber,\n\t\t\t\tstartColumn: linkBeginIndex + 1,\n\t\t\t\tendLineNumber: lineNumber,\n\t\t\t\tendColumn: linkEndIndex + 1\n\t\t\t},\n\t\t\turl: line.substring(linkBeginIndex, linkEndIndex)\n\t\t};\n\t}\n\n\tpublic static computeLinks(model:ILinkComputerTarget):ILink[] {\n\n\t\tvar i:number,\n\t\t\tlineCount:number,\n\t\t\tresult:ILink[] = [];\n\n\t\tvar line:string,\n\t\t\tj:number,\n\t\t\tlastIncludedCharIndex:number,\n\t\t\tlen:number,\n\t\t\tlinkBeginIndex:number,\n\t\t\tstate:number,\n\t\t\tch:string,\n\t\t\tchCode:number,\n\t\t\tchClass:CharacterClass,\n\t\t\tresetStateMachine:boolean,\n\t\t\thasOpenParens:boolean,\n\t\t\thasOpenSquareBracket:boolean,\n\t\t\thasOpenCurlyBracket:boolean,\n\t\t\tcharacterClassifier = LinkComputer._characterClassifier;\n\n\t\tfor (i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n\t\t\tline = model.getLineContent(i);\n\t\t\tj = 0;\n\t\t\tlen = line.length;\n\t\t\tlinkBeginIndex = 0;\n\t\t\tstate = START_STATE;\n\t\t\thasOpenParens = false;\n\t\t\thasOpenSquareBracket = false;\n\t\t\thasOpenCurlyBracket = false;\n\n\t\t\twhile (j < len) {\n\t\t\t\tch = line.charAt(j);\n\t\t\t\tchCode = line.charCodeAt(j);\n\t\t\t\tresetStateMachine = false;\n\n\t\t\t\tif (state === ACCEPT_STATE) {\n\n\t\t\t\t\tswitch (chCode) {\n\t\t\t\t\t\tcase _openParens:\n\t\t\t\t\t\t\thasOpenParens = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _closeParens:\n\t\t\t\t\t\t\tchClass = (hasOpenParens ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _openSquareBracket:\n\t\t\t\t\t\t\thasOpenSquareBracket = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _closeSquareBracket:\n\t\t\t\t\t\t\tchClass = (hasOpenSquareBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _openCurlyBracket:\n\t\t\t\t\t\t\thasOpenCurlyBracket = true;\n\t\t\t\t\t\t\tchClass = CharacterClass.None;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase _closeCurlyBracket:\n\t\t\t\t\t\t\tchClass = (hasOpenCurlyBracket ? CharacterClass.None : CharacterClass.ForceTermination);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tchClass = characterClassifier.classify(chCode);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check if character terminates link\n\t\t\t\t\tif (chClass === CharacterClass.ForceTermination) {\n\n\t\t\t\t\t\t// Do not allow to end link in certain characters...\n\t\t\t\t\t\tlastIncludedCharIndex = j - 1;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tchCode = line.charCodeAt(lastIncludedCharIndex);\n\t\t\t\t\t\t\tchClass = characterClassifier.classify(chCode);\n\t\t\t\t\t\t\tif (chClass !== CharacterClass.CannotEndIn) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastIncludedCharIndex--;\n\t\t\t\t\t\t} while (lastIncludedCharIndex > linkBeginIndex);\n\n\t\t\t\t\t\tresult.push(LinkComputer._createLink(line, i, linkBeginIndex, lastIncludedCharIndex + 1));\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t}\n\t\t\t\t} else if (state === END_STATE) {\n\t\t\t\t\tchClass = characterClassifier.classify(chCode);\n\n\t\t\t\t\t// Check if character terminates link\n\t\t\t\t\tif (chClass === CharacterClass.ForceTermination) {\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstate = ACCEPT_STATE;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (STATE_MAP[state].hasOwnProperty(ch)) {\n\t\t\t\t\t\tstate = STATE_MAP[state][ch];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresetStateMachine = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (resetStateMachine) {\n\t\t\t\t\tstate = START_STATE;\n\t\t\t\t\thasOpenParens = false;\n\t\t\t\t\thasOpenSquareBracket = false;\n\t\t\t\t\thasOpenCurlyBracket = false;\n\n\t\t\t\t\t// Record where the link started\n\t\t\t\t\tlinkBeginIndex = j + 1;\n\t\t\t\t}\n\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\tif (state === ACCEPT_STATE) {\n\t\t\t\tresult.push(LinkComputer._createLink(line, i, linkBeginIndex, len));\n\t\t\t}\n\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nexport function computeLinks(model:ILinkComputerTarget):ILink[] {\n\tif (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n\t\t// Unknown caller!\n\t\treturn [];\n\t}\n\treturn LinkComputer.computeLinks(model);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IRange} from 'vs/editor/common/editorCommon';\nimport {IInplaceReplaceSupportResult} from 'vs/editor/common/modes';\n\nexport class BasicInplaceReplace {\n\n\tpublic static INSTANCE = new BasicInplaceReplace();\n\n\tpublic navigateValueSet(range1:IRange, text1:string, range2:IRange, text2:string, up:boolean): IInplaceReplaceSupportResult {\n\n\t\tif (range1 && text1) {\n\t\t\tlet result = this.doNavigateValueSet(text1, up);\n\t\t\tif (result) {\n\t\t\t\treturn {\n\t\t\t\t\trange: range1,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (range2 && text2) {\n\t\t\tlet result = this.doNavigateValueSet(text2, up);\n\t\t\tif (result) {\n\t\t\t\treturn {\n\t\t\t\t\trange: range2,\n\t\t\t\t\tvalue: result\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate doNavigateValueSet(text:string, up:boolean): string {\n\t\tlet numberResult = this.numberReplace(text, up);\n\t\tif (numberResult !== null) {\n\t\t\treturn numberResult;\n\t\t}\n\t\treturn this.textReplace(text, up);\n\t}\n\n\tprivate numberReplace(value:string, up:boolean):string {\n\t\tvar precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1)),\n\t\t\tn1 = Number(value),\n\t\t\tn2 = parseFloat(value);\n\n\t\tif(!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n\n\t\t\tif(n1 === 0 && !up) {\n\t\t\t\treturn null; // don't do negative\n//\t\t\t} else if(n1 === 9 && up) {\n//\t\t\t\treturn null; // don't insert 10 into a number\n\t\t\t} else {\n\t\t\t\tn1 = Math.floor(n1 * precision);\n\t\t\t\tn1 += up ? precision : -precision;\n\t\t\t\treturn String(n1 / precision);\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate _defaultValueSet: string[][] = [\n\t\t['true', 'false'],\n\t\t['True', 'False'],\n\t\t['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n\t\t['public', 'protected', 'private'],\n\t];\n\n\tprivate textReplace(value:string, up:boolean):string {\n\t\treturn this.valueSetsReplace(this._defaultValueSet, value, up);\n\t}\n\n\tprivate valueSetsReplace(valueSets:string[][], value:string, up:boolean):string {\n\t\tvar result:string = null;\n\t\tfor (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n\t\t\tresult = this.valueSetReplace(valueSets[i], value, up);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate valueSetReplace(valueSet:string[], value:string, up:boolean):string {\n\t\tvar idx = valueSet.indexOf(value);\n\t\tif(idx >= 0) {\n\t\t\tidx += up ? +1 : -1;\n\t\t\tif(idx < 0) {\n\t\t\t\tidx = valueSet.length - 1;\n\t\t\t} else {\n\t\t\t\tidx %= valueSet.length;\n\t\t\t}\n\t\t\treturn valueSet[idx];\n\t\t}\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport {IInplaceReplaceSupportResult, ILink, ISuggestResult} from 'vs/editor/common/modes';\n\nexport interface IRawModelData {\n\turl:string;\n\tversionId:number;\n\tvalue:editorCommon.IRawText;\n}\n\nexport interface IEditorModelWorker {\n\tacceptNewModel(data: IRawModelData): void;\n\tacceptModelChanged(modelUrl: string, events: editorCommon.IModelContentChangedEvent2[]);\n\tacceptRemovedModel(modelUrl: string): void;\n}\n\nexport abstract class EditorSimpleWorker implements IEditorModelWorker {\n\n\tpublic acceptNewModel(data:IRawModelData): void {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic acceptModelChanged(modelUrl: string, events: editorCommon.IModelContentChangedEvent2[]): void {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic acceptRemovedModel(modelUrl: string): void {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic computeDiff(originalUrl:string, modifiedUrl:string, ignoreTrimWhitespace:boolean):TPromise<editorCommon.ILineChange[]> {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic computeDirtyDiff(originalUrl:string, modifiedUrl:string, ignoreTrimWhitespace:boolean):TPromise<editorCommon.IChange[]> {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic computeLinks(modelUrl:string):TPromise<ILink[]> {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic textualSuggest(modelUrl:string, position: editorCommon.IPosition, wordDef:string, wordDefFlags:string): TPromise<ISuggestResult[]> {\n\t\tthrow new Error('Not implemented!');\n\t}\n\n\tpublic navigateValueSet(modelUrl:string, range:editorCommon.IRange, up:boolean, wordDef:string, wordDefFlags:string): TPromise<IInplaceReplaceSupportResult> {\n\t\tthrow new Error('Not implemented!');\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nexport class PrefixSumIndexOfResult {\n\t_prefixSumIndexOfResultBrand: void;\n\n\tindex: number;\n\tremainder: number;\n\n\tconstructor(index:number, remainder:number) {\n\t\tthis.index = index;\n\t\tthis.remainder = remainder;\n\t}\n}\n\nexport class PrefixSumComputer {\n\n\t/**\n\t * values[i] is the value at index i\n\t */\n\tprivate values:number[];\n\n\t/**\n\t * prefixSum[i] = SUM(heights[j]), 0 <= j <= i\n\t */\n\tprivate prefixSum:number[];\n\n\t/**\n\t * prefixSum[i], 0 <= i <= prefixSumValidIndex can be trusted\n\t */\n\tprivate prefixSumValidIndex:number;\n\n\tconstructor(values:number[]) {\n\t\tthis.values = values;\n\t\tthis.prefixSum = [];\n\t\tfor (let i = 0, len = this.values.length; i < len; i++) {\n\t\t\tthis.prefixSum[i] = 0;\n\t\t}\n\t\tthis.prefixSumValidIndex = -1;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this.values.length;\n\t}\n\n\tpublic insertValue(insertIndex:number, value:number): void {\n\t\tinsertIndex = Math.floor(insertIndex); //@perf\n\t\tvalue = Math.floor(value); //@perf\n\n\t\tthis.values.splice(insertIndex, 0, value);\n\t\tthis.prefixSum.splice(insertIndex, 0, 0);\n\t\tif (insertIndex - 1 < this.prefixSumValidIndex) {\n\t\t\tthis.prefixSumValidIndex = insertIndex - 1;\n\t\t}\n\t}\n\n\tpublic insertValues(insertIndex: number, values: number[]): void {\n\t\tinsertIndex = Math.floor(insertIndex); //@perf\n\n\t\tif (values.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.values = this.values.slice(0, insertIndex).concat(values).concat(this.values.slice(insertIndex));\n\t\tthis.prefixSum = this.prefixSum.slice(0, insertIndex).concat(PrefixSumComputer._zeroArray(values.length)).concat(this.prefixSum.slice(insertIndex));\n\n\t\tif (insertIndex - 1 < this.prefixSumValidIndex) {\n\t\t\tthis.prefixSumValidIndex = insertIndex - 1;\n\t\t}\n\t}\n\n\tprivate static _zeroArray(count: number): number[] {\n\t\tcount = Math.floor(count); //@perf\n\n\t\tlet r: number[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tr[i] = 0;\n\t\t}\n\t\treturn r;\n\t}\n\n\tpublic changeValue(index:number, value:number): void {\n\t\tindex = Math.floor(index); //@perf\n\t\tvalue = Math.floor(value); //@perf\n\n\t\tif (this.values[index] === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis.values[index] = value;\n\t\tif (index - 1 < this.prefixSumValidIndex) {\n\t\t\tthis.prefixSumValidIndex = index - 1;\n\t\t}\n\t}\n\n\tpublic removeValues(startIndex:number, cnt:number): void {\n\t\tstartIndex = Math.floor(startIndex); //@perf\n\t\tcnt = Math.floor(cnt); //@perf\n\n\t\tthis.values.splice(startIndex, cnt);\n\t\tthis.prefixSum.splice(startIndex, cnt);\n\t\tif (startIndex - 1 < this.prefixSumValidIndex) {\n\t\t\tthis.prefixSumValidIndex = startIndex - 1;\n\t\t}\n\t}\n\n\tpublic getTotalValue(): number {\n\t\tif (this.values.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.getAccumulatedValue(this.values.length - 1);\n\t}\n\n\tpublic getAccumulatedValue(index:number): number {\n\t\tindex = Math.floor(index); //@perf\n\n\t\tif (index < 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (index <= this.prefixSumValidIndex) {\n\t\t\treturn this.prefixSum[index];\n\t\t}\n\n\t\tlet startIndex = this.prefixSumValidIndex + 1;\n\t\tif (startIndex === 0) {\n\t\t\tthis.prefixSum[0] = this.values[0];\n\t\t\tstartIndex++;\n\t\t}\n\n\t\tif (index >= this.values.length) {\n\t\t\tindex = this.values.length - 1;\n\t\t}\n\n\t\tfor (let i = startIndex; i <= index; i++) {\n\t\t\tthis.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n\t\t}\n\t\tthis.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);\n\t\treturn this.prefixSum[index];\n\t}\n\n\tpublic getIndexOf(accumulatedValue:number): PrefixSumIndexOfResult {\n\t\taccumulatedValue = Math.floor(accumulatedValue); //@perf\n\n\t\tlet low = 0;\n\t\tlet high = this.values.length - 1;\n\t\tlet mid:number;\n\t\tlet midStop:number;\n\t\tlet midStart:number;\n\n\t\twhile (low <= high) {\n\t\t\tmid = low + ( (high-low)/2 ) | 0;\n\n\t\t\tmidStop = this.getAccumulatedValue(mid);\n\t\t\tmidStart = midStop - this.values[mid];\n\n\t\t\tif (accumulatedValue < midStart) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else if (accumulatedValue >= midStop) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport URI from 'vs/base/common/uri';\nimport {IModelContentChangedEvent2, IPosition, IRange} from 'vs/editor/common/editorCommon';\nimport {PrefixSumComputer} from 'vs/editor/common/viewModel/prefixSumComputer';\n\nexport class MirrorModel2 {\n\n\tprotected _uri: URI;\n\tprotected _lines: string[];\n\tprotected _eol: string;\n\tprotected _versionId: number;\n\tprotected _lineStarts: PrefixSumComputer;\n\n\tconstructor(uri: URI, lines: string[], eol: string, versionId: number) {\n\t\tthis._uri = uri;\n\t\tthis._lines = lines;\n\t\tthis._eol = eol;\n\t\tthis._versionId = versionId;\n\t}\n\n\tdispose(): void {\n\t\tthis._lines.length = 0;\n\t}\n\n\tget version(): number {\n\t\treturn this._versionId;\n\t}\n\n\tgetText(): string {\n\t\treturn this._lines.join(this._eol);\n\t}\n\n\tonEvents(events: IModelContentChangedEvent2[]): void {\n\t\tlet newEOL: string = null;\n\t\tfor (let i = 0, len = events.length; i < len; i++) {\n\t\t\tlet e = events[i];\n\t\t\tif (e.eol) {\n\t\t\t\tnewEOL = e.eol;\n\t\t\t}\n\t\t}\n\t\tif (newEOL && newEOL !== this._eol) {\n\t\t\tthis._eol = newEOL;\n\t\t\tthis._lineStarts = null;\n\t\t}\n\n\t\t// Update my lines\n\t\tlet lastVersionId = -1;\n\t\tfor (let i = 0, len = events.length; i < len; i++) {\n\t\t\tlet e = events[i];\n\n\t\t\tthis._acceptDeleteRange(e.range);\n\t\t\tthis._acceptInsertText({\n\t\t\t\tlineNumber: e.range.startLineNumber,\n\t\t\t\tcolumn: e.range.startColumn\n\t\t\t}, e.text);\n\t\t\tlastVersionId = Math.max(lastVersionId, e.versionId);\n\t\t}\n\t\tif (lastVersionId !== -1) {\n\t\t\tthis._versionId = lastVersionId;\n\t\t}\n\t}\n\n\tprotected _ensureLineStarts(): void {\n\t\tif (!this._lineStarts) {\n\t\t\tconst lineStartValues:number[] = [];\n\t\t\tconst eolLength = this._eol.length;\n\t\t\tfor (let i = 0, len = this._lines.length; i < len; i++) {\n\t\t\t\tlineStartValues.push(this._lines[i].length + eolLength);\n\t\t\t}\n\t\t\tthis._lineStarts = new PrefixSumComputer(lineStartValues);\n\t\t}\n\t}\n\n\t/**\n\t * All changes to a line's text go through this method\n\t */\n\tprivate _setLineText(lineIndex:number, newValue:string): void {\n\t\tthis._lines[lineIndex] = newValue;\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n\t\t}\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\tif (range.startColumn === range.endColumn) {\n\t\t\t\t// Nothing to delete\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Delete text on the affected line\n\t\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t\t+ this._lines[range.startLineNumber - 1].substring(range.endColumn - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\tthis._setLineText(range.startLineNumber - 1,\n\t\t\tthis._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n\t\t\t+ this._lines[range.endLineNumber - 1].substring(range.endColumn - 1)\n\t\t);\n\n\t\t// Delete middle lines\n\t\tthis._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: IPosition, insertText:string): void {\n\t\tif (insertText.length === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\t\tlet insertLines = insertText.split(/\\r\\n|\\r|\\n/);\n\t\tif (insertLines.length === 1) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t\t+ insertLines[0]\n\t\t\t\t+ this._lines[position.lineNumber - 1].substring(position.column - 1)\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\n\t\t// Append overflowing text from first line to the end of text to insert\n\t\tinsertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n\n\t\t// Delete overflowing text from first line and insert text on first line\n\t\tthis._setLineText(position.lineNumber - 1,\n\t\t\tthis._lines[position.lineNumber - 1].substring(0, position.column - 1)\n\t\t\t+ insertLines[0]\n\t\t);\n\n\t\t// Insert new lines & store lengths\n\t\tlet newLengths:number[] = new Array<number>(insertLines.length - 1);\n\t\tfor (let i = 1; i < insertLines.length; i++) {\n\t\t\tthis._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n\t\t\tnewLengths[i - 1] = insertLines[i].length + this._eol.length;\n\t\t}\n\n\t\tif (this._lineStarts) {\n\t\t\t// update prefix sum\n\t\t\tthis._lineStarts.insertValues(position.lineNumber, newLengths);\n\t\t}\n\t}\n}\n","define(\"vs/nls!vs/editor/common/config/defaultConfig\",['vs/nls', 'vs/nls!vs/editor/common/services/editorSimpleWorker'], function(nls, data) { return nls.create(\"vs/editor/common/config/defaultConfig\", data); });","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as nls from 'vs/nls';\nimport {IEditorOptions} from 'vs/editor/common/editorCommon';\nimport * as platform from 'vs/base/common/platform';\n\nexport interface IConfiguration {\n\teditor:IEditorOptions;\n}\n\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\nexport const DEFAULT_INDENTATION = {\n\ttabSize: 4,\n\tinsertSpaces: true,\n\tdetectIndentation: true\n};\nexport const DEFAULT_TRIM_AUTO_WHITESPACE = true;\n\nconst DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \\'Courier New\\', monospace';\nconst DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \\'Courier New\\', monospace';\nconst DEFAULT_LINUX_FONT_FAMILY = '\\'Droid Sans Mono\\', \\'Courier New\\', monospace, \\'Droid Sans Fallback\\'';\n\n/**\n * Determined from empirical observations.\n */\nexport const GOLDEN_LINE_HEIGHT_RATIO = platform.isMacintosh ? 1.5 : 1.35;\n\nclass ConfigClass implements IConfiguration {\n\n\tpublic editor: IEditorOptions;\n\n\tconstructor() {\n\t\tthis.editor = {\n\t\t\texperimentalScreenReader: true,\n\t\t\trulers: [],\n\t\t\twordSeparators: USUAL_WORD_SEPARATORS,\n\t\t\tselectionClipboard: true,\n\t\t\tariaLabel: nls.localize('editorViewAccessibleLabel', \"Editor content\"),\n\t\t\tlineNumbers: true,\n\t\t\tselectOnLineNumbers: true,\n\t\t\tlineNumbersMinChars: 5,\n\t\t\tglyphMargin: false,\n\t\t\tlineDecorationsWidth: 10,\n\t\t\trevealHorizontalRightPadding: 30,\n\t\t\troundedSelection: true,\n\t\t\ttheme: 'vs',\n\t\t\treadOnly: false,\n\t\t\tscrollbar: {\n\t\t\t\tverticalScrollbarSize: 14,\n\t\t\t\thorizontal: 'auto',\n\t\t\t\tuseShadows: true,\n\t\t\t\tverticalHasArrows: false,\n\t\t\t\thorizontalHasArrows: false\n\t\t\t},\n\t\t\toverviewRulerLanes: 2,\n\t\t\tcursorBlinking: 'blink',\n\t\t\tcursorStyle: 'line',\n\t\t\tfontLigatures: false,\n\t\t\tdisableTranslate3d: false,\n\t\t\thideCursorInOverviewRuler: false,\n\t\t\tscrollBeyondLastLine: true,\n\t\t\tautomaticLayout: false,\n\t\t\twrappingColumn: 300,\n\t\t\twrappingIndent: 'same',\n\t\t\twordWrapBreakBeforeCharacters: '([{+',\n\t\t\twordWrapBreakAfterCharacters: ' \\t})]?|&,;',\n\t\t\twordWrapBreakObtrusiveCharacters: '.',\n\t\t\ttabFocusMode: false,\n\n\t\t\t// Features\n\t\t\thover: true,\n\t\t\tcontextmenu: true,\n\t\t\tmouseWheelScrollSensitivity: 1,\n\t\t\tquickSuggestions: true,\n\t\t\tquickSuggestionsDelay: 10,\n\t\t\ticonsInSuggestions: true,\n\t\t\tautoClosingBrackets: true,\n\t\t\tformatOnType: false,\n\t\t\tsuggestOnTriggerCharacters: true,\n\t\t\tacceptSuggestionOnEnter: true,\n\t\t\tselectionHighlight: true,\n\t\t\toutlineMarkers: false,\n\t\t\treferenceInfos: true,\n\t\t\tfolding: true,\n\t\t\trenderWhitespace: false,\n\t\t\tindentGuides: false,\n\t\t\tuseTabStops: true,\n\n\t\t\tfontFamily: (\n\t\t\t\tplatform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)\n\t\t\t),\n\t\t\tfontSize: (\n\t\t\t\tplatform.isMacintosh ? 12 : 14\n\t\t\t),\n\t\t\tlineHeight: 0\n\t\t};\n\t}\n}\n\nexport var DefaultConfig: IConfiguration = new ConfigClass();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport * as modes from 'vs/editor/common/modes';\nimport {USUAL_WORD_SEPARATORS} from 'vs/editor/common/config/defaultConfig';\n\nexport class NullState implements modes.IState {\n\n\tprivate mode: modes.IMode;\n\tprivate stateData: modes.IState;\n\n\tconstructor(mode: modes.IMode, stateData: modes.IState) {\n\t\tthis.mode = mode;\n\t\tthis.stateData = stateData;\n\t}\n\n\tpublic clone(): modes.IState {\n\t\tvar stateDataClone:modes.IState = (this.stateData ? this.stateData.clone() : null);\n\t\treturn new NullState(this.mode, stateDataClone);\n\t}\n\n\tpublic equals(other:modes.IState): boolean {\n\t\tif (this.mode !== other.getMode()) {\n\t\t\treturn false;\n\t\t}\n\t\tvar otherStateData = other.getStateData();\n\t\tif (!this.stateData && !otherStateData) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this.stateData && otherStateData) {\n\t\t\treturn this.stateData.equals(otherStateData);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic getMode(): modes.IMode {\n\t\treturn this.mode;\n\t}\n\n\tpublic tokenize(stream:modes.IStream):modes.ITokenizationResult {\n\t\tstream.advanceToEOS();\n\t\treturn { type:'' };\n\t}\n\n\tpublic getStateData(): modes.IState {\n\t\treturn this.stateData;\n\t}\n\n\tpublic setStateData(stateData:modes.IState):void {\n\t\tthis.stateData = stateData;\n\t}\n}\n\nexport class NullMode implements modes.IMode {\n\n\t/**\n\t * Create a word definition regular expression based on default word separators.\n\t * Optionally provide allowed separators that should be included in words.\n\t *\n\t * The default would look like this:\n\t * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n\t */\n\tpublic static createWordRegExp(allowInWords:string = ''): RegExp {\n\t\tvar usualSeparators = USUAL_WORD_SEPARATORS;\n\t\tvar source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n\t\tfor (var i = 0; i < usualSeparators.length; i++) {\n\t\t\tif (allowInWords.indexOf(usualSeparators[i]) >= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsource += '\\\\' + usualSeparators[i];\n\t\t}\n\t\tsource += '\\\\s]+)';\n\t\treturn new RegExp(source, 'g');\n\t}\n\n\t// catches numbers (including floating numbers) in the first group, and alphanum in the second\n\tstatic DEFAULT_WORD_REGEXP = NullMode.createWordRegExp();\n\n\tpublic static ID = 'vs.editor.modes.nullMode';\n\n\tpublic richEditSupport: modes.IRichEditSupport;\n\n\tconstructor() {\n\t\tthis.richEditSupport = {\n\t\t\twordDefinition: NullMode.DEFAULT_WORD_REGEXP\n\t\t};\n\t}\n\n\tpublic getId():string {\n\t\treturn NullMode.ID;\n\t}\n\n\tpublic toSimplifiedMode(): modes.IMode {\n\t\treturn this;\n\t}\n}\n\nexport function nullTokenize(mode: modes.IMode, buffer:string, state: modes.IState, deltaOffset:number = 0, stopAtOffset?:number): modes.ILineTokens {\n\tvar tokens:modes.IToken[] = [\n\t\t{\n\t\t\tstartIndex: deltaOffset,\n\t\t\ttype: ''\n\t\t}\n\t];\n\n\tvar modeTransitions:modes.IModeTransition[] = [\n\t\t{\n\t\t\tstartIndex: deltaOffset,\n\t\t\tmode: mode\n\t\t}\n\t];\n\n\treturn {\n\t\ttokens: tokens,\n\t\tactualStopOffset: deltaOffset + buffer.length,\n\t\tendState: state,\n\t\tmodeTransitions: modeTransitions\n\t};\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport {IPosition, IWordAtPosition} from 'vs/editor/common/editorCommon';\nimport {IMode, IModeTransition} from 'vs/editor/common/modes';\nimport {NullMode} from 'vs/editor/common/modes/nullMode';\nimport {ModeTransition} from 'vs/editor/common/core/modeTransition';\n\nexport interface ITextSource {\n\n\t_lineIsTokenized(lineNumber:number): boolean;\n\n\tgetLineContent(lineNumber:number): string;\n\n\tgetMode(): IMode;\n\n\t_getLineModeTransitions(lineNumber:number): ModeTransition[];\n}\n\nexport interface INonWordTokenMap {\n\t[key:string]:boolean;\n}\n\nexport class WordHelper {\n\n\tprivate static _safeGetWordDefinition(mode:IMode): RegExp {\n\t\treturn (mode.richEditSupport ? mode.richEditSupport.wordDefinition : null);\n\t}\n\n\tpublic static ensureValidWordDefinition(wordDefinition?:RegExp): RegExp {\n\t\tvar result: RegExp = NullMode.DEFAULT_WORD_REGEXP;\n\n\t\tif (wordDefinition && (wordDefinition instanceof RegExp)) {\n\t\t\tif (!wordDefinition.global) {\n\t\t\t\tvar flags = 'g';\n\t\t\t\tif (wordDefinition.ignoreCase) {\n\t\t\t\t\tflags += 'i';\n\t\t\t\t}\n\t\t\t\tif (wordDefinition.multiline) {\n\t\t\t\t\tflags += 'm';\n\t\t\t\t}\n\t\t\t\tresult = new RegExp(wordDefinition.source, flags);\n\t\t\t} else {\n\t\t\t\tresult = wordDefinition;\n\t\t\t}\n\t\t}\n\n\t\tresult.lastIndex = 0;\n\n\t\treturn result;\n\t}\n\n\tpublic static massageWordDefinitionOf(mode:IMode): RegExp {\n\t\treturn WordHelper.ensureValidWordDefinition(WordHelper._safeGetWordDefinition(mode));\n\t}\n\n\tprivate static _getWordAtColumn(txt:string, column:number, modeIndex: number, modeTransitions:IModeTransition[]): IWordAtPosition {\n\t\tvar modeStartIndex = modeTransitions[modeIndex].startIndex,\n\t\t\tmodeEndIndex = (modeIndex + 1 < modeTransitions.length ? modeTransitions[modeIndex + 1].startIndex : txt.length),\n\t\t\tmode = modeTransitions[modeIndex].mode;\n\n\t\treturn WordHelper._getWordAtText(\n\t\t\tcolumn, WordHelper.massageWordDefinitionOf(mode),\n\t\t\ttxt.substring(modeStartIndex, modeEndIndex), modeStartIndex\n\t\t);\n\t}\n\n\tpublic static getWordAtPosition(textSource:ITextSource, position:IPosition): IWordAtPosition {\n\n\t\tif (!textSource._lineIsTokenized(position.lineNumber)) {\n\t\t\treturn WordHelper._getWordAtText(position.column, WordHelper.massageWordDefinitionOf(textSource.getMode()), textSource.getLineContent(position.lineNumber), 0);\n\t\t}\n\n\t\tvar result: IWordAtPosition = null;\n\t\tvar txt = textSource.getLineContent(position.lineNumber),\n\t\t\tmodeTransitions = textSource._getLineModeTransitions(position.lineNumber),\n\t\t\tcolumnIndex = position.column - 1,\n\t\t\tmodeIndex = ModeTransition.findIndexInSegmentsArray(modeTransitions, columnIndex);\n\n\t\tresult = WordHelper._getWordAtColumn(txt, position.column, modeIndex, modeTransitions);\n\n\t\tif (!result && modeIndex > 0 && modeTransitions[modeIndex].startIndex === columnIndex) {\n\t\t\t// The position is right at the beginning of `modeIndex`, so try looking at `modeIndex` - 1 too\n\t\t\tresult = WordHelper._getWordAtColumn(txt, position.column, modeIndex - 1, modeTransitions);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tstatic _getWordAtText(column:number, wordDefinition:RegExp, text:string, textOffset:number): IWordAtPosition {\n\n\t\t// console.log('_getWordAtText: ', column, text, textOffset);\n\n\t\tvar words = text.match(wordDefinition),\n\t\t\tk:number,\n\t\t\tstartWord:number,\n\t\t\tendWord:number,\n\t\t\tstartColumn:number,\n\t\t\tendColumn:number,\n\t\t\tword:string;\n\n\t\tif (words) {\n\t\t\tfor (k = 0; k < words.length; k++) {\n\t\t\t\tword = words[k].trim();\n\t\t\t\tif (word.length > 0) {\n\t\t\t\t\tstartWord = text.indexOf(word, endWord);\n\t\t\t\t\tendWord = startWord + word.length;\n\n\t\t\t\t\tstartColumn = textOffset + startWord + 1;\n\t\t\t\t\tendColumn = textOffset + endWord + 1;\n\n\t\t\t\t\tif (startColumn <= column && column <= endColumn) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tword: word,\n\t\t\t\t\t\t\tstartColumn: startColumn,\n\t\t\t\t\t\t\tendColumn: endColumn\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport URI from 'vs/base/common/uri';\nimport {TPromise} from 'vs/base/common/winjs.base';\nimport {IRequestHandler} from 'vs/base/common/worker/simpleWorker';\nimport {Range} from 'vs/editor/common/core/range';\nimport {fuzzyContiguousFilter} from 'vs/base/common/filters';\nimport {DiffComputer} from 'vs/editor/common/diff/diffComputer';\nimport * as editorCommon from 'vs/editor/common/editorCommon';\nimport {MirrorModel2} from 'vs/editor/common/model/mirrorModel2';\nimport {WordHelper} from 'vs/editor/common/model/textModelWithTokensHelpers';\nimport {IInplaceReplaceSupportResult, ILink, ISuggestResult, ISuggestion} from 'vs/editor/common/modes';\nimport {computeLinks} from 'vs/editor/common/modes/linkComputer';\nimport {BasicInplaceReplace} from 'vs/editor/common/modes/supports/inplaceReplaceSupport';\nimport {EditorSimpleWorker, IRawModelData} from 'vs/editor/common/services/editorSimpleWorkerCommon';\n\nclass MirrorModel extends MirrorModel2 {\n\n\tpublic getLinesContent(): string[] {\n\t\treturn this._lines.slice(0);\n\t}\n\n\tpublic getLineCount(): number {\n\t\treturn this._lines.length;\n\t}\n\n\tpublic getLineContent(lineNumber:number): string {\n\t\treturn this._lines[lineNumber - 1];\n\t}\n\n\tpublic getWordAtPosition(position:editorCommon.IPosition, wordDefinition:RegExp): Range {\n\n\t\tlet wordAtText = WordHelper._getWordAtText(\n\t\t\tposition.column,\n\t\t\tWordHelper.ensureValidWordDefinition(wordDefinition),\n\t\t\tthis._lines[position.lineNumber - 1],\n\t\t\t0\n\t\t);\n\n\t\tif (wordAtText) {\n\t\t\treturn new Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tpublic getWordUntilPosition(position: editorCommon.IPosition, wordDefinition:RegExp): editorCommon.IWordAtPosition {\n\t\tvar wordAtPosition = this.getWordAtPosition(position, wordDefinition);\n\t\tif (!wordAtPosition) {\n\t\t\treturn {\n\t\t\t\tword: '',\n\t\t\t\tstartColumn: position.column,\n\t\t\t\tendColumn: position.column\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tword: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),\n\t\t\tstartColumn: wordAtPosition.startColumn,\n\t\t\tendColumn: position.column\n\t\t};\n\t}\n\n\tprivate _getAllWords(wordDefinition:RegExp): string[] {\n\t\tvar result:string[] = [];\n\t\tthis._lines.forEach((line) => {\n\t\t\tthis._wordenize(line, wordDefinition).forEach((info) => {\n\t\t\t\tresult.push(line.substring(info.start, info.end));\n\t\t\t});\n\t\t});\n\t\treturn result;\n\t}\n\n\tpublic getAllUniqueWords(wordDefinition:RegExp, skipWordOnce?:string) : string[] {\n\t\tvar foundSkipWord = false;\n\t\tvar uniqueWords = {};\n\t\treturn this._getAllWords(wordDefinition).filter((word) => {\n\t\t\tif (skipWordOnce && !foundSkipWord && skipWordOnce === word) {\n\t\t\t\tfoundSkipWord = true;\n\t\t\t\treturn false;\n\t\t\t} else if (uniqueWords[word]) {\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tuniqueWords[word] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t}\n\n//\t// TODO@Joh, TODO@Alex - remove these and make sure the super-things work\n\tprivate _wordenize(content:string, wordDefinition:RegExp): editorCommon.IWordRange[] {\n\t\tvar result:editorCommon.IWordRange[] = [];\n\t\tvar match:RegExpExecArray;\n\t\twhile (match = wordDefinition.exec(content)) {\n\t\t\tif (match[0].length === 0) {\n\t\t\t\t// it did match the empty string\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult.push({ start: match.index, end: match.index + match[0].length });\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic getValueInRange(range:editorCommon.IRange): string {\n\t\tif (range.startLineNumber === range.endLineNumber) {\n\t\t\treturn this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n\t\t}\n\n\t\tvar lineEnding = this._eol,\n\t\t\tstartLineIndex = range.startLineNumber - 1,\n\t\t\tendLineIndex = range.endLineNumber - 1,\n\t\t\tresultLines:string[] = [];\n\n\t\tresultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n\t\tfor (var i = startLineIndex + 1; i < endLineIndex; i++) {\n\t\t\tresultLines.push(this._lines[i]);\n\t\t}\n\t\tresultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n\n\t\treturn resultLines.join(lineEnding);\n\t}\n}\n\nexport class EditorSimpleWorkerImpl extends EditorSimpleWorker implements IRequestHandler {\n\t_requestHandlerTrait: any;\n\n\tprivate _models:{[uri:string]:MirrorModel;};\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis._models = Object.create(null);\n\t}\n\n\tpublic acceptNewModel(data:IRawModelData): void {\n\t\tthis._models[data.url] = new MirrorModel(URI.parse(data.url), data.value.lines, data.value.EOL, data.versionId);\n\t}\n\n\tpublic acceptModelChanged(strURL: string, events: editorCommon.IModelContentChangedEvent2[]): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tlet model = this._models[strURL];\n\t\tmodel.onEvents(events);\n\t}\n\n\tpublic acceptRemovedModel(strURL: string): void {\n\t\tif (!this._models[strURL]) {\n\t\t\treturn;\n\t\t}\n\t\tdelete this._models[strURL];\n\t}\n\n\t// ---- BEGIN diff --------------------------------------------------------------------------\n\n\tpublic computeDiff(originalUrl:string, modifiedUrl:string, ignoreTrimWhitespace:boolean): TPromise<editorCommon.ILineChange[]> {\n\t\tlet original = this._models[originalUrl];\n\t\tlet modified = this._models[modifiedUrl];\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet originalLines = original.getLinesContent();\n\t\tlet modifiedLines = modified.getLinesContent();\n\t\tlet diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tshouldPostProcessCharChanges: true,\n\t\t\tshouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n\t\t\tshouldConsiderTrimWhitespaceInEmptyCase: true\n\t\t});\n\t\treturn TPromise.as(diffComputer.computeDiff());\n\t}\n\n\tpublic computeDirtyDiff(originalUrl:string, modifiedUrl:string, ignoreTrimWhitespace:boolean):TPromise<editorCommon.IChange[]> {\n\t\tlet original = this._models[originalUrl];\n\t\tlet modified = this._models[modifiedUrl];\n\t\tif (!original || !modified) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet originalLines = original.getLinesContent();\n\t\tlet modifiedLines = modified.getLinesContent();\n\t\tlet diffComputer = new DiffComputer(originalLines, modifiedLines, {\n\t\t\tshouldPostProcessCharChanges: false,\n\t\t\tshouldIgnoreTrimWhitespace: ignoreTrimWhitespace,\n\t\t\tshouldConsiderTrimWhitespaceInEmptyCase: false\n\t\t});\n\t\treturn TPromise.as(diffComputer.computeDiff());\n\t}\n\n\t// ---- END diff --------------------------------------------------------------------------\n\n\tpublic computeLinks(modelUrl:string):TPromise<ILink[]> {\n\t\tlet model = this._models[modelUrl];\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn TPromise.as(computeLinks(model));\n\t}\n\n\t// ---- BEGIN suggest --------------------------------------------------------------------------\n\n\tpublic textualSuggest(modelUrl:string, position: editorCommon.IPosition, wordDef:string, wordDefFlags:string): TPromise<ISuggestResult[]> {\n\t\tlet model = this._models[modelUrl];\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn TPromise.as(this._suggestFiltered(model, position, new RegExp(wordDef, wordDefFlags)));\n\t}\n\n\tprivate _suggestFiltered(model:MirrorModel, position: editorCommon.IPosition, wordDefRegExp: RegExp): ISuggestResult[] {\n\t\tlet value = this._suggestUnfiltered(model, position, wordDefRegExp);\n\n\t\t// filter suggestions\n\t\treturn [{\n\t\t\tcurrentWord: value.currentWord,\n\t\t\tsuggestions: value.suggestions.filter((element) => !!fuzzyContiguousFilter(value.currentWord, element.label)),\n\t\t\tincomplete: value.incomplete\n\t\t}];\n\t}\n\n\tprivate _suggestUnfiltered(model:MirrorModel, position:editorCommon.IPosition, wordDefRegExp: RegExp): ISuggestResult {\n\t\tlet currentWord = model.getWordUntilPosition(position, wordDefRegExp).word;\n\t\tlet allWords = model.getAllUniqueWords(wordDefRegExp, currentWord);\n\n\t\tlet suggestions = allWords.filter((word) => {\n\t\t\treturn !(/^-?\\d*\\.?\\d/.test(word)); // filter out numbers\n\t\t}).map((word) => {\n\t\t\treturn <ISuggestion> {\n\t\t\t\ttype: 'text',\n\t\t\t\tlabel: word,\n\t\t\t\tcodeSnippet: word,\n\t\t\t\tnoAutoAccept: true\n\t\t\t};\n\t\t});\n\n\t\treturn {\n\t\t\tcurrentWord: currentWord,\n\t\t\tsuggestions: suggestions\n\t\t};\n\t}\n\n\t// ---- END suggest --------------------------------------------------------------------------\n\n\tpublic navigateValueSet(modelUrl:string, range:editorCommon.IRange, up:boolean, wordDef:string, wordDefFlags:string): TPromise<IInplaceReplaceSupportResult> {\n\t\tlet model = this._models[modelUrl];\n\t\tif (!model) {\n\t\t\treturn null;\n\t\t}\n\n\t\tlet wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n\n\t\tif (range.startColumn === range.endColumn) {\n\t\t\trange.endColumn += 1;\n\t\t}\n\n\t\tlet selectionText = model.getValueInRange(range);\n\n\t\tlet\twordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n\t\tlet word: string = null;\n\t\tif (wordRange !== null) {\n\t\t\tword = model.getValueInRange(wordRange);\n\t\t}\n\n\t\tlet result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n\t\treturn TPromise.as(result);\n\t}\n}\n\n/**\n * Called on the worker side\n */\nexport function create(): IRequestHandler {\n\treturn new EditorSimpleWorkerImpl();\n}\n"]}