{"version":3,"sources":["oojs.jquery.js"],"names":["global","simpleArrayCombine","a","b","includeB","i","ilen","bObj","result","length","push","oo","hasOwn","hasOwnProperty","toString","initClass","fn","static","inheritClass","targetFn","originFn","targetConstructor","Error","prototype","constructor","parent","Object","create","value","enumerable","writable","configurable","mixinClass","key","call","isSubclass","testFn","baseFn","getProp","obj","retval","arguments","undefined","setProp","prop","deleteProp","props","pop","isPlainObject","keys","cloneObject","origin","r","getObjectValues","values","TypeError","binarySearch","arr","searchFunc","forInsertion","mid","cmpResult","left","right","compare","asymmetrical","aValue","bValue","aType","bType","k","nodeType","isEqualNode","copy","source","leafCallback","nodeCallback","destination","Array","isArray","clone","cloneNode","getHash","val","JSON","stringify","keySortReplacer","normalized","len","getHashObject","sort","unique","reduce","current","indexOf","simpleArrayUnion","j","jlen","simpleArrayIntersection","simpleArrayDifference","$","validateMethod","method","context","addBinding","ee","event","binding","bindings","EventEmitter","this","on","args","once","listener","off","splice","emit","slice","apply","concat","connect","methods","disconnect","normalizeArrayIndex","index","EmitterList","items","aggregateItemEvents","getItems","getItemIndex","item","getItemCount","isEmpty","aggregate","events","add","remove","itemEvent","groupEvent","addItems","oldIndex","moveItem","insertItem","newIndex","existingIndex","removeItems","clearItems","cleared","SortedEmitterList","sortingCallback","sortChange","itemSortChange","onItemSortChange","setSortingCallback","insertionIndex","findInsertionIndex","list","otherItem","Registry","registry","register","name","data","unregister","lookup","Factory","super","module","exports","OO"],"mappings":"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","file":"oojs.jquery.min.js","sourcesContent":["/*!\n * OOjs v2.1.0 optimised for jQuery\n * https://www.mediawiki.org/wiki/OOjs\n *\n * Copyright 2011-2017 OOjs Team and other contributors.\n * Released under the MIT license\n * https://oojs.mit-license.org\n *\n * Date: 2017-05-30T22:56:52Z\n */\n( function ( global ) {\n\n'use strict';\n\n/* exported toString */\nvar\n\t/**\n\t * Namespace for all classes, static methods and static properties.\n\t * @class OO\n\t * @singleton\n\t */\n\too = {},\n\t// Optimisation: Local reference to Object.prototype.hasOwnProperty\n\thasOwn = oo.hasOwnProperty,\n\ttoString = oo.toString;\n\n/* Class Methods */\n\n/**\n * Utility to initialize a class for OO inheritance.\n *\n * Currently this just initializes an empty static object.\n *\n * @param {Function} fn\n */\noo.initClass = function ( fn ) {\n\tfn.static = fn.static || {};\n};\n\n/**\n * Inherit from prototype to another using Object#create.\n *\n * Beware: This redefines the prototype, call before setting your prototypes.\n *\n * Beware: This redefines the prototype, can only be called once on a function.\n * If called multiple times on the same function, the previous prototype is lost.\n * This is how prototypal inheritance works, it can only be one straight chain\n * (just like classical inheritance in PHP for example). If you need to work with\n * multiple constructors consider storing an instance of the other constructor in a\n * property instead, or perhaps use a mixin (see OO.mixinClass).\n *\n *     function Thing() {}\n *     Thing.prototype.exists = function () {};\n *\n *     function Person() {\n *         Person.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Person, Thing );\n *     Person.static.defaultEyeCount = 2;\n *     Person.prototype.walk = function () {};\n *\n *     function Jumper() {\n *         Jumper.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Jumper, Person );\n *     Jumper.prototype.jump = function () {};\n *\n *     Jumper.static.defaultEyeCount === 2;\n *     var x = new Jumper();\n *     x.jump();\n *     x.walk();\n *     x instanceof Thing && x instanceof Person && x instanceof Jumper;\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n * @throws {Error} If target already inherits from origin\n */\noo.inheritClass = function ( targetFn, originFn ) {\n\tvar targetConstructor;\n\n\tif ( !originFn ) {\n\t\tthrow new Error( 'inheritClass: Origin is not a function (actually ' + originFn + ')' );\n\t}\n\tif ( targetFn.prototype instanceof originFn ) {\n\t\tthrow new Error( 'inheritClass: Target already inherits from origin' );\n\t}\n\n\ttargetConstructor = targetFn.prototype.constructor;\n\n\t// Using ['super'] instead of .super because 'super' is not supported\n\t// by IE 8 and below (bug 63303).\n\t// Provide .parent as alias for code supporting older browsers which\n\t// allows people to comply with their style guide.\n\t// eslint-disable-next-line dot-notation\n\ttargetFn[ 'super' ] = targetFn.parent = originFn;\n\n\ttargetFn.prototype = Object.create( originFn.prototype, {\n\t\t// Restore constructor property of targetFn\n\t\tconstructor: {\n\t\t\tvalue: targetConstructor,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t} );\n\n\t// Extend static properties - always initialize both sides\n\too.initClass( originFn );\n\ttargetFn.static = Object.create( originFn.static );\n};\n\n/**\n * Copy over *own* prototype properties of a mixin.\n *\n * The 'constructor' (whether implicit or explicit) is not copied over.\n *\n * This does not create inheritance to the origin. If you need inheritance,\n * use OO.inheritClass instead.\n *\n * Beware: This can redefine a prototype property, call before setting your prototypes.\n *\n * Beware: Don't call before OO.inheritClass.\n *\n *     function Foo() {}\n *     function Context() {}\n *\n *     // Avoid repeating this code\n *     function ContextLazyLoad() {}\n *     ContextLazyLoad.prototype.getContext = function () {\n *         if ( !this.context ) {\n *             this.context = new Context();\n *         }\n *         return this.context;\n *     };\n *\n *     function FooBar() {}\n *     OO.inheritClass( FooBar, Foo );\n *     OO.mixinClass( FooBar, ContextLazyLoad );\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n */\noo.mixinClass = function ( targetFn, originFn ) {\n\tvar key;\n\n\tif ( !originFn ) {\n\t\tthrow new Error( 'mixinClass: Origin is not a function (actually ' + originFn + ')' );\n\t}\n\n\t// Copy prototype properties\n\tfor ( key in originFn.prototype ) {\n\t\tif ( key !== 'constructor' && hasOwn.call( originFn.prototype, key ) ) {\n\t\t\ttargetFn.prototype[ key ] = originFn.prototype[ key ];\n\t\t}\n\t}\n\n\t// Copy static properties - always initialize both sides\n\too.initClass( targetFn );\n\tif ( originFn.static ) {\n\t\tfor ( key in originFn.static ) {\n\t\t\tif ( hasOwn.call( originFn.static, key ) ) {\n\t\t\t\ttargetFn.static[ key ] = originFn.static[ key ];\n\t\t\t}\n\t\t}\n\t} else {\n\t\too.initClass( originFn );\n\t}\n};\n\n/**\n * Test whether one class is a subclass of another, without instantiating it.\n *\n * Every class is considered a subclass of Object and of itself.\n *\n * @param {Function} testFn The class to be tested\n * @param {Function} baseFn The base class\n * @return {boolean} Whether testFn is a subclass of baseFn (or equal to it)\n */\noo.isSubclass = function ( testFn, baseFn ) {\n\treturn testFn === baseFn || testFn.prototype instanceof baseFn;\n};\n\n/* Object Methods */\n\n/**\n * Get a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `quux = OO.getProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `quux = obj.foo.bar.baz;`\n * except that the former protects against JS errors if one of the intermediate properties\n * is undefined. Instead of throwing an error, this function will return undefined in\n * that case.\n *\n * @param {Object} obj\n * @param {...Mixed} [keys]\n * @return {Object|undefined} obj[arguments[1]][arguments[2]].... or undefined\n */\noo.getProp = function ( obj ) {\n\tvar i,\n\t\tretval = obj;\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\tif ( retval === undefined || retval === null ) {\n\t\t\t// Trying to access a property of undefined or null causes an error\n\t\t\treturn undefined;\n\t\t}\n\t\tretval = retval[ arguments[ i ] ];\n\t}\n\treturn retval;\n};\n\n/**\n * Set a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `oo.setProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `obj.foo.bar = baz;` except that\n * the former protects against JS errors if one of the intermediate properties is\n * undefined. Instead of throwing an error, undefined intermediate properties will be\n * initialized to an empty object. If an intermediate property is not an object, or if obj itself\n * is not an object, this function will silently abort.\n *\n * @param {Object} obj\n * @param {...Mixed} [keys]\n * @param {Mixed} [value]\n */\noo.setProp = function ( obj ) {\n\tvar i,\n\t\tprop = obj;\n\tif ( Object( obj ) !== obj || arguments.length < 2 ) {\n\t\treturn;\n\t}\n\tfor ( i = 1; i < arguments.length - 2; i++ ) {\n\t\tif ( prop[ arguments[ i ] ] === undefined ) {\n\t\t\tprop[ arguments[ i ] ] = {};\n\t\t}\n\t\tif ( Object( prop[ arguments[ i ] ] ) !== prop[ arguments[ i ] ] ) {\n\t\t\treturn;\n\t\t}\n\t\tprop = prop[ arguments[ i ] ];\n\t}\n\tprop[ arguments[ arguments.length - 2 ] ] = arguments[ arguments.length - 1 ];\n};\n\n/**\n * Delete a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors, and deleting resulting empty objects.\n *\n * @param {Object} obj\n * @param {...Mixed} [keys]\n */\noo.deleteProp = function ( obj ) {\n\tvar i,\n\t\tprop = obj,\n\t\tprops = [ prop ];\n\tif ( Object( obj ) !== obj || arguments.length < 2 ) {\n\t\treturn;\n\t}\n\tfor ( i = 1; i < arguments.length - 1; i++ ) {\n\t\tif ( prop[ arguments[ i ] ] === undefined || Object( prop[ arguments[ i ] ] ) !== prop[ arguments[ i ] ] ) {\n\t\t\treturn;\n\t\t}\n\t\tprop = prop[ arguments[ i ] ];\n\t\tprops.push( prop );\n\t}\n\tdelete prop[ arguments[ i ] ];\n\t// Walk back through props removing any plain empty objects\n\twhile ( ( prop = props.pop() ) && oo.isPlainObject( prop ) && !Object.keys( prop ).length ) {\n\t\tdelete props[ props.length - 1 ][ arguments[ props.length ] ];\n\t}\n};\n\n/**\n * Create a new object that is an instance of the same\n * constructor as the input, inherits from the same object\n * and contains the same own properties.\n *\n * This makes a shallow non-recursive copy of own properties.\n * To create a recursive copy of plain objects, use #copy.\n *\n *     var foo = new Person( mom, dad );\n *     foo.setAge( 21 );\n *     var foo2 = OO.cloneObject( foo );\n *     foo.setAge( 22 );\n *\n *     // Then\n *     foo2 !== foo; // true\n *     foo2 instanceof Person; // true\n *     foo2.getAge(); // 21\n *     foo.getAge(); // 22\n *\n * @param {Object} origin\n * @return {Object} Clone of origin\n */\noo.cloneObject = function ( origin ) {\n\tvar key, r;\n\n\tr = Object.create( origin.constructor.prototype );\n\n\tfor ( key in origin ) {\n\t\tif ( hasOwn.call( origin, key ) ) {\n\t\t\tr[ key ] = origin[ key ];\n\t\t}\n\t}\n\n\treturn r;\n};\n\n/**\n * Get an array of all property values in an object.\n *\n * @param {Object} obj Object to get values from\n * @return {Array} List of object values\n */\noo.getObjectValues = function ( obj ) {\n\tvar key, values;\n\n\tif ( obj !== Object( obj ) ) {\n\t\tthrow new TypeError( 'Called on non-object' );\n\t}\n\n\tvalues = [];\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tvalues[ values.length ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn values;\n};\n\n/**\n * Use binary search to locate an element in a sorted array.\n *\n * searchFunc is given an element from the array. `searchFunc(elem)` must return a number\n * above 0 if the element we're searching for is to the right of (has a higher index than) elem,\n * below 0 if it is to the left of elem, or zero if it's equal to elem.\n *\n * To search for a specific value with a comparator function (a `function cmp(a,b)` that returns\n * above 0 if `a > b`, below 0 if `a < b`, and 0 if `a == b`), you can use\n * `searchFunc = cmp.bind( null, value )`.\n *\n * @param {Array} arr Array to search in\n * @param {Function} searchFunc Search function\n * @param {boolean} [forInsertion] If not found, return index where val could be inserted\n * @return {number|null} Index where val was found, or null if not found\n */\noo.binarySearch = function ( arr, searchFunc, forInsertion ) {\n\tvar mid, cmpResult,\n\t\tleft = 0,\n\t\tright = arr.length;\n\twhile ( left < right ) {\n\t\t// Equivalent to Math.floor( ( left + right ) / 2 ) but much faster\n\t\t// eslint-disable-next-line no-bitwise\n\t\tmid = ( left + right ) >> 1;\n\t\tcmpResult = searchFunc( arr[ mid ] );\n\t\tif ( cmpResult < 0 ) {\n\t\t\tright = mid;\n\t\t} else if ( cmpResult > 0 ) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn forInsertion ? right : null;\n};\n\n/**\n * Recursively compare properties between two objects.\n *\n * A false result may be caused by property inequality or by properties in one object missing from\n * the other. An asymmetrical test may also be performed, which checks only that properties in the\n * first object are present in the second object, but not the inverse.\n *\n * If either a or b is null or undefined it will be treated as an empty object.\n *\n * @param {Object|undefined|null} a First object to compare\n * @param {Object|undefined|null} b Second object to compare\n * @param {boolean} [asymmetrical] Whether to check only that a's values are equal to b's\n *  (i.e. a is a subset of b)\n * @return {boolean} If the objects contain the same values as each other\n */\noo.compare = function ( a, b, asymmetrical ) {\n\tvar aValue, bValue, aType, bType, k;\n\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\ta = a || {};\n\tb = b || {};\n\n\tif ( typeof a.nodeType === 'number' && typeof a.isEqualNode === 'function' ) {\n\t\treturn a.isEqualNode( b );\n\t}\n\n\tfor ( k in a ) {\n\t\tif ( !hasOwn.call( a, k ) || a[ k ] === undefined || a[ k ] === b[ k ] ) {\n\t\t\t// Support es3-shim: Without the hasOwn filter, comparing [] to {} will be false in ES3\n\t\t\t// because the shimmed \"forEach\" is enumerable and shows up in Array but not Object.\n\t\t\t// Also ignore undefined values, because there is no conceptual difference between\n\t\t\t// a key that is absent and a key that is present but whose value is undefined.\n\t\t\tcontinue;\n\t\t}\n\n\t\taValue = a[ k ];\n\t\tbValue = b[ k ];\n\t\taType = typeof aValue;\n\t\tbType = typeof bValue;\n\t\tif ( aType !== bType ||\n\t\t\t(\n\t\t\t\t( aType === 'string' || aType === 'number' || aType === 'boolean' ) &&\n\t\t\t\taValue !== bValue\n\t\t\t) ||\n\t\t\t( aValue === Object( aValue ) && !oo.compare( aValue, bValue, true ) ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If the check is not asymmetrical, recursing with the arguments swapped will verify our result\n\treturn asymmetrical ? true : oo.compare( b, a, true );\n};\n\n/**\n * Create a plain deep copy of any kind of object.\n *\n * Copies are deep, and will either be an object or an array depending on `source`.\n *\n * @param {Object} source Object to copy\n * @param {Function} [leafCallback] Applied to leaf values after they are cloned but before they are added to the clone\n * @param {Function} [nodeCallback] Applied to all values before they are cloned.  If the nodeCallback returns a value other than undefined, the returned value is used instead of attempting to clone.\n * @return {Object} Copy of source object\n */\noo.copy = function ( source, leafCallback, nodeCallback ) {\n\tvar key, destination;\n\n\tif ( nodeCallback ) {\n\t\t// Extensibility: check before attempting to clone source.\n\t\tdestination = nodeCallback( source );\n\t\tif ( destination !== undefined ) {\n\t\t\treturn destination;\n\t\t}\n\t}\n\n\tif ( Array.isArray( source ) ) {\n\t\t// Array (fall through)\n\t\tdestination = new Array( source.length );\n\t} else if ( source && typeof source.clone === 'function' ) {\n\t\t// Duck type object with custom clone method\n\t\treturn leafCallback ? leafCallback( source.clone() ) : source.clone();\n\t} else if ( source && typeof source.cloneNode === 'function' ) {\n\t\t// DOM Node\n\t\treturn leafCallback ?\n\t\t\tleafCallback( source.cloneNode( true ) ) :\n\t\t\tsource.cloneNode( true );\n\t} else if ( oo.isPlainObject( source ) ) {\n\t\t// Plain objects (fall through)\n\t\tdestination = {};\n\t} else {\n\t\t// Non-plain objects (incl. functions) and primitive values\n\t\treturn leafCallback ? leafCallback( source ) : source;\n\t}\n\n\t// source is an array or a plain object\n\tfor ( key in source ) {\n\t\tdestination[ key ] = oo.copy( source[ key ], leafCallback, nodeCallback );\n\t}\n\n\t// This is an internal node, so we don't apply the leafCallback.\n\treturn destination;\n};\n\n/**\n * Generate a hash of an object based on its name and data.\n *\n * Performance optimization: <http://jsperf.com/ve-gethash-201208#/toJson_fnReplacerIfAoForElse>\n *\n * To avoid two objects with the same values generating different hashes, we utilize the replacer\n * argument of JSON.stringify and sort the object by key as it's being serialized. This may or may\n * not be the fastest way to do this; we should investigate this further.\n *\n * Objects and arrays are hashed recursively. When hashing an object that has a .getHash()\n * function, we call that function and use its return value rather than hashing the object\n * ourselves. This allows classes to define custom hashing.\n *\n * @param {Object} val Object to generate hash for\n * @return {string} Hash of object\n */\noo.getHash = function ( val ) {\n\treturn JSON.stringify( val, oo.getHash.keySortReplacer );\n};\n\n/**\n * Sort objects by key (helper function for OO.getHash).\n *\n * This is a callback passed into JSON.stringify.\n *\n * @method getHash_keySortReplacer\n * @param {string} key Property name of value being replaced\n * @param {Mixed} val Property value to replace\n * @return {Mixed} Replacement value\n */\noo.getHash.keySortReplacer = function ( key, val ) {\n\tvar normalized, keys, i, len;\n\tif ( val && typeof val.getHashObject === 'function' ) {\n\t\t// This object has its own custom hash function, use it\n\t\tval = val.getHashObject();\n\t}\n\tif ( !Array.isArray( val ) && Object( val ) === val ) {\n\t\t// Only normalize objects when the key-order is ambiguous\n\t\t// (e.g. any object not an array).\n\t\tnormalized = {};\n\t\tkeys = Object.keys( val ).sort();\n\t\ti = 0;\n\t\tlen = keys.length;\n\t\tfor ( ; i < len; i += 1 ) {\n\t\t\tnormalized[ keys[ i ] ] = val[ keys[ i ] ];\n\t\t}\n\t\treturn normalized;\n\t} else {\n\t\t// Primitive values and arrays get stable hashes\n\t\t// by default. Lets those be stringified as-is.\n\t\treturn val;\n\t}\n};\n\n/**\n * Get the unique values of an array, removing duplicates\n *\n * @param {Array} arr Array\n * @return {Array} Unique values in array\n */\noo.unique = function ( arr ) {\n\treturn arr.reduce( function ( result, current ) {\n\t\tif ( result.indexOf( current ) === -1 ) {\n\t\t\tresult.push( current );\n\t\t}\n\t\treturn result;\n\t}, [] );\n};\n\n/**\n * Compute the union (duplicate-free merge) of a set of arrays.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) in parallel with\n * the array, a new item's existence in the union can be computed faster.\n *\n * @param {...Array} arrays Arrays to union\n * @return {Array} Union of the arrays\n */\noo.simpleArrayUnion = function () {\n\tvar i, ilen, arr, j, jlen,\n\t\tobj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = arguments.length; i < ilen; i++ ) {\n\t\tarr = arguments[ i ];\n\t\tfor ( j = 0, jlen = arr.length; j < jlen; j++ ) {\n\t\t\tif ( !obj[ arr[ j ] ] ) {\n\t\t\t\tobj[ arr[ j ] ] = true;\n\t\t\t\tresult.push( arr[ j ] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Combine arrays (intersection or difference).\n *\n * An intersection checks the item exists in 'b' while difference checks it doesn't.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) of 'b' we can\n * compute the result faster.\n *\n * @private\n * @param {Array} a First array\n * @param {Array} b Second array\n * @param {boolean} includeB Whether to items in 'b'\n * @return {Array} Combination (intersection or difference) of arrays\n */\nfunction simpleArrayCombine( a, b, includeB ) {\n\tvar i, ilen, isInB,\n\t\tbObj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = b.length; i < ilen; i++ ) {\n\t\tbObj[ b[ i ] ] = true;\n\t}\n\n\tfor ( i = 0, ilen = a.length; i < ilen; i++ ) {\n\t\tisInB = !!bObj[ a[ i ] ];\n\t\tif ( isInB === includeB ) {\n\t\t\tresult.push( a[ i ] );\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute the intersection of two arrays (items in both arrays).\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayIntersection = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, true );\n};\n\n/**\n * Compute the difference of two arrays (items in 'a' but not 'b').\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayDifference = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, false );\n};\n\n/* global $ */\n\noo.isPlainObject = $.isPlainObject;\n\n/* global hasOwn */\n\n( function () {\n\n\t/**\n\t * @class OO.EventEmitter\n\t *\n\t * @constructor\n\t */\n\too.EventEmitter = function OoEventEmitter() {\n\t\t// Properties\n\n\t\t/**\n\t\t * Storage of bound event handlers by event name.\n\t\t *\n\t\t * @property\n\t\t */\n\t\tthis.bindings = {};\n\t};\n\n\too.initClass( oo.EventEmitter );\n\n\t/* Private helper functions */\n\n\t/**\n\t * Validate a function or method call in a context\n\t *\n\t * For a method name, check that it names a function in the context object\n\t *\n\t * @private\n\t * @param {Function|string} method Function or method name\n\t * @param {Mixed} context The context of the call\n\t * @throws {Error} A method name is given but there is no context\n\t * @throws {Error} In the context object, no property exists with the given name\n\t * @throws {Error} In the context object, the named property is not a function\n\t */\n\tfunction validateMethod( method, context ) {\n\t\t// Validate method and context\n\t\tif ( typeof method === 'string' ) {\n\t\t\t// Validate method\n\t\t\tif ( context === undefined || context === null ) {\n\t\t\t\tthrow new Error( 'Method name \"' + method + '\" has no context.' );\n\t\t\t}\n\t\t\tif ( typeof context[ method ] !== 'function' ) {\n\t\t\t\t// Technically the property could be replaced by a function before\n\t\t\t\t// call time. But this probably signals a typo.\n\t\t\t\tthrow new Error( 'Property \"' + method + '\" is not a function' );\n\t\t\t}\n\t\t} else if ( typeof method !== 'function' ) {\n\t\t\tthrow new Error( 'Invalid callback. Function or method name expected.' );\n\t\t}\n\t}\n\n\t/**\n\t * @private\n\t * @param {OO.EventEmitter} ee\n\t * @param {Function|string} method Function or method name\n\t * @param {Object} binding\n\t */\n\tfunction addBinding( ee, event, binding ) {\n\t\tvar bindings;\n\t\t// Auto-initialize bindings list\n\t\tif ( hasOwn.call( ee.bindings, event ) ) {\n\t\t\tbindings = ee.bindings[ event ];\n\t\t} else {\n\t\t\tbindings = ee.bindings[ event ] = [];\n\t\t}\n\t\t// Add binding\n\t\tbindings.push( binding );\n\t}\n\n\t/* Methods */\n\n\t/**\n\t * Add a listener to events of a specific event.\n\t *\n\t * The listener can be a function or the string name of a method; if the latter, then the\n\t * name lookup happens at the time the listener is called.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function|string} method Function or method name to call when event occurs\n\t * @param {Array} [args] Arguments to pass to listener, will be prepended to emitted arguments\n\t * @param {Object} [context=null] Context object for function or method call\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.on = function ( event, method, args, context ) {\n\t\tvalidateMethod( method, context );\n\n\t\t// Ensure consistent object shape (optimisation)\n\t\taddBinding( this, event, {\n\t\t\tmethod: method,\n\t\t\targs: args,\n\t\t\tcontext: ( arguments.length < 4 ) ? null : context,\n\t\t\tonce: false\n\t\t} );\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a one-time listener to a specific event.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function} listener Listener to call when event occurs\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.once = function ( event, listener ) {\n\t\tvalidateMethod( listener );\n\n\t\t// Ensure consistent object shape (optimisation)\n\t\taddBinding( this, event, {\n\t\t\tmethod: listener,\n\t\t\targs: undefined,\n\t\t\tcontext: null,\n\t\t\tonce: true\n\t\t} );\n\t\treturn this;\n\t};\n\n\t/**\n\t * Remove a specific listener from a specific event.\n\t *\n\t * @param {string} event Type of event to remove listener from\n\t * @param {Function|string} [method] Listener to remove. Must be in the same form as was passed\n\t * to \"on\". Omit to remove all listeners.\n\t * @param {Object} [context=null] Context object function or method call\n\t * @chainable\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t */\n\too.EventEmitter.prototype.off = function ( event, method, context ) {\n\t\tvar i, bindings;\n\n\t\tif ( arguments.length === 1 ) {\n\t\t\t// Remove all bindings for event\n\t\t\tdelete this.bindings[ event ];\n\t\t\treturn this;\n\t\t}\n\n\t\tvalidateMethod( method, context );\n\n\t\tif ( !hasOwn.call( this.bindings, event ) || !this.bindings[ event ].length ) {\n\t\t\t// No matching bindings\n\t\t\treturn this;\n\t\t}\n\n\t\t// Default to null context\n\t\tif ( arguments.length < 3 ) {\n\t\t\tcontext = null;\n\t\t}\n\n\t\t// Remove matching handlers\n\t\tbindings = this.bindings[ event ];\n\t\ti = bindings.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( bindings[ i ].method === method && bindings[ i ].context === context ) {\n\t\t\t\tbindings.splice( i, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// Cleanup if now empty\n\t\tif ( bindings.length === 0 ) {\n\t\t\tdelete this.bindings[ event ];\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Emit an event.\n\t *\n\t * @param {string} event Type of event\n\t * @param {...Mixed} args First in a list of variadic arguments passed to event handler (optional)\n\t * @return {boolean} Whether the event was handled by at least one listener\n\t */\n\too.EventEmitter.prototype.emit = function ( event ) {\n\t\tvar args = [],\n\t\t\ti, len, binding, bindings, method;\n\n\t\tif ( hasOwn.call( this.bindings, event ) ) {\n\t\t\t// Slicing ensures that we don't get tripped up by event handlers that add/remove bindings\n\t\t\tbindings = this.bindings[ event ].slice();\n\t\t\tfor ( i = 1, len = arguments.length; i < len; i++ ) {\n\t\t\t\targs.push( arguments[ i ] );\n\t\t\t}\n\t\t\tfor ( i = 0, len = bindings.length; i < len; i++ ) {\n\t\t\t\tbinding = bindings[ i ];\n\t\t\t\tif ( typeof binding.method === 'string' ) {\n\t\t\t\t\t// Lookup method by name (late binding)\n\t\t\t\t\tmethod = binding.context[ binding.method ];\n\t\t\t\t} else {\n\t\t\t\t\tmethod = binding.method;\n\t\t\t\t}\n\t\t\t\tif ( binding.once ) {\n\t\t\t\t\t// Must unbind before calling method to avoid\n\t\t\t\t\t// any nested triggers.\n\t\t\t\t\tthis.off( event, method );\n\t\t\t\t}\n\t\t\t\tmethod.apply(\n\t\t\t\t\tbinding.context,\n\t\t\t\t\tbinding.args ? binding.args.concat( args ) : args\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Connect event handlers to an object.\n\t *\n\t * @param {Object} context Object to call methods on when events occur\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} methods List of\n\t *  event bindings keyed by event name containing either method names, functions or arrays containing\n\t *  method name or function followed by a list of arguments to be passed to callback before emitted\n\t *  arguments.\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.connect = function ( context, methods ) {\n\t\tvar method, args, event;\n\n\t\tfor ( event in methods ) {\n\t\t\tmethod = methods[ event ];\n\t\t\t// Allow providing additional args\n\t\t\tif ( Array.isArray( method ) ) {\n\t\t\t\targs = method.slice( 1 );\n\t\t\t\tmethod = method[ 0 ];\n\t\t\t} else {\n\t\t\t\targs = [];\n\t\t\t}\n\t\t\t// Add binding\n\t\t\tthis.on( event, method, args, context );\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Disconnect event handlers from an object.\n\t *\n\t * @param {Object} context Object to disconnect methods from\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} [methods] List of\n\t *  event bindings keyed by event name. Values can be either method names, functions or arrays\n\t *  containing a method name.\n\t *  NOTE: To allow matching call sites with connect(), array values are allowed to contain the\n\t *  parameters as well, but only the method name is used to find bindings. Tt is discouraged to\n\t *  have multiple bindings for the same event to the same listener, but if used (and only the\n\t *  parameters vary), disconnecting one variation of (event name, event listener, parameters)\n\t *  will disconnect other variations as well.\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.disconnect = function ( context, methods ) {\n\t\tvar i, event, method, bindings;\n\n\t\tif ( methods ) {\n\t\t\t// Remove specific connections to the context\n\t\t\tfor ( event in methods ) {\n\t\t\t\tmethod = methods[ event ];\n\t\t\t\tif ( Array.isArray( method ) ) {\n\t\t\t\t\tmethod = method[ 0 ];\n\t\t\t\t}\n\t\t\t\tthis.off( event, method, context );\n\t\t\t}\n\t\t} else {\n\t\t\t// Remove all connections to the context\n\t\t\tfor ( event in this.bindings ) {\n\t\t\t\tbindings = this.bindings[ event ];\n\t\t\t\ti = bindings.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t// bindings[i] may have been removed by the previous step's\n\t\t\t\t\t// this.off so check it still exists\n\t\t\t\t\tif ( bindings[ i ] && bindings[ i ].context === context ) {\n\t\t\t\t\t\tthis.off( event, bindings[ i ].method, context );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n}() );\n\n( function () {\n\n\t/**\n\t * Contain and manage a list of OO.EventEmitter items.\n\t *\n\t * Aggregates and manages their events collectively.\n\t *\n\t * This mixin must be used in a class that also mixes in OO.EventEmitter.\n\t *\n\t * @abstract\n\t * @class OO.EmitterList\n\t * @constructor\n\t */\n\too.EmitterList = function OoEmitterList() {\n\t\tthis.items = [];\n\t\tthis.aggregateItemEvents = {};\n\t};\n\n\t/* Events */\n\n\t/**\n\t * Item has been added\n\t *\n\t * @event add\n\t * @param {OO.EventEmitter} item Added item\n\t * @param {number} index Index items were added at\n\t */\n\n\t/**\n\t * Item has been moved to a new index\n\t *\n\t * @event move\n\t * @param {OO.EventEmitter} item Moved item\n\t * @param {number} index Index item was moved to\n\t * @param {number} oldIndex The original index the item was in\n\t */\n\n\t/**\n\t * Item has been removed\n\t *\n\t * @event remove\n\t * @param {OO.EventEmitter} item Removed item\n\t * @param {number} index Index the item was removed from\n\t */\n\n\t/**\n\t * @event clear The list has been cleared of items\n\t */\n\n\t/* Methods */\n\n\t/**\n\t * Normalize requested index to fit into the bounds of the given array.\n\t *\n\t * @private\n\t * @static\n\t * @param {Array} arr Given array\n\t * @param {number|undefined} index Requested index\n\t * @return {number} Normalized index\n\t */\n\tfunction normalizeArrayIndex( arr, index ) {\n\t\treturn ( index === undefined || index < 0 || index >= arr.length ) ?\n\t\t\tarr.length :\n\t\t\tindex;\n\t}\n\n\t/**\n\t * Get all items.\n\t *\n\t * @return {OO.EventEmitter[]} Items in the list\n\t */\n\too.EmitterList.prototype.getItems = function () {\n\t\treturn this.items.slice( 0 );\n\t};\n\n\t/**\n\t * Get the index of a specific item.\n\t *\n\t * @param {OO.EventEmitter} item Requested item\n\t * @return {number} Index of the item\n\t */\n\too.EmitterList.prototype.getItemIndex = function ( item ) {\n\t\treturn this.items.indexOf( item );\n\t};\n\n\t/**\n\t * Get number of items.\n\t *\n\t * @return {number} Number of items in the list\n\t */\n\too.EmitterList.prototype.getItemCount = function () {\n\t\treturn this.items.length;\n\t};\n\n\t/**\n\t * Check if a list contains no items.\n\t *\n\t * @return {boolean} Group is empty\n\t */\n\too.EmitterList.prototype.isEmpty = function () {\n\t\treturn !this.items.length;\n\t};\n\n\t/**\n\t * Aggregate the events emitted by the group.\n\t *\n\t * When events are aggregated, the group will listen to all contained items for the event,\n\t * and then emit the event under a new name. The new event will contain an additional leading\n\t * parameter containing the item that emitted the original event. Other arguments emitted from\n\t * the original event are passed through.\n\t *\n\t * @param {Object.<string,string|null>} events An object keyed by the name of the event that should be\n\t *  aggregated  (e.g., ‘click’) and the value of the new name to use (e.g., ‘groupClick’).\n\t *  A `null` value will remove aggregated events.\n\n\t * @throws {Error} If aggregation already exists\n\t */\n\too.EmitterList.prototype.aggregate = function ( events ) {\n\t\tvar i, item, add, remove, itemEvent, groupEvent;\n\n\t\tfor ( itemEvent in events ) {\n\t\t\tgroupEvent = events[ itemEvent ];\n\n\t\t\t// Remove existing aggregated event\n\t\t\tif ( Object.prototype.hasOwnProperty.call( this.aggregateItemEvents, itemEvent ) ) {\n\t\t\t\t// Don't allow duplicate aggregations\n\t\t\t\tif ( groupEvent ) {\n\t\t\t\t\tthrow new Error( 'Duplicate item event aggregation for ' + itemEvent );\n\t\t\t\t}\n\t\t\t\t// Remove event aggregation from existing items\n\t\t\t\tfor ( i = 0; i < this.items.length; i++ ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t\tremove = {};\n\t\t\t\t\t\tremove[ itemEvent ] = [ 'emit', this.aggregateItemEvents[ itemEvent ], item ];\n\t\t\t\t\t\titem.disconnect( this, remove );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Prevent future items from aggregating event\n\t\t\t\tdelete this.aggregateItemEvents[ itemEvent ];\n\t\t\t}\n\n\t\t\t// Add new aggregate event\n\t\t\tif ( groupEvent ) {\n\t\t\t\t// Make future items aggregate event\n\t\t\t\tthis.aggregateItemEvents[ itemEvent ] = groupEvent;\n\t\t\t\t// Add event aggregation to existing items\n\t\t\t\tfor ( i = 0; i < this.items.length; i++ ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t\tadd = {};\n\t\t\t\t\t\tadd[ itemEvent ] = [ 'emit', groupEvent, item ];\n\t\t\t\t\t\titem.connect( this, add );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Add items to the list.\n\t *\n\t * @param {OO.EventEmitter|OO.EventEmitter[]} items Item to add or\n\t *  an array of items to add\n\t * @param {number} [index] Index to add items at. If no index is\n\t *  given, or if the index that is given is invalid, the item\n\t *  will be added at the end of the list.\n\t * @chainable\n\t * @fires add\n\t * @fires move\n\t */\n\too.EmitterList.prototype.addItems = function ( items, index ) {\n\t\tvar i, oldIndex;\n\n\t\tif ( !Array.isArray( items ) ) {\n\t\t\titems = [ items ];\n\t\t}\n\n\t\tif ( items.length === 0 ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tindex = normalizeArrayIndex( this.items, index );\n\t\tfor ( i = 0; i < items.length; i++ ) {\n\t\t\toldIndex = this.items.indexOf( items[ i ] );\n\t\t\tif ( oldIndex !== -1 ) {\n\t\t\t\t// Move item to new index\n\t\t\t\tindex = this.moveItem( items[ i ], index );\n\t\t\t\tthis.emit( 'move', items[ i ], index, oldIndex );\n\t\t\t} else {\n\t\t\t\t// insert item at index\n\t\t\t\tindex = this.insertItem( items[ i ], index );\n\t\t\t\tthis.emit( 'add', items[ i ], index );\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Move an item from its current position to a new index.\n\t *\n\t * The item is expected to exist in the list. If it doesn't,\n\t * the method will throw an exception.\n\t *\n\t * @private\n\t * @param {OO.EventEmitter} item Items to add\n\t * @param {number} newIndex Index to move the item to\n\t * @return {number} The index the item was moved to\n\t * @throws {Error} If item is not in the list\n\t */\n\too.EmitterList.prototype.moveItem = function ( item, newIndex ) {\n\t\tvar existingIndex = this.items.indexOf( item );\n\n\t\tif ( existingIndex === -1 ) {\n\t\t\tthrow new Error( 'Item cannot be moved, because it is not in the list.' );\n\t\t}\n\n\t\tnewIndex = normalizeArrayIndex( this.items, newIndex );\n\n\t\t// Remove the item from the current index\n\t\tthis.items.splice( existingIndex, 1 );\n\n\t\t// If necessary, adjust new index after removal\n\t\tif ( existingIndex < newIndex ) {\n\t\t\tnewIndex--;\n\t\t}\n\n\t\t// Move the item to the new index\n\t\tthis.items.splice( newIndex, 0, item );\n\n\t\treturn newIndex;\n\t};\n\n\t/**\n\t * Utility method to insert an item into the list, and\n\t * connect it to aggregate events.\n\t *\n\t * Don't call this directly unless you know what you're doing.\n\t * Use #addItems instead.\n\t *\n\t * This method can be extended in child classes to produce\n\t * different behavior when an item is inserted. For example,\n\t * inserted items may also be attached to the DOM or may\n\t * interact with some other nodes in certain ways. Extending\n\t * this method is allowed, but if overriden, the aggregation\n\t * of events must be preserved, or behavior of emitted events\n\t * will be broken.\n\t *\n\t * If you are extending this method, please make sure the\n\t * parent method is called.\n\t *\n\t * @protected\n\t * @param {OO.EventEmitter} item Items to add\n\t * @param {number} index Index to add items at\n\t * @return {number} The index the item was added at\n\t */\n\too.EmitterList.prototype.insertItem = function ( item, index ) {\n\t\tvar events, event;\n\n\t\t// Add the item to event aggregation\n\t\tif ( item.connect && item.disconnect ) {\n\t\t\tevents = {};\n\t\t\tfor ( event in this.aggregateItemEvents ) {\n\t\t\t\tevents[ event ] = [ 'emit', this.aggregateItemEvents[ event ], item ];\n\t\t\t}\n\t\t\titem.connect( this, events );\n\t\t}\n\n\t\tindex = normalizeArrayIndex( this.items, index );\n\n\t\t// Insert into items array\n\t\tthis.items.splice( index, 0, item );\n\t\treturn index;\n\t};\n\n\t/**\n\t * Remove items.\n\t *\n\t * @param {OO.EventEmitter[]} items Items to remove\n\t * @chainable\n\t * @fires remove\n\t */\n\too.EmitterList.prototype.removeItems = function ( items ) {\n\t\tvar i, item, index;\n\n\t\tif ( !Array.isArray( items ) ) {\n\t\t\titems = [ items ];\n\t\t}\n\n\t\tif ( items.length === 0 ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Remove specific items\n\t\tfor ( i = 0; i < items.length; i++ ) {\n\t\t\titem = items[ i ];\n\t\t\tindex = this.items.indexOf( item );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t// Disconnect all listeners from the item\n\t\t\t\t\titem.disconnect( this );\n\t\t\t\t}\n\t\t\t\tthis.items.splice( index, 1 );\n\t\t\t\tthis.emit( 'remove', item, index );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Clear all items\n\t *\n\t * @chainable\n\t * @fires clear\n\t */\n\too.EmitterList.prototype.clearItems = function () {\n\t\tvar i, item,\n\t\t\tcleared = this.items.splice( 0, this.items.length );\n\n\t\t// Disconnect all items\n\t\tfor ( i = 0; i < cleared.length; i++ ) {\n\t\t\titem = cleared[ i ];\n\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\titem.disconnect( this );\n\t\t\t}\n\t\t}\n\n\t\tthis.emit( 'clear' );\n\n\t\treturn this;\n\t};\n\n}() );\n\n/**\n * Manage a sorted list of OO.EmitterList objects.\n *\n * The sort order is based on a callback that compares two items. The return value of\n * callback( a, b ) must be less than zero if a < b, greater than zero if a > b, and zero\n * if a is equal to b. The callback should only return zero if the two objects are\n * considered equal.\n *\n * When an item changes in a way that could affect their sorting behavior, it must\n * emit the itemSortChange event. This will cause it to be re-sorted automatically.\n *\n * This mixin must be used in a class that also mixes in OO.EventEmitter.\n *\n * @abstract\n * @class OO.SortedEmitterList\n * @mixins OO.EmitterList\n * @constructor\n * @param {Function} sortingCallback Callback that compares two items.\n */\noo.SortedEmitterList = function OoSortedEmitterList( sortingCallback ) {\n\t// Mixin constructors\n\too.EmitterList.call( this );\n\n\tthis.sortingCallback = sortingCallback;\n\n\t// Listen to sortChange event and make sure\n\t// we re-sort the changed item when that happens\n\tthis.aggregate( {\n\t\tsortChange: 'itemSortChange'\n\t} );\n\n\tthis.connect( this, {\n\t\titemSortChange: 'onItemSortChange'\n\t} );\n};\n\noo.mixinClass( oo.SortedEmitterList, oo.EmitterList );\n\n/* Events */\n\n/**\n * An item has changed properties that affect its sort positioning\n * inside the list.\n *\n * @private\n * @event itemSortChange\n */\n\n/* Methods */\n\n/**\n * Handle a case where an item changed a property that relates\n * to its sorted order\n *\n * @param {OO.EventEmitter} item Item in the list\n */\noo.SortedEmitterList.prototype.onItemSortChange = function ( item ) {\n\t// Remove the item\n\tthis.removeItems( item );\n\t// Re-add the item so it is in the correct place\n\tthis.addItems( item );\n};\n\n/**\n * Change the sorting callback for this sorted list.\n *\n * The callback receives two items. The return value of callback(a, b) must be less than zero\n * if a < b, greater than zero if a > b, and zero if a is equal to b.\n *\n * @param {Function} sortingCallback Sorting callback\n */\noo.SortedEmitterList.prototype.setSortingCallback = function ( sortingCallback ) {\n\tvar items = this.getItems();\n\n\tthis.sortingCallback = sortingCallback;\n\n\t// Empty the list\n\tthis.clearItems();\n\t// Re-add the items in the new order\n\tthis.addItems( items );\n};\n\n/**\n * Add items to the sorted list.\n *\n * @chainable\n * @param {OO.EventEmitter|OO.EventEmitter[]} items Item to add or\n *  an array of items to add\n */\noo.SortedEmitterList.prototype.addItems = function ( items ) {\n\tvar index, i, insertionIndex;\n\n\tif ( !Array.isArray( items ) ) {\n\t\titems = [ items ];\n\t}\n\n\tif ( items.length === 0 ) {\n\t\treturn this;\n\t}\n\n\tfor ( i = 0; i < items.length; i++ ) {\n\t\t// Find insertion index\n\t\tinsertionIndex = this.findInsertionIndex( items[ i ] );\n\n\t\t// Check if the item exists using the sorting callback\n\t\t// and remove it first if it exists\n\t\tif (\n\t\t\t// First make sure the insertion index is not at the end\n\t\t\t// of the list (which means it does not point to any actual\n\t\t\t// items)\n\t\t\tinsertionIndex <= this.items.length &&\n\t\t\t// Make sure there actually is an item in this index\n\t\t\tthis.items[ insertionIndex ] &&\n\t\t\t// The callback returns 0 if the items are equal\n\t\t\tthis.sortingCallback( this.items[ insertionIndex ], items[ i ] ) === 0\n\t\t) {\n\t\t\t// Remove the existing item\n\t\t\tthis.removeItems( this.items[ insertionIndex ] );\n\t\t}\n\n\t\t// Insert item at the insertion index\n\t\tindex = this.insertItem( items[ i ], insertionIndex );\n\t\tthis.emit( 'add', items[ i ], index );\n\t}\n\n\treturn this;\n};\n\n/**\n * Find the index a given item should be inserted at. If the item is already\n * in the list, this will return the index where the item currently is.\n *\n * @param {OO.EventEmitter} item Items to insert\n * @return {number} The index the item should be inserted at\n */\noo.SortedEmitterList.prototype.findInsertionIndex = function ( item ) {\n\tvar list = this;\n\n\treturn oo.binarySearch(\n\t\tthis.items,\n\t\t// Fake a this.sortingCallback.bind( null, item ) call here\n\t\t// otherwise this doesn't pass tests in phantomJS\n\t\tfunction ( otherItem ) {\n\t\t\treturn list.sortingCallback( item, otherItem );\n\t\t},\n\t\ttrue\n\t);\n\n};\n\n/* global hasOwn */\n\n/**\n * @class OO.Registry\n * @mixins OO.EventEmitter\n *\n * @constructor\n */\noo.Registry = function OoRegistry() {\n\t// Mixin constructors\n\too.EventEmitter.call( this );\n\n\t// Properties\n\tthis.registry = {};\n};\n\n/* Inheritance */\n\noo.mixinClass( oo.Registry, oo.EventEmitter );\n\n/* Events */\n\n/**\n * @event register\n * @param {string} name\n * @param {Mixed} data\n */\n\n/**\n * @event unregister\n * @param {string} name\n * @param {Mixed} data Data removed from registry\n */\n\n/* Methods */\n\n/**\n * Associate one or more symbolic names with some data.\n *\n * Any existing entry with the same name will be overridden.\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @param {Mixed} data Data to associate with symbolic name\n * @fires register\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.register = function ( name, data ) {\n\tvar i, len;\n\tif ( typeof name === 'string' ) {\n\t\tthis.registry[ name ] = data;\n\t\tthis.emit( 'register', name, data );\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.register( name[ i ], data );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Remove one or more symbolic names from the registry\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @fires unregister\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.unregister = function ( name ) {\n\tvar i, len, data;\n\tif ( typeof name === 'string' ) {\n\t\tdata = this.lookup( name );\n\t\tif ( data !== undefined ) {\n\t\t\tdelete this.registry[ name ];\n\t\t\tthis.emit( 'unregister', name, data );\n\t\t}\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.unregister( name[ i ] );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Get data for a given symbolic name.\n *\n * @param {string} name Symbolic name\n * @return {Mixed|undefined} Data associated with symbolic name\n */\noo.Registry.prototype.lookup = function ( name ) {\n\tif ( hasOwn.call( this.registry, name ) ) {\n\t\treturn this.registry[ name ];\n\t}\n};\n\n/**\n * @class OO.Factory\n * @extends OO.Registry\n *\n * @constructor\n */\noo.Factory = function OoFactory() {\n\t// Parent constructor\n\too.Factory.super.call( this );\n};\n\n/* Inheritance */\n\noo.inheritClass( oo.Factory, oo.Registry );\n\n/* Methods */\n\n/**\n * Register a constructor with the factory.\n *\n * Classes must have a static `name` property to be registered.\n *\n *     function MyClass() {};\n *     OO.initClass( MyClass );\n *     // Adds a static property to the class defining a symbolic name\n *     MyClass.static.name = 'mine';\n *     // Registers class with factory, available via symbolic name 'mine'\n *     factory.register( MyClass );\n *\n * @param {Function} constructor Constructor to use when creating object\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.register = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.super.prototype.register.call( this, name, constructor );\n};\n\n/**\n * Unregister a constructor from the factory.\n *\n * @param {Function} constructor Constructor to unregister\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.unregister = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.super.prototype.unregister.call( this, name );\n};\n\n/**\n * Create an object based on a name.\n *\n * Name is used to look up the constructor to use, while all additional arguments are passed to the\n * constructor directly, so leaving one out will pass an undefined to the constructor.\n *\n * @param {string} name Object name\n * @param {...Mixed} [args] Arguments to pass to the constructor\n * @return {Object} The new object\n * @throws {Error} Unknown object name\n */\noo.Factory.prototype.create = function ( name ) {\n\tvar obj, i,\n\t\targs = [],\n\t\tconstructor = this.lookup( name );\n\n\tif ( !constructor ) {\n\t\tthrow new Error( 'No class registered by that name: ' + name );\n\t}\n\n\t// Convert arguments to array and shift the first argument (name) off\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\targs.push( arguments[ i ] );\n\t}\n\n\t// We can't use the \"new\" operator with .apply directly because apply needs a\n\t// context. So instead just do what \"new\" does: create an object that inherits from\n\t// the constructor's prototype (which also makes it an \"instanceof\" the constructor),\n\t// then invoke the constructor with the object as context, and return it (ignoring\n\t// the constructor's return value).\n\tobj = Object.create( constructor.prototype );\n\tconstructor.apply( obj, args );\n\treturn obj;\n};\n\n/* eslint-env node */\n\n/* istanbul ignore next */\nif ( typeof module !== 'undefined' && module.exports ) {\n\tmodule.exports = oo;\n} else {\n\tglobal.OO = oo;\n}\n\n}( this ) );\n"]}