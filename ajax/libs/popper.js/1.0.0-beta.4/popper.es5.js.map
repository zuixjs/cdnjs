{"version":3,"file":null,"sources":["../src/popper/utils/getOffsetParent.js","../src/popper/utils/getStyleComputedProperty.js","../src/popper/utils/getParentNode.js","../src/popper/utils/getScrollParent.js","../src/popper/utils/getWindowSizes.js","../src/popper/utils/getOffsetRect.js","../src/popper/utils/isFixed.js","../src/popper/utils/getPosition.js","../src/popper/utils/getBoundingClientRect.js","../src/popper/utils/getScroll.js","../src/popper/utils/getOffsetRectRelativeToCustomParent.js","../src/popper/utils/getTotalScroll.js","../src/popper/utils/getBoundaries.js","../src/popper/utils/computeAutoPlacement.js","../src/popper/utils/isNative.js","../src/popper/utils/debounce.js","../src/popper/utils/findIndex.js","../src/popper/utils/getClientRect.js","../src/popper/utils/getOuterSizes.js","../src/popper/utils/getOppositePlacement.js","../src/popper/utils/getPopperOffsets.js","../src/popper/utils/getReferenceOffsets.js","../src/popper/utils/getSupportedPropertyName.js","../src/popper/utils/isFunction.js","../src/popper/utils/isModifierEnabled.js","../src/popper/utils/isModifierRequired.js","../src/popper/utils/isNumeric.js","../src/popper/utils/isTransformed.js","../src/popper/utils/removeEventListeners.js","../src/popper/utils/runModifiers.js","../src/popper/utils/setAttributes.js","../src/popper/utils/setStyles.js","../src/popper/utils/setupEventListeners.js","../src/popper/utils/index.js","../src/popper/modifiers/applyStyle.js","../src/popper/modifiers/arrow.js","../src/popper/utils/getOppositeVariation.js","../src/popper/modifiers/flip.js","../src/popper/modifiers/keepTogether.js","../src/popper/modifiers/offset.js","../src/popper/modifiers/preventOverflow.js","../src/popper/modifiers/shift.js","../src/popper/modifiers/hide.js","../src/popper/modifiers/inner.js","../src/popper/modifiers/index.js","../src/popper/index.js"],"sourcesContent":["/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nexport default function getOffsetParent(element) {\n    // NOTE: 1 DOM access here\n    const offsetParent = element.offsetParent;\n\n    if(!offsetParent || offsetParent.nodeName === 'BODY' || offsetParent.nodeName === 'HTML') {\n        return window.document.documentElement;\n    }\n\n    return offsetParent;\n}\n","/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nexport default function getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n        return [];\n    }\n    // NOTE: 1 DOM access here\n    const css = window.getComputedStyle(element, null);\n    return property ? css[property] : css;\n}\n","/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nexport default function getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n        return element;\n    }\n    return element.parentNode || element.host;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nexport default function getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element || ['HTML', 'BODY', '#document'].indexOf(element.nodeName) !== -1) {\n        return window.document.body;\n    }\n\n    // Firefox want us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getStyleComputedProperty(element);\n    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {\n        return element;\n    }\n\n    return getScrollParent(getParentNode(element));\n}\n","export default function getWindowSizes() {\n    const body = window.document.body;\n    const html = window.document.documentElement;\n    return {\n        height: Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight),\n        width: Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth),\n    };\n}\n","import getWindowSizes from './getWindowSizes';\n\n/**\n * Get the position of the given element, relative to its offset parent\n * @method\n * @memberof Popper.Utils\n * @param {Element} element\n * @return {Object} position - Coordinates of the element and its `scrollTop`\n */\nexport default function getOffsetRect(element) {\n    let elementRect;\n    if (element.nodeName === 'HTML') {\n        const { width, height } = getWindowSizes();\n        elementRect = {\n            width,\n            height,\n            left: 0,\n            top: 0,\n        };\n    }\n    else {\n        elementRect = {\n            width: element.offsetWidth,\n            height: element.offsetHeight,\n            left: element.offsetLeft,\n            top: element.offsetTop,\n        };\n    }\n\n    elementRect.right = elementRect.left + elementRect.width;\n    elementRect.bottom = elementRect.top + elementRect.height;\n\n    // position\n    return elementRect;\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nexport default function isFixed(element) {\n    if (element.nodeName === 'BODY' || element.nodeName === 'HTML') {\n        return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n        return true;\n    }\n    return isFixed(getParentNode(element));\n}\n","import getOffsetParent from './getOffsetParent';\nimport isFixed from './isFixed';\n\n/**\n * Helper used to get the position which will be applied to the popper\n * @method\n * @memberof Popper.Utils\n * @param config {HTMLElement} popper element\n * @returns {HTMLElement} reference element\n */\nexport default function getPosition(element) {\n    const container = getOffsetParent(element);\n\n    // Decide if the popper will be fixed\n    // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n    const isParentFixed = isFixed(container);\n    return isParentFixed ? 'fixed' : 'absolute';\n}\n","/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nexport default function getBoundingClientRect(element) {\n    let rect = element.getBoundingClientRect();\n\n    const result = {\n        left: rect.left,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top,\n    };\n\n    // IE10 FIX: `getBoundingClientRect`, when executed on `documentElement`\n    // will not take in account the `scrollTop` and `scrollLeft`\n    if (element.nodeName === 'HTML' && navigator.appVersion.indexOf('MSIE 10') !== -1) {\n        const { scrollTop, scrollLeft } = window.document.documentElement;\n        result.top -= scrollTop;\n        result.bottom -= scrollTop;\n        result.left -= scrollLeft;\n        result.right -= scrollLeft;\n    }\n\n    // subtract scrollbar size from sizes\n    const horizScrollbar = rect.width - (element.clientWidth || rect.right - rect.left);\n    const vertScrollbar = rect.height - (element.clientHeight || rect.bottom - rect.top);\n\n    result.right -= horizScrollbar;\n    result.width -= horizScrollbar;\n    result.bottom -= vertScrollbar;\n    result.height -= vertScrollbar;\n\n    return result;\n}\n","export default function getScroll(element, side = 'top') {\n    const upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n\n    if (element.nodeName === 'BODY' || element.nodeName === 'HTML') {\n        const html = window.document.documentElement;\n        const scrollingElement = window.document.scrollingElement || html;\n        return scrollingElement[upperSide];\n    }\n\n    return element[upperSide];\n}\n","import getBoundingClientRect from './getBoundingClientRect';\nimport getScrollParent from './getScrollParent';\nimport getScroll from './getScroll';\nimport getOffsetParent from './getOffsetParent';\n\n/**\n * Given an element and one of its parents, return the offset\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @param {HTMLElement} parent\n * @return {Object} rect\n */\nexport default function getOffsetRectRelativeToCustomParent(element, parent, fixed = false, transformed = false) {\n    const scrollParent = getScrollParent(parent);\n    const elementRect = getBoundingClientRect(element);\n    const parentRect = getBoundingClientRect(parent);\n\n    const rect = {\n        top: elementRect.top - parentRect.top,\n        left: elementRect.left - parentRect.left,\n        bottom: (elementRect.top - parentRect.top) + elementRect.height,\n        right: (elementRect.left - parentRect.left) + elementRect.width,\n        width: elementRect.width,\n        height: elementRect.height,\n    };\n\n    if (fixed && !transformed) {\n        const scrollTop = getScroll(scrollParent, 'top');\n        const scrollLeft = getScroll(scrollParent, 'left');\n        rect.top -= scrollTop;\n        rect.bottom -= scrollTop;\n        rect.left -= scrollLeft;\n        rect.right -= scrollLeft;\n    } else if (getOffsetParent(element).contains(scrollParent)) {\n        const scrollTop = getScroll(parent, 'top');\n        const scrollLeft = getScroll(parent, 'left');\n        rect.top += scrollTop;\n        rect.bottom += scrollTop;\n        rect.left += scrollLeft;\n        rect.right += scrollLeft;\n    }\n\n    return rect;\n}\n","import getScrollParent from './getScrollParent';\nimport getScroll from './getScroll';\nimport getParentNode from './getParentNode';\n\nexport default function getTotalScroll(element, side = 'top') {\n    const scrollParent = getScrollParent(element);\n    const scroll = getScroll(scrollParent, side);\n\n    if (['BODY', 'HTML'].indexOf(scrollParent.nodeName) === -1) {\n        return scroll + getTotalScroll(getParentNode(scrollParent), side);\n    }\n    return scroll;\n}\n","import getOffsetParent from './getOffsetParent';\nimport getScrollParent from './getScrollParent';\nimport getOffsetRect from './getOffsetRect';\nimport getPosition from './getPosition';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\nimport getTotalScroll from './getTotalScroll';\nimport isFixed from './isFixed';\nimport getWindowSizes from './getWindowSizes';\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n * @param {Number} padding - Boundaries padding\n * @param {Element} boundariesElement - Element used to define the boundaries\n * @returns {Object} Coordinates of the boundaries\n */\nexport default function getBoundaries(popper, padding, boundariesElement) {\n    // NOTE: 1 DOM access here\n    let boundaries = { top: 0, left: 0 };\n    const offsetParent = getOffsetParent(popper);\n\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n        const { left, top } = getOffsetRect(offsetParent);\n        const { clientWidth: width, clientHeight: height } = window.document.documentElement;\n\n        if (getPosition(popper) === 'fixed') {\n            boundaries.right = width;\n            boundaries.bottom = height;\n        } else {\n            const scrollLeft = getTotalScroll(popper, 'left');\n            const scrollTop = getTotalScroll(popper, 'top');\n\n            boundaries = {\n                top: 0 - top,\n                right: width - left + scrollLeft,\n                bottom: height - top + scrollTop,\n                left: 0 - left,\n            };\n        }\n    }\n    // Handle other cases based on DOM element used as boundaries\n    else {\n        let boundariesNode;\n        if (boundariesElement === 'scrollParent') {\n            boundariesNode = getScrollParent(popper);\n        } else if (boundariesElement === 'window') {\n            boundariesNode = window.document.body;\n        } else {\n            boundariesNode = boundariesElement;\n        }\n\n        // In case of BODY, we need a different computation\n        if (boundariesNode.nodeName === 'BODY') {\n            const { height, width } = getWindowSizes();\n            boundaries.right = width;\n            boundaries.bottom = height;\n        }\n        // for all the other DOM elements, this one is good\n        else {\n            boundaries = getOffsetRectRelativeToCustomParent(boundariesNode, offsetParent, isFixed(popper));\n        }\n    }\n\n    // Add paddings\n    boundaries.left += padding;\n    boundaries.top += padding;\n    boundaries.right -= padding;\n    boundaries.bottom -= padding;\n\n    return boundaries;\n}\n","import getBoundaries from '../utils/getBoundaries';\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function computeAutoPlacement(placement, referenceOffsets, popper) {\n    if (placement.indexOf('auto') === -1) {\n        return placement;\n    }\n\n    const refRect = referenceOffsets;\n    const boundaries = getBoundaries(popper, 0, 'scrollParent');\n\n    const sides = {\n        top: refRect.top - boundaries.top,\n        right: boundaries.right - refRect.right,\n        bottom: boundaries.bottom - refRect.bottom,\n        left: refRect.left - boundaries.left,\n    };\n\n    const computedPlacement = Object.keys(sides).sort((a, b) => sides[b] - sides[a])[0];\n    const variation = placement.split('-')[1];\n\n    return computedPlacement + (variation ? `-${variation}` : '');\n}\n","const nativeHints = [\n    'native code',\n    '[object MutationObserverConstructor]' // for mobile safari iOS 9.0\n];\n\n/**\n * Determine if a function is implemented natively (as opposed to a polyfill).\n * @argument {Function | undefined} fn the function to check\n * @returns {boolean}\n */\nexport default fn => nativeHints.some(hint => (fn || '').toString().indexOf(hint) > -1);","import isNative from './isNative';\n\nconst longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\nlet timeoutDuration = 0;\nfor (let i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n  if (navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n    timeoutDuration = 1;\n    break;\n  }\n}\n\nfunction microtaskDebounce(fn) {\n  let scheduled = false;\n  let i = 0;\n  const elem = document.createElement('span');\n\n  // MutationObserver provides a mechanism for scheduling microtasks, which\n  // are scheduled *before* the next task. This gives us a way to debounce\n  // a function but ensure it's called *before* the next paint.\n  const observer = new MutationObserver(() => {\n    fn();\n    scheduled = false;\n  });\n\n  observer.observe(elem, { childList: true });\n\n  return () => {\n    if (!scheduled) {\n      scheduled = true;\n      elem.textContent = `${i}`;\n      i += 1;\n    }\n  };\n}\n\nfunction taskDebounce(fn) {\n  let scheduled = false;\n  return () => {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(() => {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\n// It's common for MutationObserver polyfills to be seen in the wild, however\n// these rely on Mutation Events which only occur when an element is connected\n// to the DOM. The algorithm used in this module does not use a connected element,\n// and so we must ensure that a *native* MutationObserver is available.\nconst supportsNativeMutationObserver = isNative(window.MutationObserver);\n\n/**\n * Create a debounced version of a method, that's asynchronously deferred\n * but called in the minimum time possible.\n *\n * @method\n * @memberof Popper.Utils\n * @argument {Function} fn\n * @returns {Function}\n */\nexport default supportsNativeMutationObserver ? microtaskDebounce : taskDebounce;\n","/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nexport default function findIndex(arr, prop, value) {\n    // use filter instead of find because find has less cross-browser support\n    const match = arr.filter((obj) => (obj[prop] === value))[0];\n    return arr.indexOf(match);\n}\n","/**\n * Given the popper offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} popperOffsets\n * @returns {Object} ClientRect like output\n */\nexport default function getClientRect(popperOffsets) {\n    return {\n        ...popperOffsets,\n        right: popperOffsets.left + popperOffsets.width,\n        bottom: popperOffsets.top + popperOffsets.height,\n    };\n}\n","/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nexport default function getOuterSizes(element) {\n    // NOTE: 1 DOM access here\n    const display = element.style.display;\n    const visibility = element.style.visibility;\n\n    element.style.display = 'block';\n    element.style.visibility = 'hidden';\n\n    // original method\n    const styles = window.getComputedStyle(element);\n    const x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    const y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    const result = {\n        width: element.offsetWidth + y,\n        height: element.offsetHeight + x\n    };\n\n    // reset element styles\n    element.style.display = display;\n    element.style.visibility = visibility;\n\n    return result;\n}\n","/**\n * Get the opposite placement of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nexport default function getOppositePlacement(placement) {\n    const hash = {left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n    return placement.replace(/left|right|bottom|top/g, (matched) => hash[matched]);\n}\n","import getOuterSizes from './getOuterSizes';\nimport getOppositePlacement from './getOppositePlacement';\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nexport default function getPopperOffsets(state, popper, referenceOffsets, placement) {\n    placement = placement.split('-')[0];\n\n    // Get popper node sizes\n    const popperRect = getOuterSizes(popper);\n\n    // Add position, width and height to our offsets object\n    const popperOffsets = {\n        position: state.position,\n        width: popperRect.width,\n        height: popperRect.height,\n    };\n\n    // depending by the popper placement we have to compute its offsets slightly differently\n    const isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    const mainSide = isHoriz ? 'top' : 'left';\n    const secondarySide = isHoriz ? 'left' : 'top';\n    const measurement = isHoriz ? 'height' : 'width';\n    const secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n    if (placement === secondarySide) {\n        popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n    } else {\n        popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n    }\n\n    return popperOffsets;\n}\n","import getOffsetParent from './getOffsetParent';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nexport default function getReferenceOffsets(state, popper, reference) {\n    const isParentFixed = state.position === 'fixed';\n    const isParentTransformed = state.isParentTransformed;\n    const offsetParent = getOffsetParent((isParentFixed && isParentTransformed) ? reference : popper);\n\n    return getOffsetRectRelativeToCustomParent(reference, offsetParent, isParentFixed, isParentTransformed);\n}\n","/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase)\n */\nexport default function getSupportedPropertyName(property) {\n    const prefixes = ['', 'ms', 'webkit', 'moz', 'o'];\n    const upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n    prefixes.forEach((prefix) => {\n        const toCheck = prefix ? `${prefix}${upperProp}` : property;\n        if (typeof window.document.body.style[toCheck] !== 'undefined') {\n            return toCheck;\n        }\n    });\n    return null;\n}\n","/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to check\n * @returns {Boolean} answer to: is a function?\n */\nexport default function isFunction(functionToCheck) {\n    const getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n","/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\n export default function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(({ name, enabled }) => name === modifierName && enabled);\n}\n","/**\n * Helper used to know if the given modifier depends from another one.\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nexport default function isModifierRequired(modifiers, requestingName, requestedName) {\n    // find is not supported by IE\n    const requesting = modifiers.filter(({ name }) => name === requestingName)[0];\n\n    return !!requesting && modifiers.some((modifier) => {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n}\n","/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nexport default function isNumeric(n) {\n    return (n !== '' && !isNaN(parseFloat(n)) && isFinite(n));\n}\n","import getStyleComputedProperty from './getStyleComputedProperty';\nimport getParentNode from './getParentNode';\n\n/**\n * Check if the given element has transforms applied to itself or a parent\n * @method\n * @memberof Popper.Utils\n * @param  {Element} element\n * @return {Boolean} answer to \"isTransformed?\"\n */\nexport default function isTransformed(element) {\n  if (element.nodeName === 'BODY') {\n      return false;\n  }\n  if (getStyleComputedProperty(element, 'transform') !== 'none') {\n      return true;\n  }\n  return getParentNode(element) ? isTransformed(getParentNode(element)) : element;\n}\n","/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function removeEventListeners(reference, state) {\n    // NOTE: 1 DOM access here\n    window.removeEventListener('resize', state.updateBound);\n    if (state.scrollElement) {\n        state.scrollElement.removeEventListener('scroll', state.updateBound);\n    }\n    state.updateBound = null;\n    state.scrollElement = null;\n    state.eventsEnabled = false;\n    return state;\n}\n","import isFunction from './isFunction';\nimport findIndex from './findIndex';\n\n/**\n * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n * @method\n * @memberof Popper.Utils\n * @param {Object} data\n * @param {Array} modifiers\n * @param {Function} ends\n */\nexport default function runModifiers(modifiers, data, ends) {\n    const modifiersToRun = (ends === undefined) ?\n          modifiers :\n          modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n    modifiersToRun.forEach((modifier) => {\n        if (modifier.enabled && isFunction(modifier.function)) {\n            data = modifier.function(data, modifier);\n        }\n    });\n\n    return data;\n}\n","/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nexport default function setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function(prop) {\n        const value = attributes[prop];\n        if (value !== false) {\n            element.setAttribute(prop, attributes[prop]);\n        } else {\n            element.removeAttribute(prop);\n        }\n    });\n}\n","import isNumeric from './isNumeric';\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n */\nexport default function setStyles(element, styles) {\n    Object.keys(styles).forEach(function(prop) {\n        let unit = '';\n        // add unit if the value is numeric and is one of the following\n        if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n            unit = 'px';\n        }\n        element.style[prop] = styles[prop] + unit;\n    });\n}\n","import getScrollParent from './getScrollParent';\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nexport default function setupEventListeners(reference, options, state, updateBound) {\n    // NOTE: 1 DOM access here\n    state.updateBound = updateBound;\n    window.addEventListener('resize', state.updateBound, { passive: true });\n    let target = getScrollParent(reference);\n    if (target.nodeName === 'BODY') {\n        target = window;\n    }\n    target.addEventListener('scroll', state.updateBound, { passive: true });\n    state.scrollElement = target;\n    state.eventsEnabled = true;\n\n    return state;\n}\n","import computeAutoPlacement from './computeAutoPlacement';\nimport debounce from './debounce';\nimport findIndex from './findIndex';\nimport getBoundaries from './getBoundaries';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getClientRect from './getClientRect';\nimport getOffsetParent from './getOffsetParent';\nimport getOffsetRect from './getOffsetRect';\nimport getOffsetRectRelativeToCustomParent from './getOffsetRectRelativeToCustomParent';\nimport getOuterSizes from './getOuterSizes';\nimport getParentNode from './getParentNode';\nimport getPopperOffsets from './getPopperOffsets';\nimport getPosition from './getPosition';\nimport getReferenceOffsets from './getReferenceOffsets';\nimport getScroll from './getScroll';\nimport getScrollParent from './getScrollParent';\nimport getStyleComputedProperty from './getStyleComputedProperty';\nimport getSupportedPropertyName from './getSupportedPropertyName';\nimport getTotalScroll from './getTotalScroll';\nimport getWindowSizes from './getWindowSizes';\nimport isFixed from './isFixed';\nimport isFunction from './isFunction';\nimport isModifierEnabled from './isModifierEnabled';\nimport isModifierRequired from './isModifierRequired';\nimport isNative from './isNative';\nimport isNumeric from './isNumeric';\nimport isTransformed from './isTransformed';\nimport removeEventListeners from './removeEventListeners';\nimport runModifiers from './runModifiers';\nimport setAttributes from './setAttributes';\nimport setStyles from './setStyles';\nimport setupEventListeners from './setupEventListeners';\n\n/** @namespace Popper.Utils */\nexport default {\n    computeAutoPlacement,\n    debounce,\n    findIndex,\n    getBoundaries,\n    getBoundingClientRect,\n    getClientRect,\n    getOffsetParent,\n    getOffsetRect,\n    getOffsetRectRelativeToCustomParent,\n    getOuterSizes,\n    getParentNode,\n    getPopperOffsets,\n    getPosition,\n    getReferenceOffsets,\n    getScroll,\n    getScrollParent,\n    getStyleComputedProperty,\n    getSupportedPropertyName,\n    getTotalScroll,\n    getWindowSizes,\n    isFixed,\n    isFunction,\n    isModifierEnabled,\n    isModifierRequired,\n    isNative,\n    isNumeric,\n    isTransformed,\n    removeEventListeners,\n    runModifiers,\n    setAttributes,\n    setStyles,\n    setupEventListeners,\n};\n","import getSupportedPropertyName from '../utils/getSupportedPropertyName';\nimport setStyles from '../utils/setStyles';\nimport setAttributes from '../utils/setAttributes';\nimport getReferenceOffsets from '../utils/getReferenceOffsets';\nimport computeAutoPlacement from '../utils/computeAutoPlacement';\n\n/**\n * Apply the computed styles to the popper element\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nexport default function applyStyle(data, options) {\n    // apply the final offsets to the popper\n    // NOTE: 1 DOM access here\n    const styles = {\n        position: data.offsets.popper.position\n    };\n\n    const attributes = {\n        'x-placement': data.placement,\n    };\n\n    // round top and left to avoid blurry text\n    const left = Math.round(data.offsets.popper.left);\n    const top = Math.round(data.offsets.popper.top);\n\n    // if gpuAcceleration is set to true and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n    const prefixedProperty = getSupportedPropertyName('transform');\n    if (options.gpuAcceleration && prefixedProperty) {\n        styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n        styles.top = 0;\n        styles.left = 0;\n    }\n    // othwerise, we use the standard `left` and `top` properties\n    else {\n        styles.left =left;\n        styles.top = top;\n    }\n\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    setStyles(data.instance.popper, {...styles, ...data.styles});\n\n    // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n    setAttributes(data.instance.popper, {...attributes, ...data.attributes});\n\n    // if the arrow style has been computed, apply the arrow style\n    if (data.offsets.arrow) {\n        setStyles(data.arrowElement, data.offsets.arrow);\n    }\n\n    return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used to add margins to the popper\n * margins needs to be calculated to get the correct popper offsets\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options - Popper.js options\n */\nexport function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    // compute reference element offsets\n    const referenceOffsets = getReferenceOffsets(state, popper, reference);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    options.placement = computeAutoPlacement(options.placement, referenceOffsets, popper);\n\n    popper.setAttribute('x-placement', options.placement);\n    return options;\n}\n","import getClientRect from '../utils/getClientRect';\nimport getOuterSizes from '../utils/getOuterSizes';\nimport isModifierRequired from '../utils/isModifierRequired';\n\n/**\n * Modifier used to move the arrowEls on the edge of the popper to make sure them are always between the popper and the reference element\n * It will use the CSS outer size of the arrowEl element to know how many pixels of conjuction are needed\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function arrow(data, options) {\n    let arrowEl  = options.element;\n\n    // if the arrowElElement is a string, suppose it's a CSS selector\n    if (typeof arrowEl === 'string') {\n        arrowEl = data.instance.popper.querySelector(arrowEl);\n    }\n\n    // if arrowEl element is not found, don't run the modifier\n    if (!arrowEl) {\n        return data;\n    }\n\n    // the arrowEl element must be child of its popper\n    if (!data.instance.popper.contains(arrowEl)) {\n        console.warn('WARNING: `arrowElElement` must be child of its popper element!');\n        return data;\n    }\n\n    // arrowEl depends on keepTogether in order to work\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n        console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');\n        return data;\n    }\n\n    const arrowElStyle  = {};\n    const placement     = data.placement.split('-')[0];\n    const popper        = getClientRect(data.offsets.popper);\n    const reference     = data.offsets.reference;\n    const isVertical    = ['left', 'right'].indexOf(placement) !== -1;\n\n    const len           = isVertical ? 'height' : 'width';\n    const side          = isVertical ? 'top' : 'left';\n    const altSide       = isVertical ? 'left' : 'top';\n    const opSide        = isVertical ? 'bottom' : 'right';\n    const arrowElSize   = getOuterSizes(arrowEl)[len];\n\n    //\n    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n    //\n\n    // top/left side\n    if (reference[opSide] - arrowElSize < popper[side]) {\n        data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElSize);\n    }\n    // bottom/right side\n    if (reference[side] + arrowElSize > popper[opSide]) {\n        data.offsets.popper[side] += (reference[side] + arrowElSize) - popper[opSide];\n    }\n\n    // compute center of the popper\n    const center = reference[side] + (reference[len] / 2) - (arrowElSize / 2);\n\n    // Compute the sideValue using the updated popper offsets\n    let sideValue = center - getClientRect(data.offsets.popper)[side];\n\n    // prevent arrowEl from being placed not contiguously to its popper\n    sideValue = Math.max(Math.min(popper[len] - arrowElSize, sideValue), 0);\n    arrowElStyle[side] = sideValue;\n    arrowElStyle[altSide] = ''; // make sure to remove any old style from the arrowEl\n\n    data.offsets.arrow = arrowElStyle;\n    data.arrowElement = arrowEl;\n\n    return data;\n}\n","/**\n * Get the opposite placement variation of the given one/\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nexport default function getOppositeVariation(variation) {\n    if (variation === 'end') {\n        return 'start';\n    } else if (variation === 'start') {\n        return 'end';\n    }\n    return variation;\n}\n","import getOppositePlacement from '../utils/getOppositePlacement';\nimport getOppositeVariation from '../utils/getOppositeVariation';\nimport getClientRect from '../utils/getClientRect';\nimport getPopperOffsets from '../utils/getPopperOffsets';\nimport runModifiers from '../utils/runModifiers';\nimport getBoundaries from '../utils/getBoundaries';\nimport isModifierEnabled from '../utils/isModifierEnabled';\n\n/**\n * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n * Requires the `preventOverflow` modifier before it in order to work.\n * **NOTE:** data.instance modifier will run all its previous modifiers everytime it tries to flip the popper!\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function flip(data, options) {\n    // if `inner` modifier is enabled, we can't use the `flip` modifier\n    if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n        return data;\n    }\n\n    if (data.flipped && data.placement === data.originalPlacement) {\n        // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n        return data;\n    }\n\n    const boundaries = getBoundaries(data.instance.popper, options.padding, options.boundariesElement);\n\n    let placement = data.placement.split('-')[0];\n    let placementOpposite = getOppositePlacement(placement);\n    let variation = data.placement.split('-')[1] || '';\n\n    let flipOrder = [];\n\n    if (options.behavior === 'flip') {\n        flipOrder = [\n            placement,\n            placementOpposite\n        ];\n    } else {\n        flipOrder = options.behavior;\n    }\n\n    flipOrder.forEach((step, index) => {\n        if (placement !== step || flipOrder.length === index + 1) {\n            return data;\n        }\n\n        placement = data.placement.split('-')[0];\n        placementOpposite = getOppositePlacement(placement);\n\n        const popperOffsets = getClientRect(data.offsets.popper);\n        const refOffsets = data.offsets.reference;\n\n        // using Math.floor because the reference offsets may contain decimals we are not going to consider here\n        const overlapsRef = (\n            (placement === 'left'   && Math.floor(popperOffsets.right) > Math.floor(refOffsets.left)) ||\n            (placement === 'right'  && Math.floor(popperOffsets.left) < Math.floor(refOffsets.right)) ||\n            (placement === 'top'    && Math.floor(popperOffsets.bottom) > Math.floor(refOffsets.top)) ||\n            (placement === 'bottom' && Math.floor(popperOffsets.top) < Math.floor(refOffsets.bottom))\n        );\n\n        const overflowsBoundaries = (\n            (placement === 'left'   && Math.floor(popperOffsets.left) < Math.floor(boundaries.left)) ||\n            (placement === 'right'  && Math.floor(popperOffsets.right) > Math.floor(boundaries.right)) ||\n            (placement === 'top'    && Math.floor(popperOffsets.top) < Math.floor(boundaries.top)) ||\n            (placement === 'bottom' && Math.floor(popperOffsets.bottom) > Math.floor(boundaries.bottom))\n        );\n\n        // flip the variation if required\n        const isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n        const flippedVariation = !!options.flipVariations && (\n            (isVertical  && variation === 'start' && Math.floor(popperOffsets.left) < Math.floor(boundaries.left)) ||\n            (isVertical  && variation === 'end'   && Math.floor(popperOffsets.right) > Math.floor(boundaries.right)) ||\n            (!isVertical && variation === 'start' && Math.floor(popperOffsets.top) < Math.floor(boundaries.top)) ||\n            (!isVertical && variation === 'end'   && Math.floor(popperOffsets.bottom) > Math.floor(boundaries.bottom))\n        );\n\n        if (overlapsRef || overflowsBoundaries || flippedVariation) {\n            // this boolean to detect any flip loop\n            data.flipped = true;\n\n            if (overlapsRef || overflowsBoundaries) {\n                placement = flipOrder[index + 1];\n            }\n\n            if (flippedVariation) {\n                variation = getOppositeVariation(variation);\n            }\n\n            data.placement = placement + (variation ? '-' + variation : '');\n            data.offsets.popper = getPopperOffsets(data.instance.state, data.instance.popper, data.offsets.reference, data.placement);\n\n            data = runModifiers(data.instance.modifiers, data, 'flip');\n        }\n    });\n    return data;\n}\n","import getClientRect from '../utils/getClientRect';\n\n/**\n * Modifier used to make sure the popper is always near its reference element\n * It cares only about the first axis, you can still have poppers with margin\n * between the popper and its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function keepTogether(data) {\n    const popper  = getClientRect(data.offsets.popper);\n    const reference = data.offsets.reference;\n    const f = Math.floor;\n    const placement = data.placement.split('-')[0];\n\n    if (['top', 'bottom'].indexOf(placement) !== -1) {\n        if (popper.right < f(reference.left)) {\n            data.offsets.popper.left = f(reference.left) - popper.width;\n        }\n        if (popper.left > f(reference.right)) {\n            data.offsets.popper.left = f(reference.right);\n        }\n    } else {\n        if (popper.bottom < f(reference.top)) {\n            data.offsets.popper.top = f(reference.top) - popper.height;\n        }\n        if (popper.top > f(reference.bottom)) {\n            data.offsets.popper.top = f(reference.bottom);\n        }\n    }\n\n    return data;\n}\n","import isNumeric from '../utils/isNumeric';\nimport getClientRect from '../utils/getClientRect';\n\n/**\n * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n * The offsets will shift the popper on the side of its reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n *      Basic usage allows a number used to nudge the popper by the given amount of pixels.\n *      You can pass a percentage value as string (eg. `20%`) to nudge by the given percentage (relative to reference element size)\n *      Other supported units are `vh` and `vw` (relative to viewport)\n *      Additionally, you can pass a pair of values (eg. `10 20` or `2vh 20%`) to nudge the popper\n *      on both axis.\n *      A note about percentage values, if you want to refer a percentage to the popper size instead of the reference element size,\n *      use `%p` instead of `%` (eg: `20%p`). To make it clearer, you can replace `%` with `%r` and use eg.`10%p 25%r`.\n *      > **Heads up!** The order of the axis is relative to the popper placement: `bottom` or `top` are `X,Y`, the other are `Y,X`\n * @returns {Object} The data object, properly modified\n */\nexport default function offset(data, options) {\n    const placement = data.placement;\n    const popper  = data.offsets.popper;\n\n    let offsets;\n    if (isNumeric(options.offset)) {\n        offsets = [options.offset, 0];\n    } else {\n        // split the offset in case we are providing a pair of offsets separated\n        // by a blank space\n        offsets = options.offset.split(' ');\n\n        // itherate through each offset to compute them in case they are percentages\n        offsets = offsets.map((offset, index) => {\n            // separate value from unit\n            const split = offset.match(/(\\d*\\.?\\d*)(.*)/);\n            const value = +split[1];\n            const unit = split[2];\n\n            // use height if placement is left or right and index is 0 otherwise use width\n            // in this way the first offset will use an axis and the second one\n            // will use the other one\n            let useHeight = placement.indexOf('right') !== -1 || placement.indexOf('left') !== -1;\n\n            if (index === 1) {\n                useHeight = !useHeight;\n            }\n\n            const measurement = useHeight ? 'height' : 'width';\n\n            // if is a percentage, we calculate the value of it using as base the\n            // sizes of the reference element\n            if (unit === '%' || unit === '%r') {\n                const referenceRect = getClientRect(data.offsets.reference);\n                let len = referenceRect[measurement];\n                return (len / 100) * value;\n            }\n            // if is a percentage relative to the popper, we calculate the value of it using\n            // as base the sizes of the popper\n            else if (unit === '%p') {\n                const popperRect = getClientRect(data.offsets.popper);\n                let len = popperRect[measurement];\n                return (len / 100) * value;\n            }\n            // if is a vh or vw, we calculate the size based on the viewport\n            else if (unit === 'vh' || unit === 'vw') {\n                let size;\n                if (unit === 'vh') {\n                    size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n                } else {\n                    size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n                }\n                return (size / 100) * value;\n            }\n            // if is an explicit pixel unit, we get rid of the unit and keep the value\n            else if (unit === 'px') {\n                return +value;\n            }\n            // if is an implicit unit, it's px, and we return just the value\n            else {\n                return +offset;\n            }\n        });\n    }\n\n    if (data.placement.indexOf('left') !== -1) {\n        popper.top += offsets[0];\n        popper.left -= offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('right') !== -1) {\n        popper.top += offsets[0];\n        popper.left += offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('top') !== -1) {\n        popper.left += offsets[0];\n        popper.top -= offsets[1] || 0;\n    }\n    else if (data.placement.indexOf('bottom') !== -1) {\n        popper.left += offsets[0];\n        popper.top += offsets[1] || 0;\n    }\n    return data;\n}\n","import getClientRect from '../utils/getClientRect';\nimport getOppositePlacement from '../utils/getOppositePlacement';\nimport getOffsetParent from '../utils/getOffsetParent';\nimport getBoundaries from '../utils/getBoundaries';\n\n/**\n * Modifier used to prevent the popper from being positioned outside the boundary.\n *\n * An scenario exists where the reference itself is not within the boundaries. We can\n * say it has \"escaped the boundaries\" â€” or just \"escaped\". In this case we need to\n * decide whether the popper should either:\n *\n * - detach from the reference and remain \"trapped\" in the boundaries, or\n * - if it should be ignore the boundary and \"escape with the reference\"\n *\n * When `escapeWithReference` is `true`, and reference is completely outside the\n * boundaries, the popper will overflow (or completely leave) the boundaries in order\n * to remain attached to the edge of the reference.\n *\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function preventOverflow(data, options) {\n    const boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n    const boundaries = getBoundaries(data.instance.popper, options.padding, boundariesElement);\n    options.boundaries = boundaries;\n\n    const order = options.priority;\n    let popper = getClientRect(data.offsets.popper);\n\n    const check = {\n        left() {\n            let left = popper.left;\n            if (popper.left < boundaries.left && !shouldOverflowBoundary(data, options, 'left')) {\n                left = Math.max(popper.left, boundaries.left);\n            }\n            return { left };\n        },\n        right() {\n            let left = popper.left;\n            if (popper.right > boundaries.right && !shouldOverflowBoundary(data, options, 'right')) {\n                left = Math.min(popper.left, boundaries.right - popper.width);\n            }\n            return { left };\n        },\n        top() {\n            let top = popper.top;\n            if (popper.top < boundaries.top && !shouldOverflowBoundary(data, options, 'top')) {\n                top = Math.max(popper.top, boundaries.top);\n            }\n            return { top };\n        },\n        bottom() {\n            let top = popper.top;\n            if (popper.bottom > boundaries.bottom && !shouldOverflowBoundary(data, options, 'bottom')) {\n                top = Math.min(popper.top, boundaries.bottom - popper.height);\n            }\n            return { top };\n        }\n    };\n\n    order.forEach((direction) => {\n        popper = {...popper, ...check[direction]()};\n    });\n\n    data.offsets.popper = popper;\n\n    return data;\n}\n\n/**\n * Determine if the popper should overflow a boundary edge to stay together with the reference.\n */\nfunction shouldOverflowBoundary(data, options, overflowDirection) {\n    if (!options.escapeWithReference) {\n        return false;\n    }\n\n    if (data.flipped && isSameAxis(data.originalPlacement, overflowDirection)) {\n        return true;\n    }\n\n    if (!isSameAxis(data.originalPlacement, overflowDirection)) {\n        return true;\n    }\n\n    return true;\n}\n\n/**\n * Determine if two placement values are on the same axis.\n */\nfunction isSameAxis(a, b) {\n    // placement syntax:\n    //\n    //     ( \"top\" | \"right\" | \"bottom\" | \"left\" ) ( \"-start\" | \"\" | \"-end\" )\n    //     |------------- Direction -------------|\n    //\n    const aDirection = a.split('-')[0];\n    const bDirection = b.split('-')[0];\n\n    return aDirection === bDirection || aDirection === getOppositePlacement(b);\n}\n","import getClientRect from '../utils/getClientRect';\n\n/**\n * Modifier used to shift the popper on the start or end of its reference element side\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function shift(data) {\n    const placement = data.placement;\n    const basePlacement = placement.split('-')[0];\n    const shiftvariation = placement.split('-')[1];\n\n    // if shift shiftvariation is specified, run the modifier\n    if (shiftvariation) {\n        const reference = data.offsets.reference;\n        const popper = getClientRect(data.offsets.popper);\n\n        const shiftOffsets = {\n            y: {\n                start:  { top: reference.top },\n                end:    { top: reference.top + reference.height - popper.height }\n            },\n            x: {\n                start:  { left: reference.left },\n                end:    { left: reference.left + reference.width - popper.width }\n            }\n        };\n\n        const axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';\n\n        data.offsets.popper = {...popper, ...shiftOffsets[axis][shiftvariation]};\n    }\n\n    return data;\n}\n","import isModifierRequired from '../utils/isModifierRequired';\n\n/**\n * Modifier used to hide the popper when its reference element is outside of the\n * popper boundaries. It will set an x-hidden attribute which can be used to hide\n * the popper when its reference is out of boundaries.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n        console.warn('WARNING: preventOverflow modifier is required by hide modifier in order to work, be sure to include it before hide!');\n        return data;\n    }\n\n    const refRect = data.offsets.reference;\n    const bound = data.instance.modifiers.filter((modifier) => modifier.name ==='preventOverflow')[0].boundaries;\n\n    if (\n        refRect.bottom < bound.top ||\n        refRect.left > bound.right ||\n        refRect.top > bound.bottom ||\n        refRect.right < bound.left\n    ) {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === true) { return data; }\n\n        data.hide = true;\n        data.attributes['x-out-of-boundaries'] = '';\n    } else {\n        // Avoid unnecessary DOM access if visibility hasn't changed\n        if (data.hide === false) { return data; }\n\n        data.hide = false;\n        data.attributes['x-out-of-boundaries'] = false;\n    }\n\n    return data;\n}\n","import getClientRect from '../utils/getClientRect';\nimport getOppositePlacement from '../utils/getOppositePlacement';\n\n/**\n * Modifier used to make the popper flow toward the inner of the reference element.\n * By default, when this modifier is disabled, the popper will be placed outside\n * the reference element.\n * @method\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nexport default function inner(data) {\n    const placement = data.placement;\n    const basePlacement = placement.split('-')[0];\n    const popper = getClientRect(data.offsets.popper);\n    const reference = getClientRect(data.offsets.reference);\n    const isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n    const subtractLength = (['top', 'left'].indexOf(basePlacement) === -1);\n\n    popper[isHoriz ? 'left' : 'top'] = reference[placement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n    data.placement = getOppositePlacement(placement);\n    data.offsets.popper = getClientRect(popper);\n\n    return data;\n}\n","import applyStyle, { applyStyleOnLoad } from './applyStyle';\nimport arrow from './arrow';\nimport flip from './flip';\nimport keepTogether from './keepTogether';\nimport offset from './offset';\nimport preventOverflow from './preventOverflow';\nimport shift from './shift';\nimport hide from './hide';\nimport inner from './inner';\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.\n * Popper.js uses a set of 7 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Each modifier is an object containing several properties listed below.\n * @namespace Modifiers\n * @param {Object} modifier - Modifier descriptor\n * @param {Integer} modifier.order\n *      The `order` property defines the execution order of the modifiers.\n *      The built-in modifiers have orders with a gap of 100 units in between,\n *      this allows you to inject additional modifiers between the existing ones\n *      without having to redefine the order of all of them.\n *      The modifiers are executed starting from the one with the lowest order.\n * @param {Boolean} modifier.enabled - When `true`, the modifier will be used.\n * @param {Modifiers~modifier} modifier.function - Modifier function.\n * @param {Modifiers~onLoad} modifier.onLoad - Function executed on popper initalization\n * @return {Object} data - Each modifier must return the modified `data` object.\n */\nexport default {\n     shift: {\n         order: 100,\n         enabled: true,\n         function: shift,\n     },\n     offset: {\n         order: 200,\n         enabled: true,\n         function: offset,\n         // nudges popper from its origin by the given amount of pixels (can be negative)\n         offset: 0,\n     },\n     preventOverflow: {\n         order: 300,\n         enabled: true,\n         function: preventOverflow,\n         // popper will try to prevent overflow following these priorities\n         //  by default, then, it could overflow on the left and on top of the boundariesElement\n         priority: ['left', 'right', 'top', 'bottom'],\n         // amount of pixel used to define a minimum distance between the boundaries and the popper\n         // this makes sure the popper has always a little padding between the edges of its container\n         padding: 5,\n         boundariesElement: 'scrollParent',\n     },\n     keepTogether: {\n         order: 400,\n         enabled: true,\n         function: keepTogether\n     },\n     arrow: {\n         order: 500,\n         enabled: true,\n         function: arrow,\n         // selector or node used as arrow\n         element: '[x-arrow]'\n     },\n     flip: {\n         order: 600,\n         enabled: true,\n         function: flip,\n         // the behavior used to change the popper's placement\n         behavior: 'flip',\n         // the popper will flip if it hits the edges of the boundariesElement - padding\n         padding: 5,\n         boundariesElement: 'viewport'\n     },\n     inner: {\n         order: 700,\n         enabled: false,\n         function: inner,\n     },\n     hide: {\n         order: 800,\n         enabled: true,\n         function: hide\n     },\n     applyStyle: {\n         order: 900,\n         enabled: true,\n         // if true, it uses the CSS 3d transformation to position the popper\n         gpuAcceleration: true,\n         function: applyStyle,\n         onLoad: applyStyleOnLoad,\n     }\n }\n\n\n /**\n  * Modifiers can edit the `data` object to change the beheavior of the popper.\n  * This object contains all the informations used by Popper.js to compute the\n  * popper position.\n  * The modifier can edit the data as needed, and then `return` it as result.\n  *\n  * @callback Modifiers~modifier\n  * @param {dataObject} data\n  * @return {dataObject} modified data\n  */\n\n /**\n  * The `dataObject` is an object containing all the informations used by Popper.js\n  * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n  * @name dataObject\n  * @property {Object} data.instance The Popper.js instance\n  * @property {String} data.placement Placement applied to popper\n  * @property {String} data.originalPlacement Placement originally defined on init\n  * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n  * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.\n  * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n  * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)\n  * @property {Object} data.boundaries Offsets of the popper boundaries\n  * @property {Object} data.offsets The measurements of popper, reference and arrow elements.\n  * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n  * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n  * @property {Object} data.offsets.arro] `top` and `left` offsets, only one of them will be different from 0\n  */\n","// Utils\nimport Utils from './utils/index';\nimport debounce from './utils/debounce';\nimport setStyles from './utils/setStyles';\nimport isTransformed from './utils/isTransformed';\nimport getSupportedPropertyName from './utils/getSupportedPropertyName';\nimport getPosition from './utils/getPosition';\nimport getReferenceOffsets from './utils/getReferenceOffsets';\nimport getPopperOffsets from './utils/getPopperOffsets';\nimport isFunction from './utils/isFunction';\nimport setupEventListeners from './utils/setupEventListeners';\nimport removeEventListeners from './utils/removeEventListeners';\nimport runModifiers from './utils/runModifiers';\nimport isModifierEnabled from './utils/isModifierEnabled';\nimport computeAutoPlacement from './utils/computeAutoPlacement';\n\n// Modifiers\nimport modifiers from './modifiers/index';\n\n// default options\nconst DEFAULTS = {\n    // placement of the popper\n    placement: 'bottom',\n\n    // whether events (resize, scroll) are initially enabled\n    eventsEnabled: true,\n\n    /**\n     * Callback called when the popper is created.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback createCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onCreate: () => {},\n\n    /**\n     * Callback called when the popper is updated, this callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.\n     * By default, is set to no-op.\n     * Access Popper.js instance with `data.instance`.\n     * @callback updateCallback\n     * @static\n     * @param {dataObject} data\n     */\n    onUpdate: () => {},\n\n    // list of functions used to modify the offsets before they are applied to the popper\n    modifiers,\n};\n\n/**\n * Create a new Popper.js instance\n * @class Popper\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper.\n * @param {Object} options\n * @param {String} options.placement=bottom\n *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),\n *      left(-start, -end)`\n *\n * @param {Boolean} options.eventsEnabled=true\n *      Whether events (resize, scroll) are initially enabled\n * @param {Boolean} options.gpuAcceleration=true\n *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n *      browser to use the GPU to accelerate the rendering.\n *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n *\n * @param {Number} options.boundariesPadding=5\n *      Additional padding for the boundaries\n *\n * @param {Boolean} options.removeOnDestroy=false\n *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n *\n * @param {Object} options.modifiers\n *      List of functions used to modify the data before they are applied to the popper (see source code for default values)\n *\n * @param {Object} options.modifiers.arrow - Arrow modifier configuration\n * @param {HTMLElement|String} options.modifiers.arrow.element='[x-arrow]'\n *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n *      reference element.\n *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n *\n * @param {Object} options.modifiers.offset - Offset modifier configuration\n * @param {Number} options.modifiers.offset.offset=0\n *      Amount of pixels the popper will be shifted (can be negative).\n *\n * @param {Object} options.modifiers.preventOverflow - PreventOverflow modifier configuration\n * @param {Array} [options.modifiers.preventOverflow.priority=['left', 'right', 'top', 'bottom']]\n *      Priority used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n *      this means that the last one will never overflow\n * @param {Number} options.modifiers.preventOverflow.boundariesElement='scrollParent'\n *      Boundaries used by the modifier, can be `scrollParent`, `window`, `viewport` or any DOM element.\n * @param {Number} options.modifiers.preventOverflow.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @param {Object} options.modifiers.flip - Flip modifier configuration\n * @param {String|Array} options.modifiers.flip.behavior='flip'\n *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n *      its axis (`right - left`, `top - bottom`).\n *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n * @param {String|Element} options.modifiers.flip.boundariesElement='viewport'\n *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n *      of the defined boundaries (except if `keepTogether` is enabled)\n *\n * @param {Object} options.modifiers.inner - Inner modifier configuration\n * @param {Number} options.modifiers.innner.enabled=false\n *      Set to `true` to make the popper flow toward the inner of the reference element.\n *\n * @param {Number} options.modifiers.flip.padding=5\n *      Amount of pixel used to define a minimum distance between the boundaries and the popper\n *      this makes sure the popper has always a little padding between the edges of its container.\n *\n * @return {Object} instance - The generated Popper.js instance\n */\nexport default class Popper {\n    constructor(reference, popper, options = {}) {\n        // make update() debounced, so that it only runs at most once-per-tick\n        this.update = debounce(this.update.bind(this));\n\n        // with {} we create a new object with the options inside it\n        this.options = {...Popper.Defaults, ...options};\n\n        // init state\n        this.state = {\n            isDestroyed: false,\n            isCreated: false,\n        };\n\n        // get reference and popper elements (allow jQuery wrappers)\n        this.reference = reference.jquery ? reference[0] : reference;\n        this.popper = popper.jquery ? popper[0] : popper;\n\n        // refactoring modifiers' list (Object => Array)\n        this.modifiers = Object.keys(Popper.Defaults.modifiers)\n                               .map((name) => ({name, ...Popper.Defaults.modifiers[name]}));\n\n        // assign default values to modifiers, making sure to override them with\n        // the ones defined by user\n        this.modifiers = this.modifiers.map((defaultConfig) => {\n            const userConfig = (options.modifiers && options.modifiers[defaultConfig.name]) || {};\n            return {...defaultConfig, ...userConfig};\n        });\n\n        // add custom modifiers to the modifiers list\n        if (options.modifiers) {\n            this.options.modifiers = {...{}, ...Popper.Defaults.modifiers, ...options.modifiers};\n            Object.keys(options.modifiers).forEach((name) => {\n                // take in account only custom modifiers\n                if (Popper.Defaults.modifiers[name] === undefined) {\n                    const modifier = options.modifiers[name];\n                    modifier.name = name;\n                    this.modifiers.push(modifier);\n                }\n            });\n        }\n\n        // get the popper position type\n        this.state.position = getPosition(this.reference);\n\n        // sort the modifiers by order\n        this.modifiers = this.modifiers.sort((a, b) => a.order - b.order);\n\n        // modifiers have the ability to execute arbitrary code when Popper.js get inited\n        // such code is executed in the same order of its modifier\n        // they could add new properties to their options configuration\n        // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n        this.modifiers.forEach((modifierOptions) => {\n            if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n                modifierOptions.onLoad(\n                    this.reference,\n                    this.popper,\n                    this.options,\n                    modifierOptions,\n                    this.state\n                );\n            }\n        });\n\n        // determine how we should set the origin of offsets\n        this.state.isParentTransformed = isTransformed(this.popper.parentNode);\n\n        // fire the first update to position the popper in the right place\n        this.update();\n\n        const eventsEnabled = this.options.eventsEnabled;\n        if (eventsEnabled) {\n            // setup event listeners, they will take care of update the position in specific situations\n            this.enableEventListeners();\n        }\n\n        this.state.eventsEnabled = eventsEnabled;\n    }\n\n    //\n    // Methods\n    //\n\n    /**\n     * Updates the position of the popper, computing the new offsets and applying the new style\n     * Prefer `scheduleUpdate` over `update` because of performance reasons\n     * @method\n     * @memberof Popper\n     */\n    update() {\n        // if popper is destroyed, don't perform any further update\n        if (this.state.isDestroyed) { return; }\n\n        let data = {\n            instance: this,\n            styles: {},\n            attributes: {},\n            flipped: false,\n            offsets: {},\n        };\n\n        // make sure to apply the popper position before any computation\n        this.state.position = getPosition(this.reference);\n        setStyles(this.popper, { position: this.state.position});\n\n        // compute reference element offsets\n        data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);\n\n        // compute auto placement, store placement inside the data object,\n        // modifiers will be able to edit `placement` if needed\n        // and refer to originalPlacement to know the original value\n        data.placement = computeAutoPlacement(\n            this.options.placement,\n            data.offsets.reference,\n            this.popper\n        );\n\n        // store the computed placement inside `originalPlacement`\n        data.originalPlacement = this.options.placement;\n\n        // compute the popper offsets\n        data.offsets.popper = getPopperOffsets(\n            this.state,\n            this.popper,\n            data.offsets.reference,\n            data.placement\n        );\n\n        // run the modifiers\n        data = runModifiers(this.modifiers, data);\n\n        // the first `update` will call `onCreate` callback\n        // the other ones will call `onUpdate` callback\n        if (!this.state.isCreated) {\n            this.state.isCreated = true;\n            this.options.onCreate(data);\n        } else {\n            this.options.onUpdate(data);\n        }\n    }\n\n    /**\n     * Schedule an update, it will run on the next UI update available\n     * @method\n     * @memberof Popper\n     */\n    scheduleUpdate = () => this.scheduledUpdate = requestAnimationFrame(this.update);\n\n    /**\n     * Destroy the popper\n     * @method\n     * @memberof Popper\n     */\n    destroy() {\n        this.state.isDestroyed = true;\n\n        // touch DOM only if `applyStyle` modifier is enabled\n        if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n            this.popper.removeAttribute('x-placement');\n            this.popper.style.left = '';\n            this.popper.style.position = '';\n            this.popper.style.top = '';\n            this.popper.style[getSupportedPropertyName('transform')] = '';\n        }\n\n        this.disableEventListeners();\n\n        // remove the popper if user explicity asked for the deletion on destroy\n        // do not use `remove` because IE11 doesn't support it\n        if (this.options.removeOnDestroy) {\n            this.popper.parentNode.removeChild(this.popper);\n        }\n        return this;\n    }\n\n    /**\n     * it will add resize/scroll events and start recalculating\n     * position of the popper element when they are triggered\n     * @method\n     * @memberof Popper\n     */\n    enableEventListeners() {\n        if (!this.state.eventsEnabled) {\n            this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n        }\n    }\n\n    /**\n     * it will remove resize/scroll events and won't recalculate\n     * popper position when they are triggered. It also won't trigger onUpdate callback anymore,\n     * unless you call 'update' method manually.\n     * @method\n     * @memberof Popper\n     */\n    disableEventListeners() {\n        if (this.state.eventsEnabled) {\n            cancelAnimationFrame(this.scheduledUpdate);\n            this.state = removeEventListeners(this.reference, this.state);\n        }\n    }\n\n    /**\n     * Collection of utilities useful when writing custom modifiers\n     * @memberof Popper\n     */\n    static Utils = Utils;\n\n    /**\n     * List of accepted placements to use as values of the `placement` option\n     * @memberof Popper\n     */\n     static placements = [\n         'auto',\n         'auto-start',\n         'auto-end',\n         'top',\n         'top-start',\n         'top-end',\n         'right',\n         'right-start',\n         'right-end',\n         'bottom',\n         'bottom-start',\n         'bottom-end',\n         'left',\n         'left-start',\n         'left-end',\n     ];\n\n    /**\n     * Default Popper.js options\n     * @memberof Popper\n     */\n    static Defaults = DEFAULTS;\n}\n"],"names":["getOffsetParent","element","offsetParent","nodeName","window","document","documentElement","getStyleComputedProperty","property","nodeType","css","getComputedStyle","getParentNode","parentNode","host","getScrollParent","indexOf","body","overflow","overflowX","overflowY","test","getWindowSizes","html","Math","max","scrollHeight","offsetHeight","clientHeight","scrollWidth","offsetWidth","clientWidth","getOffsetRect","elementRect","width","height","offsetLeft","offsetTop","right","left","bottom","top","isFixed","getPosition","container","isParentFixed","getBoundingClientRect","rect","result","navigator","appVersion","scrollTop","scrollLeft","horizScrollbar","vertScrollbar","getScroll","side","upperSide","scrollingElement","getOffsetRectRelativeToCustomParent","parent","fixed","transformed","scrollParent","parentRect","contains","getTotalScroll","scroll","getBoundaries","popper","padding","boundariesElement","boundaries","boundariesNode","computeAutoPlacement","placement","referenceOffsets","refRect","sides","computedPlacement","Object","keys","sort","a","b","variation","split","nativeHints","fn","some","hint","toString","longerTimeoutBrowsers","timeoutDuration","i","length","userAgent","microtaskDebounce","scheduled","elem","createElement","observer","MutationObserver","observe","childList","textContent","taskDebounce","supportsNativeMutationObserver","isNative","findIndex","arr","prop","value","match","filter","obj","getClientRect","popperOffsets","getOuterSizes","display","style","visibility","styles","x","parseFloat","marginTop","marginBottom","y","marginLeft","marginRight","getOppositePlacement","hash","replace","matched","getPopperOffsets","state","popperRect","position","isHoriz","mainSide","secondarySide","measurement","secondaryMeasurement","getReferenceOffsets","reference","isParentTransformed","getSupportedPropertyName","prefixes","upperProp","charAt","toUpperCase","slice","forEach","prefix","toCheck","isFunction","functionToCheck","getType","call","isModifierEnabled","modifiers","modifierName","name","enabled","isModifierRequired","requestingName","requestedName","requesting","modifier","order","isNumeric","n","isNaN","isFinite","isTransformed","removeEventListeners","removeEventListener","updateBound","scrollElement","eventsEnabled","runModifiers","data","ends","modifiersToRun","undefined","function","setAttributes","attributes","setAttribute","removeAttribute","setStyles","unit","setupEventListeners","options","addEventListener","passive","target","applyStyle","offsets","round","prefixedProperty","gpuAcceleration","instance","arrow","arrowElement","applyStyleOnLoad","modifierOptions","arrowEl","querySelector","warn","arrowElStyle","isVertical","len","altSide","opSide","arrowElSize","center","sideValue","min","getOppositeVariation","flip","flipped","originalPlacement","placementOpposite","flipOrder","behavior","step","index","refOffsets","overlapsRef","floor","overflowsBoundaries","flippedVariation","flipVariations","keepTogether","f","offset","map","useHeight","referenceRect","size","innerHeight","innerWidth","preventOverflow","priority","check","shouldOverflowBoundary","direction","overflowDirection","escapeWithReference","isSameAxis","aDirection","bDirection","shift","basePlacement","shiftvariation","shiftOffsets","axis","hide","bound","inner","subtractLength","DEFAULTS","Popper","scheduleUpdate","scheduledUpdate","requestAnimationFrame","update","debounce","bind","Defaults","jquery","defaultConfig","userConfig","push","onLoad","enableEventListeners","isDestroyed","isCreated","onCreate","onUpdate","disableEventListeners","removeOnDestroy","removeChild","Utils","placements"],"mappings":"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"}